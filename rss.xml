<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[bono's blog]]></title><description><![CDATA[about javascript, react, css]]></description><link>https://blueshw.github.io</link><generator>RSS for Node</generator><lastBuildDate>Fri, 28 Sep 2018 14:37:34 GMT</lastBuildDate><item><title><![CDATA[글쓰기와 마라톤의 공통점]]></title><description><![CDATA[…]]></description><link>https://blueshw.github.io/2018/09/20/writing_and_marathon/</link><guid isPermaLink="false">https://blueshw.github.io/2018/09/20/writing_and_marathon/</guid><pubDate>Thu, 20 Sep 2018 01:37:26 GMT</pubDate><content:encoded>&lt;p&gt;요즘, 습관으로 만들려고 노력하는 두 가지가 있다. &lt;strong&gt;&lt;em&gt;하나는 글쓰기, 하나는 마라톤&lt;/em&gt;&lt;/strong&gt; (아래부터는 달리기로 쓰겠다)이다. 글쓰기는 시작한지 세달 정도 지났고, 달리기는 시작한지 겨우 한달밖에 안됐다. 두 가지 모두 저녁시간을 활용한다. 출근이 늦기 때문에 아침 시간을 이용할 수도 있지만, 죽었다 깨어나도 아침은 무리다. 일어나지 못하기 때문이다. 예전에 몇 번 아침 일찍 운동하려고 헬스장 등록도 해봤다. 하지만, 대부분 세 달을 넘기지 못했다. 그래서 아예 아침에 뭔가 하겠다는 생각은 접었다. 대신 조금 늦게 자더라도 저녁시간을 활용하기로 했다. 물론, 저녁 시간도 제약은 많다. 예를들어, 회사일이 바빠 늦게까지 야근해야 할 수도 있고, 갑자기 저녁약속이 생길수도 있다. 또는 몸이 아파서 휴식을 취해야할때도 있다(실제로 지난주 내내 아파서 글이고 달리기고 아무것도 못했다). 만약 집에 일찍 왔다 하더라도 집에는 아이가 기다리고 있다. 저녁을 먹고 아이가 잠들기 전까지는 아이와 시간을 보낸다. 내가 하고싶은 일도 중요하지만, 아이와 보내는 시간이 훨씬 중요하다 생각한다. 10 시 30 분쯤 되면 아이가 잠이 드는데, 이때부터 나를 위한 시간이 시작된다.&lt;/p&gt;
&lt;p&gt;내가 글쓰기와 달리기를 습관으로 만들려는 이유는 무엇일까? 처음부터 두 가지를 같이 하려던 생각은 없었다. 글쓰기는 오랜 숙원이었기 때문에 이번에 제대로 해보자는 생각이었다(벌써 잘 안한다ㅠㅠ). 달리기는 아마 이사하면서 시작하게 된것같다. 이사한 집 앞에 하천이 흐르는데, 정비도 잘 되어있어 달리기 딱 좋다. 특히 지금은 더위가 한풀 꺾이고 여름이 지나가는 시기(8 월 중순부터 10 월)라 더욱 달리기 좋은 환경이다. 그렇게 처음 한 두번 뛰어보니 욕심이 났고 마라톤에 도전해보고 싶다는 생각까지 하게되었다. 그래서 본격적으로 달리기도 꾸준히 해보자고 마음먹었다. 이렇게 나의 글쓰기와 달리기가 시작되었다.&lt;/p&gt;
&lt;p&gt;어느날, 하천 변을 달리다보니 달리기와 글쓰기가 비슷한점이 많다는 생각이 들었다. 글쓰기도 그렇고 달리기도 그렇고 해보면 알지만, 정말 인내가 필요하다. 글 하나를 쓰려면 주제 선정부터 시작해 마지막 문장을 쓸때까지, 글을 채워나가는게 보통일이 아님을 알 수 있다. 글의 종류에 따라 다르지만, 짧게는 2 시간에서 길게는 4~5 시간 정도가 소요 되기도 한다. 아이가 잠들고 10 시 30 분부터 쓰기 시작하더라도 빨리 자야 1 시, 늦으면 3 시까지 못자기도 한다. 시간이 너무 늦어지면 하루에 하나의 글을 완성하지 못한다. 어쩔수 없이 이틀이나 사흘에 걸쳐 완성해야한다.&lt;/p&gt;
&lt;p&gt;글을 꾸준히 쓰기는 훨씬 어렵다. 하나의 글을 쓰는것은 몇시간 고생하면 된다. 하지만, 며칠에 한번 또는 일주일에 세번, 이렇게 빈도를 정해놓고 글을 쓰다보면 점점 나태해지기 쉽다. 나도 처음 글쓰기 시작할때는 일주일에 5 개를 쓰겠다고 다짐 했다가 한달 쯤 지나 3 개로 줄더니 이제는 일주일 내내 하나도 안쓸때도 있다. 물론 다양한 소재로 일주일에 몇개씩 글을 쓴다는게 쉬운 일은 아니다. 소재가 풍부하려면 다양한 사람도 만나고 책도 많이 읽어야한다. 그리고 사람을 만나고 책을 읽는것으로 끝내서는 안된다. input 이 들어온만큼 생각도 많이하고 정리도 해야하다. 그래야 제대로된 output 이 나온다. 강한 의지도 필수다. 처음에는 정신의 근육이 글쓰기를 거부하기 때문에 강한 의지가 없으면 지속적으로 글쓰기 힘들다. 언젠가는 습관처럼 몸에 배이는 날이 올것이라 믿으면서 그렇게 노력해야한다.&lt;/p&gt;
&lt;p&gt;달리기도 비슷하다. 규칙적으로 같은 곳을 달려본 사람은 알겠지만, 정말 재미없다. 마음이 맞는 사람과 같이 달리면 좀 낫지만, 혼자 달리거나 런닝머신 위에서 뛸때면 이렇게 재미없는 운동이 또 있겠나 싶다. 그래서 꾸준히 하기 어렵다. 같은 코스를 매일 달린다고 생각해보자. 웬만큼 강한 의지가 없으면 며칠만 지나도 지겨워지고 그러다보면 점점 달리지 않게 된다. 아무런 동기부여가 없으면 나도 똑같이 그렇게 될것을 뻔히 알고 있다. 그렇기 때문에 &lt;em&gt;마라톤 대회 참가&lt;/em&gt; 라는 목표를 설정했다. 그것도 한 두달에 한번씩 꾸준히 참가하는게 목표다. 아무래도 목표가 있으면 없을때보다는 조금 덜 강한 의지만으로도 충분히 이어갈수 있다.&lt;/p&gt;
&lt;p&gt;나는 끈기가 부족한 사람이(었)다. 정말 부족하다. 쉽게 포기하고 오랫동안 지속하는걸 힘들어한다. 그래서 뭐하나 제대로 잘한다 할 만한 것이 없다. 끈기를 키워야할 필요가 있다. 뭐하나 시작하면 끈질기게 물고늘어질 그런 끈기말이다. 없던 능력이 갑자기 생기지는 않겠지만 노력하면 충분히 키울 수 있다. 끈기를 키우기에 가장 좋은 것이 바로 글쓰기와 달리기다. 두가지 다 짧은 시간 노력한다고 빠르게 능력이 향상되지 않는다. 오랜시간 공을 들여야 하고 꾸준히 규칙적으로 해야 한다. 하지만, 오랫동안 지속하면 반드시 성과를 얻을 수 있다. 이건 확실하다(그렇게 믿는다). 나는 글쓰기와 달리기로 나를 개조할 생각이다. 그 동안 쉽게 포기하고 나태한 나를 바꾸기 위해 글쓰기와 달리기를 도구로 사용할 생각이다. 아마 처음에는 많이 힘들것이다. 머리는 글을쓰기 싫어할것이고 몸은 달리기를 거부할 것이다. 초반 몇달이 고비가 될것 같다. 조금만 참자. 조금만 참고 견뎌보자. 글쓰기와 달리기가 내 일부가 될때까지만 참아보자.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[2018 아디다스 마이런 서울 후기]]></title><description><![CDATA[지난주 일요일, 아디다스와 MBC+, 서울시가 주최하는 아디다스  마이런(mirun)  에 다녀왔다. 그런데, 대회가 있기…]]></description><link>https://blueshw.github.io/2018/09/18/review_2018_mirun_seoul/</link><guid isPermaLink="false">https://blueshw.github.io/2018/09/18/review_2018_mirun_seoul/</guid><pubDate>Tue, 18 Sep 2018 01:20:23 GMT</pubDate><content:encoded>&lt;p&gt;지난주 일요일, 아디다스와 MBC+, 서울시가 주최하는 아디다스 &lt;em&gt;마이런(mirun)&lt;/em&gt; 에 다녀왔다. 그런데, 대회가 있기 4 일전, 갑자기 급성편도염에 걸렸다. 아프기 시작한 당일은 회사에 휴가를 쓸정도로 아팠다. 몸이 아픈것도 걱정이었지만 그보다 이번에도(등록후 피치못할 사정으로 불참한 경험이 있다) 마라톤에 참가하지 못할까봐 더 걱정이었다. 다행히 당일 아침, 몸이 많이 회복되었고 무사히 마라톤을 완주할 수 있었다.&lt;/p&gt;
&lt;p&gt;집에서 여의도까지는 꽤나 거리가 있었다. 새벽 5 시에 일어나야했고, 지하철 첫차를 타야 늦지 않게 도착할 수 있었다. 이번 마이런 티셔츠가 유독 튀는 빨간색이라 입고 지하철에 오를 용기가 없었다. 그래서 도중에 갈아입을 요랑으로 다른 티셔츠를 입었다. 그러나 시간이 지날수록 내가 잘못 생각했다는걸 깨달았다. 지하철이 여의도에 가까워질수록 밝은 미소(진짜 그랬다)를 띄고 있는 빨간 티셔츠의 사람들이 하나둘 보이기 시작했다. 시끌벅적한 여러명의 사람들이 함께 타기도 했고, 이어폰을 끼고 혼자서 조용히 타는 사람도 있었다. 다양한 연령에 사는곳도 제각각이었지만, 모두 빨간 티셔츠를 입고 있었고 도착 예정지도 같았다. 바로, 여의도.&lt;/p&gt;
&lt;p&gt;지하철 여의도역에 도착했다. 이른 시간이었지만 정말 많은 사람들이 있었다. 지하철 출구를 나오기 위해 길게 줄을 서야할 정도였다. 출구를 나오니 비가 내리고 있었다. 젖을 정도는 아니었고 딱 기분 좋을 정도로 보슬보슬 내리고 있었다. 주위를 둘러보니 거의 대부분 빨간 셔츠를 입고 있었다. 여기서는 오히려 다른 색상의 옷을 입고 있으면 더 튀어 보일것 같았다. 그래서 나도 얼른 빨간색 티셔츠로 갈아입었다. 몇분 걸어 여의도 공원에 도착하니 정말 장관이 펼쳐져 있었다. 빨간색 티셔츠를 입은 만명 넘는(아마도…) 사람들이 여의도 공원을 물들이고 있었다. 시끄럽지만 기분좋은 음악이 들리고 있었고, 무대에는 파이팅 넘치는 MC 가 사람들의 흥을 돋구고 있었다. 짐을 맡기는 차량이 7 시 20 분까지만 운영했기 우선 짐을 맡겼다.&lt;/p&gt;
&lt;p&gt;잠시 후 같이 뛰기로 한 일행을 만났다. 그리고 몸을 풀기 위해 광장 한켠에 자리잡았다. 무대위 트레이너의 동작에 맞춰 빡세게 몸을 풀었다. 아침일찍 일어나 찌뿌둥한 상태에서 몸을 풀어주지 않으면 다치기 쉽다. 그래서 반드시 빡세게 몸을 풀어주어야 한다. 20 여분간의 스트레칭이 끝나고 드디어 출발선으로 향했다. 출발선은 총 네개가 있었고, A 부터 D 까지 그룹으로 나누었다. 신청단계에서 자신의 목표 시간에 맞춰서 그룹을 선택할수 있었다. 이는 빨리 뛰는 사람과 천천히 뛰는 사람이 질서없이 모여있으면, 레이스 도중에 부딪히거나 발이 엉켜 다치는 사고가 발생할 수 있다. 이런 사고를 미연에 방지하기 위해 그룹을 분리한 것이다.&lt;/p&gt;
&lt;p&gt;드디어 시작, 뛰는 방식도 제각각이었다. 젊은 혈기만 믿고 처음부터 빠르게 치고 나가는 사람, 좀 달려본 사람인것처럼 천천히 자기만의 페이스를 유지하는 사람, 달리기보다는 사진찍기 바쁜 사람 등 다양한 사람들이 뒤엉켜 나아갔다. 혼자서는 많이 달려봤지만, 이렇게 많은 사람들이 모여 달려보는건 처음이었다. 너무 모여있다보니 좌로 우로 뛰어다니며 사람들을 피해 달렸다. 확실히 혼자서 달릴때 보다는 쉽지 않았다. 혼자 달릴때는 내 페이스에 맞춰 속도를 조절하면 되었지만, 이번에는 내 페이스 보다는 주변 사람들과 부딪히거나 발이 엉키지 않도록 조심하면서 뛰는게 우선이었다.&lt;/p&gt;
&lt;p&gt;5Km 정도 지나자 조금 여유가 생겼다. 처음 뛸때보다 도로도 훨씬 넓어졌다. 그리고 이제는 정말 기록에 관심있고 뛰는걸 좋아하는 사람들만 남아서 처음의 그런 혼잡함은 느껴지지 않았다. 힐끔힐끔 순토 시계를 보면서 심박수가 너무 많이 오르지 않도록(대략 160~170) 조절하면서 달렸다. 심박수가 170 이 넘으면 금방 숨이 차서 오랫동안 뛰기 힘들다. 마라톤은 완주가 중요한 스포츠기 때문에 힘이 남는다고 미리 써버리면 안된다. 그러면 완주가 힘들어진다. 시간이 지나 8Km 지점에 도착했다. 시계를 보니 대략 49 분이 지나고 있었다. 2Km 에 11 분, 1Km 를 5 분 30 초 안에만 주파하면 1 시간 이내 완주가 가능하다. 처음 참가하는 대회라 1 시간 5 분 정도를 목표로 잡고 있었다. 그런데, 막상 달리다보니 1 시간 안에 완주가 가능할것 같다는 생각이 머리를 스쳤다. 욕심이 났다. 그래, 달려보자. 심박수도 체크하지 않고 달렸다. 숨이 가빠오는게 느껴졌지만, 좀 있으면 도착한다는 생각에 참았다. 몇번이나 참고 또 참았다. 마지막 500m, 정말 죽을것 같았다. 심박수를 보니 190 이 훌쩍 넘어가고 있었다. 안될것 같았다. 이렇게 달리다가 잘못하면 쓰러질지도 모른다고 생각했다. 속도를 늦췄다. 1 시간 안에 도착하는 것도 중요하지만, 다치지 않는게 우선이었다. 페이스를 조절하면서 조금 달리다 보니 좀 괜찮아지는 느낌이 들었다. 마지막 200m, 에라 모르겠다. 그냥 달렸다. 아무 생각도 안했다. 그냥 골만 보면서 달렸다. 드디어, 골인. 머리가 핑 돌았다. 잠시 쉬다가 아차 싶었다. 순토로 측정하던 운동 시간을 멈추지 않았다. 시계를 보니 1 시간 0 분 11 초를 지나고 있었다. 1 시간이 지난건가? 마지막 200m 전력질주가 원망스러웠다.&lt;/p&gt;
&lt;p&gt;동료는 좀 늦게 도착했다. 이녀석, 요즘 운동 안하더니 배만 나와서 달리지도 못한다. 원래 마라톤 잘 하던 친구였는데, 언제부터인지 운동을 게을리하더니 잘 달리지도 못한다. 그렇게 한참 기다리면서(15 분은 기다렸다) 건네받은 간식으로 허기를 달랬다. 뭐든 먹을 수 있을 것 같았다. 아침으로 간단히 먹긴 했지만, 10Km 정도를 달렸더니 철근도 씹어 먹을 수 있을만큼 배가 고팠다. 조금 있으니 같이 참가한 동료가 도착했다. 잠시 쉬면서 남은 음식을 모두 먹어치우고는 짐을 맡기는 차량으로 향했다. 짐을 찾고 제일 먼저 핸드폰을 켰다. 가슴에 달았던 번호표에 내장된 칩으로 측정한 기록이 도착해 있었기 때문이었다. 기록을 본 순간 마음속으로 소리를 지를 수 밖에 없었다. 그 이유느 바로 문자에 &lt;em&gt;59 분 44 초&lt;/em&gt; 가 찍혀있었기 때문이었다.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/0-07959ea3469b0d5fb4c3027a23a31c6d-79ad4.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 400px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 150%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAeABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIEAwX/xAAYAQACAwAAAAAAAAAAAAAAAAACBAABA//aAAwDAQACEAMQAAABtZ1sIhgl6X5u4s4khMv/xAAdEAADAAICAwAAAAAAAAAAAAABAgMEEgATESMz/9oACAEBAAEFAknPQJPlwEdFBig2OV9F8dRYEZbe2NNWOVyr9rf/xAAZEQADAQEBAAAAAAAAAAAAAAAAAQIRAzH/2gAIAQMBAT8BXPVpXpNTg0tP/8QAFREBAQAAAAAAAAAAAAAAAAAAESD/2gAIAQIBAT8BY//EACEQAAIBAwMFAAAAAAAAAAAAAAABEQIhMQNRcRIiMmGx/9oACAEBAAY/AqW8tF/pFOxS2pcHfpR7kXBpzOBZsLgttc8TqiD/xAAdEAADAQEAAgMAAAAAAAAAAAAAARExIUGBYXGR/9oACAEBAAE/IWXL6NPhv0JlI6FaUcjsWEJSyRovQRlH6CfRK0OPhfIlcvLolCYQ/9oADAMBAAIAAwAAABAwwE//xAAYEQEAAwEAAAAAAAAAAAAAAAABABHwsf/aAAgBAwEBPxBqAUbVCDJSG5GJn//EABgRAQADAQAAAAAAAAAAAAAAAAEAEBEx/9oACAECAQE/EHDkOULk/8QAIBABAQACAAYDAAAAAAAAAAAAAREAITFBYXGRoVGB0f/aAAgBAQABPxAwQC33gV0HKKvWHxE3bxXAgJhZemQ8Ioq35uGAAAPtwcEpm7zrBRlpq766ZqivS75SpNXSOZrXbKRqup5F+MRgAwt4X9z/2Q==&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;img0&quot;
        title=&quot;&quot;
        src=&quot;/static/0-07959ea3469b0d5fb4c3027a23a31c6d-79ad4.jpg&quot;
        srcset=&quot;/static/0-07959ea3469b0d5fb4c3027a23a31c6d-a7b8e.jpg 148w,
/static/0-07959ea3469b0d5fb4c3027a23a31c6d-575d0.jpg 295w,
/static/0-07959ea3469b0d5fb4c3027a23a31c6d-79ad4.jpg 400w&quot;
        sizes=&quot;(max-width: 400px) 100vw, 400px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;정말 재밌었다. 이게 마라톤인가 싶었다. 두 시간 정도밖에 안되는 짧은 시간이었지만 긍정적인 젊은 에너지도 많이 받았다. 이 맛에 다들 마라톤하는구나 싶었다. 이제 한번 끝났다. 그리고 고작 10Km 한번이다. 아직 최종 목표를 확실하게 정하지는 않았지만, 몇년 안에 풀코스에 도전해보고 싶다는 생각이 들었다. 지금은 마음뿐이지만 대회에 한번씩 참가하고 완주할 때 마다 도전은 현실이 될것이다. 다음 마라톤(아마도 춘천)이 기다려진다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[[javascript] call by value]]></title><description><![CDATA[의문은 아래와 같은 코드에서 시작되었습니다. 객체를 매개변수로 받는   함수에 새롭게 만든  객체를 인자로 전달하였습니다. 그리고   함수에서 obj 변수에 새로운 객체를 할당하였습니다. 과연  는 어떤 값이 출력될까요? Call By Value…]]></description><link>https://blueshw.github.io/2018/09/15/pass-by-reference/</link><guid isPermaLink="false">https://blueshw.github.io/2018/09/15/pass-by-reference/</guid><pubDate>Sat, 15 Sep 2018 20:18:08 GMT</pubDate><content:encoded>&lt;p&gt;의문은 아래와 같은 코드에서 시작되었습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function change(obj) {
  obj = { p1: 100 }
}
const o = { p1: 1 };
change(o);
console.log(o);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;객체를 매개변수로 받는 &lt;code class=&quot;language-text&quot;&gt;change&lt;/code&gt; 함수에 새롭게 만든 &lt;code class=&quot;language-text&quot;&gt;o&lt;/code&gt;객체를 인자로 전달하였습니다. 그리고 &lt;code class=&quot;language-text&quot;&gt;change&lt;/code&gt; 함수에서 obj 변수에 새로운 객체를 할당하였습니다. 과연 &lt;code class=&quot;language-text&quot;&gt;o&lt;/code&gt;는 어떤 값이 출력될까요?&lt;/p&gt;
&lt;h3&gt;Call By Value&lt;/h3&gt;
&lt;p&gt;가끔 일하다보면, 정말 기초적인 부분에서 실수하는 경우가 있습니다. 최근에 저도 그랬습니다. 새로운 기술이나 도구 등을 익히는 것도 중요합니다만, 기본을 중요시하는 자세가 우선시해야 한다는걸 새삼 깨닫게 되었습니다. &lt;code class=&quot;language-text&quot;&gt;Call By...&lt;/code&gt;로 시작하는 함수 호출 방법도 기본중에 기본입니다. 언어에 따라서, 호출 방식에 따라서 인자가 평가되는 과정이 달라집니다. 언어를 익힐때 기본중에 기본이죠.&lt;/p&gt;
&lt;p&gt;인자를 전달하는 방식에 따라 함수 호출 방법은 크게 두가지로 나눠집니다. &lt;code class=&quot;language-text&quot;&gt;Call By Value&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;Call By Reference&lt;/code&gt;입니다. 그러면, 자바스크립트는 어떤 방식으로 함수를 호출할까요? 바로 &lt;code class=&quot;language-text&quot;&gt;Call By Value&lt;/code&gt;입니다. 흔히들 잘못 알고 있는 사실이 한가지 있습니다. 바로 함수의 매개변수가 원시타입(Primitive Type)인 경우에는 Call By Value 고, 매개변수가 객체형태면 Call By Reference 로 동작한다는 것입니다. 이는 완전히 잘못된 사실입니다. 블로그를 검색해보면, 이렇게 잘못된 사실을 바탕으로 쓰여진 글을 쉽게 찾아볼 수 있습니다.&lt;/p&gt;
&lt;h4&gt;원시타입 (Primitive Type)&lt;/h4&gt;
&lt;p&gt;자바스크립트에는 5 가지 원시타입이 있습니다. &lt;code class=&quot;language-text&quot;&gt;boolean&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;number&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;string&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt; 이렇게 다섯가지 입니다. 함수의 인자로 원시타입의 값이 전달되면, 함수가 실행될때 전달받은 인자를 복사합니다. 인자가 복사되었기 때문에 전달된 인자와 전달 받은 인자는 전혀 다른 값(주소값이 다른)이 됩니다. 코드로 확인해 보겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function change(pri) {
  pri = 10;
}
const p = 1;
change(p);
console.log(p); // p = 1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;변수 &lt;code class=&quot;language-text&quot;&gt;p&lt;/code&gt;에 1 이 할당된 다음, change 함수의 인자로 p 가 전달되었습니다. change 함수 내에서는 매개변수 &lt;code class=&quot;language-text&quot;&gt;pri&lt;/code&gt;에 10 을 할당하여 값을 변경 시킵니다. change 함수가 호출된 이후 log 를 찍어보면, p 값은 change 함수가 호출되기 전과 동일하게 &lt;code class=&quot;language-text&quot;&gt;1&lt;/code&gt;이 됩니다. 즉, 처음 선언한 &lt;code class=&quot;language-text&quot;&gt;p&lt;/code&gt;와 change 함수로 전달한 인자는 별도의 값으로 존재한다는 뜻입니다.&lt;/p&gt;
&lt;h4&gt;재할당 (Reassigning of Reference Type)&lt;/h4&gt;
&lt;p&gt;주소값을 직접 찍어볼 방법이 없기 때문에(있으면 좀 알려주세요^^;;), &lt;code class=&quot;language-text&quot;&gt;===&lt;/code&gt; 연산자로 참조값이 동일한지 비교해보도록 하겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;let obj = { p1: 10 };
let objCopy = obj;
console.log(obj === objCopy); // true

objCopy = { p2: 100 };
console.log(obj === objCopy); // false&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;obj 라는 객체를 선언합니다. 그리고 objCopy 에 obj 를 할당합니다. 좀더 자세히 알아보기 위해 임의의 주소값으로 표현해보겠습니다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;변수&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;값&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;obj&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&amp;#x3C;0x001&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;objCopy&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&amp;#x3C;0x001&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;주소&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;객체&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;0x001&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;{ p1: 10 }&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;objCopy 는 obj 와 동일한 객체를 가리키고 있습니다. 그래서 &lt;code class=&quot;language-text&quot;&gt;===&lt;/code&gt; 연산자로 비교해보면 서로 같다(true)고 출력됩니다.
그 다음, objCopy 에 새로운 객체를 할당합니다. 그러면, 아래와 같이 바뀝니다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;변수&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;값&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;obj&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&amp;#x3C;0x001&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;objCopy&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&amp;#x3C;0x002&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;주소&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;객체&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;0x001&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;{ p1: 10 }&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;0x002&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;{ p2: 100 }&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;objCopy 의 주소값이 변경되었습니다. objCopy 는 원래 &lt;code class=&quot;language-text&quot;&gt;0x001&lt;/code&gt;라는 주소값을 value 로 가지고 있었습니다. 그런데, 새로운 객체를 할당했더니 주소값이 변경되었습니다. 그 이유는 &lt;code class=&quot;language-text&quot;&gt;{ p2: 100 }&lt;/code&gt;이라는 객체는 새로운 주소로 만들어집니다. 그리고 기존에 잇던 objCopy 라는 변수에 할당했으므로, 이제 objCopy 는 &lt;code class=&quot;language-text&quot;&gt;0x002&lt;/code&gt; 주소값을 가리키게 되었습니다. 이해를 쉽게 하기 위해 코드를 조금 변형시켜보겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;let obj = {p1: 10}; // obj 주소값 : 0x001
let objCopy = obj; // objCopy 주소값 : 0x001
const newObj = {p2: 100}; // newObj 주소값 : 0x002
objCopy = newObj; // objCopy 주소값 : 0x002&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;newObj 라는 새로운 객체가 objCopy 에 할당되었으니 objCopy 가 가리키는 주소값이 당연히 바뀌게 되는 것입니다. 애초에 객체타입(reference type)에 할당되는 값이 실제 객체가 아니라 객체를 가리키는 주소값이기 때문에 당연한 결과인지도 모르겠습니다.&lt;/p&gt;
&lt;h3&gt;인자를 함수내에서 변경(속성만 변경)하면 어떻게 될까?&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function change(obj) {
  obj.p1 = 100
}
const o = { p1: 1 };
change(o);
console.log(o);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;변수&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;값&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;o&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&amp;#x3C;0x001&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;obj&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&amp;#x3C;0x001&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;주소&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;객체&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;0x001&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;{ p1: 1 }&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;처음 할당된 &lt;code class=&quot;language-text&quot;&gt;o&lt;/code&gt; 객체의 주소값은 &lt;code class=&quot;language-text&quot;&gt;0x001&lt;/code&gt;입니다. change 함수를 호출되면 인자 o 가 복사됩니다. 복사된 객체 obj 는 o 객체의 주소값을 갖는 새로운 변수가 됩니다(위의 표 참고). 즉, obj 와 o 두가지 변수가 동일한 객체를 바라보고 있다는 뜻입니다. 그래서 obj 객체의 속성을 변경하면 객체 o 의 속성도 변경됩니다.&lt;/p&gt;
&lt;p&gt;그럼 이제 처음에 봤던 코드를 다시 한번 살펴보도록 합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function change(obj) {
  obj = { p1: 100 }
}
const o = { p1: 1 };
change(o);
console.log(o);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;log 에 찍히는 값은 바로 &lt;code class=&quot;language-text&quot;&gt;{ p1: 1 }&lt;/code&gt;입니다. 위에서 보았던 &lt;code class=&quot;language-text&quot;&gt;재할당&lt;/code&gt;을 잘 기억하면서 위 코드의 주소값 변화를 살펴보겠습니다.&lt;/p&gt;
&lt;p&gt;const o = { p1: 1 };&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;변수&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;값&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;o&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&amp;#x3C;0x001&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;주소&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;객체&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;0x001&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;{ p1: 1 }&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;change(o)호출, 인자(주소값)가 복사됩니다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;변수&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;값&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;o&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&amp;#x3C;0x001&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;obj&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&amp;#x3C;0x001&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;주소&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;객체&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;0x001&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;{ p1: 1 }&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;change 함수 내, obj = { p1: 100 };&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;변수&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;값&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;o&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&amp;#x3C;0x001&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;obj&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&amp;#x3C;0x002&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;주소&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;객체&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;0x001&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;{ p1: 1 }&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;0x002&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;{ p1: 100 }&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;마지막으로 &lt;code class=&quot;language-text&quot;&gt;console.log(o)&lt;/code&gt;에서 &lt;code class=&quot;language-text&quot;&gt;{ p1: 1 }&lt;/code&gt;가 출력됩니다. 즉, 객체가 바뀌지 않았습니다. 이유는 o 객체가 여전히 &lt;code class=&quot;language-text&quot;&gt;0x001&lt;/code&gt;을 가리키고 있기 때문입니다.&lt;/p&gt;
&lt;h3&gt;정리&lt;/h3&gt;
&lt;p&gt;자바스크립트에서 함수 호출시 &lt;code class=&quot;language-text&quot;&gt;call by value&lt;/code&gt;로 인자가 전달됩니다. call by value 는 함수가 호출되면 전달한 인자가 복사됨을 뜻합니다. 인자가 복사되기 때문에 원시타입(primitive type)의 경우에는 함수 바깥의 변수와 서로 별개로 동작합니다. 하지만, array 를 포함한 객체타입이 인자로 전달된 경우에는 변수에 할당되어 있는 &lt;code class=&quot;language-text&quot;&gt;객체의 주소값&lt;/code&gt;이 복사됩니다. 그래서 함수내에서 매개변수의 속성을 변경하면 함수 바깥에서도 동일하게 변경되는 것입니다. 그런데, 만약 함수내에서 매개변수가 &lt;code class=&quot;language-text&quot;&gt;재할당&lt;/code&gt;되었다면, 함수 바깥의 변수와 함수내 매개변수가 서로다른 객체를 바라보게 됩니다. 그래서 함수 내부에서 아무리 객체를 변형시키더라도 외부의 객체에 영향을 줄 수 없습니다.&lt;/p&gt;
&lt;h3&gt;참고자료&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://codeburst.io/explaining-value-vs-reference-in-javascript-647a975e12a0&quot;&gt;https://codeburst.io/explaining-value-vs-reference-in-javascript-647a975e12a0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[추리소설 작가의 힐링 소설 <나미야 잡화점의 기적 : 히가시노 게이고>]]></title><description><![CDATA[“아래 글에는 스포일러가 존재합니다” 히가시노 게이고 작품 네번째, ‘나미야 잡화점의 기적’(이하 ‘나미야’)을 완독했다. 일본에서는 잘 모르겠지만, 한국에서는 48 쇄를 찍을 정도로 출간이후부터 꾸준히 팔리고 있다. 출간되고도…]]></description><link>https://blueshw.github.io/2018/09/04/healing_mystery/</link><guid isPermaLink="false">https://blueshw.github.io/2018/09/04/healing_mystery/</guid><pubDate>Tue, 04 Sep 2018 01:38:09 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;“아래 글에는 스포일러가 존재합니다”&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;히가시노 게이고 작품 네번째, ‘나미야 잡화점의 기적’(이하 ‘나미야’)을 완독했다. 일본에서는 잘 모르겠지만, 한국에서는 48 쇄를 찍을 정도로 출간이후부터 꾸준히 팔리고 있다. 출간되고도 2 쇄를 찍지 못하는 책들이 수두룩한 출판시장에서 &lt;em&gt;48 쇄&lt;/em&gt; 는 정말 경이로운 수치가 아닐 수 없다. 이전에 나왔던 ‘용의자 X 의 헌신’, ‘비밀’ 등 유명한 작품이 있었지만, 국내에서는 ‘나미야’를 통해 비로소 베스트셀러 작가에 이름을 올릴 수 있었다. 도대체 어떤 내용이길래 48 쇄나 되도록 꾸준함을 유지할 수 있었을까? 비로소 궁금함이 생겼다.&lt;/p&gt;
&lt;p&gt;‘나미야’는 추리소설이 아니다. 굳이 장르를 따지자면, 판타지 힐링소설쯤 되겠다. 대부분의 작품이 추리소설인 전문 추리소설 작가가 판타지라니? 게다가 힐링? 도대체 잡화점이라는 소재로 어떤 이야기를 만들어 나갈지 추측할 수 없었다.&lt;/p&gt;
&lt;p&gt;이야기의 시작은 세명의 루저(?) 청년들로 시작한다. 쇼타, 고헤이, 아쓰야 세사람은 아동복지시설 &lt;em&gt;‘환광원’&lt;/em&gt; 출신이다. 어렸을 때부터 부모의 사랑을 받지 못하고 자라온 이들은 어른이 되어도 사회에서 환영받지 못한다. 한명은 회사에서 잘렸고, 다른 한명은 회사가 망해서 실업자가 되었다. 또 다른 한명은 누명을 쓰고 쫓기는 중이다. 그렇게 도망다니던 3 인조는 우연히 낡고 오래된 ‘나미야 잡화점’에 숨어들게 된다. 잠시만 밤이슬을 피하려던 그들에게 갑자기 편지가 한통 도착하고 이 편지로 인해 그들의 인생은 완전히 뒤바껴 버린다. 분명히 아무도 살지 않는곳인데, 편지가 온걸 의아하게 여긴다. 밖으로 나가봐도 사람이 다녀간 흔적은 찾아볼 수 없다. 이상하게 생각한 이들은 편지를 뜯게되고, 이 편지가 상담편지임을 알게된다. 답장을 쓸 처지는 아니었지만, 시간도 때울겸 장난 반 진심 반으로 편지에 답장을 하기 시작한다.&lt;/p&gt;
&lt;p&gt;30 여년전, 나미야 잡화점은 사람들의 ‘상담창구’였다. 처음에는 아이들의 장난스런 상담에 진심어린 답변을 해주던게 점점 커졌다. 나중에는 잠지에 실릴만큼 유명세를 타게된다. 어떤 상담에도 진심어린 답을 해주던 나미야 할아버지는 숨을 거두기 전, 아들에게 더이상 운영하지 않던 ‘나미야 잡화점’에 다시 한번 가자고 한다. 거기에서 미래에서 온 편지(그렇다. 나미야 잡화점은 시간을 초월하는 공간이다)를 읽은 나미야씨는 죽기전 아들에게 기묘한 유언을 전한다. 자신이 죽은뒤 30 주기가 되는 날, 단 하루만 ‘나미야 잡화점’을 다시 열어달라는 것이다. 아버지의 유언이 이상했지만, 잡화점에서 가지고 나온 편지들이 미래에서 온 것임을 알게된 아들은 아버지의 유지에 따라 정확히 30 년 후 ‘나미야 잡화점’을 연다. 그런데 우연히도 이날이 세명의 청년들이 잡화점에 숨어든 날이었다.&lt;/p&gt;
&lt;p&gt;30 여년 간의 시간을 오가며 나미야 할아버지와 3 인조의 상담 내용이 교차된다. 수십년간 상담 전문가(?)로 활동한 나미야 할아버지는 모르겠지만, 상담과는 전혀 거리가 먼 3 인조의 상담 내용은 정말 형편없다. 하지만, 그 답장을 읽은 사람들은 이상하게도 스스로 답을 얻는다. 상담을 통해 점점 진실에 접근하던 3 인조는 모든 이의 상담이 자신들이 어린시절을 보냈던 ‘환광원’과 연결됨을 깨닫는다. 사실 ‘환광원’은 나미야 할아버지가 젊은 시절 사랑에 빠졌던 여인이 설립한 복지 재단이다. 무슨 이유에선지 모르겠지만 어떤 인연의 끈을 통해 ‘환광원’출신 사람들의 고민을 나미야 할아버지가 들어주게 된 것 같다. 결국 모든 사실을 알게된 3 인조는 스스로 잘못을 뉘우치고 새로운 삶을 살기로 결심하고 이야기는 막을 내린다.&lt;/p&gt;
&lt;p&gt;‘나미야’는 정말 재미있는 소설임에는 틀림없다. 추리소설이라고 할 수는 없지만, 충분히 재미있는 요소를 갖추고 있다. 이야기의 중심 흐름은 모두 다르지만, 결국에는 ‘환광원’으로 연결된다. 30 년의 세월을 오가면서 오갔던 상담이나 잡화점에 들어오기 전 3 인조가 겪은 사건, 그리고 그들의 상담내용 모든 것들이 아우러져 하나의 거대한 이야기를 만들어낸다. 가히 수십년간 추리소설을 써온 작가의 내공이 느껴지는 부분이다.&lt;/p&gt;
&lt;p&gt;그렇다고 완벽하지는 않다. 판타지며 SF 기 때문에 모른척 넘어갈 수 있는 부분이지만, 30 년의 시간이 어떤한 방식으로 연결되는지 그 인과관계는 명확히 드러나지 않는다. 또한 어째서 30 년 전의 편지 일부가 30 년 후의 3 인조에게 전달되는지도 아이러니하다. 아마도 나미야 할아버지가 죽고나서일듯 한데 정확히는 알수 없다. 또한 ‘환광원’을 설립한 여인과 나미야 할아버지가 젊은 시절 사랑하는 사이었다고 해서 ‘환광원’과 관계된 사람들의 고민을 들어준다는 설정 또한 당위성이 부족해보인다. 히가시노 게이고가 추리 작가가 아니었다면 그다지 아쉽다고 생각하지 않았을것 같다. 하지만, 치밀한 추리소설을 그렇게나 많이 집필한 히가시노 게이고기 때문에 아쉬운 마음은 어쩔수 없는것 같다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[롤모델이 독이 될지도 모른다.]]></title><description><![CDATA[‘롤모델’ 또는 ‘역할모델’은 위키피디아에 다음과 같이 정의되어 있다. ” 역할 모델(Role model)은 어떤 한 사람을 정해, 그 사람을 표본으로 정하여 성숙할때까지 모델로 삼는 것을 말한다. 이 용어는 로버트 K. 머튼(Robert K…]]></description><link>https://blueshw.github.io/2018/08/31/disadvantages_role_model/</link><guid isPermaLink="false">https://blueshw.github.io/2018/08/31/disadvantages_role_model/</guid><pubDate>Fri, 31 Aug 2018 01:07:28 GMT</pubDate><content:encoded>&lt;p&gt;‘롤모델’ 또는 ‘역할모델’은 위키피디아에 다음과 같이 정의되어 있다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;” 역할 모델(Role model)은 어떤 한 사람을 정해, 그 사람을 표본으로 정하여 성숙할때까지 모델로 삼는 것을 말한다. 이 용어는 로버트 K. 머튼(Robert K. Merton)이 처음으로 사용하였다.”&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;쉽게 말해 &lt;em&gt;롤모델&lt;/em&gt; 은 내가 본받고 싶은 사람이다. 아직은 많이 부족하지만 미래에는 ‘저 사람처럼 살고싶다’고 느껴진다면, 그(녀)는 당신에게 롤모델이 될 수 있다. 롤모델이라는 말이 최근 십수년내에 많이 퍼졌지만, 우리는 이미 어렸을적부터 롤모델이 무언지 알고 있었다. 누구나 어렸을적에 한번쯤 위인전을 읽어보았거라 생각한다. 우리가 어렸을적에는 집집마다 위인전이 있었고, 학교에서도 가장 존경하는 인물이 누구냐는 질문을 수도 없이 들어왔다. 그게 바로 롤모델이다. 롤모델을 선정하는 것은 자신의 성장을 위해 가장 효과적인 방법중의 하나다. 롤모델의 생애와 업적를 따라가면서 그의 인생관이나 철학, 행동 등을 배울 수 있다.&lt;/p&gt;
&lt;p&gt;우리가 어떤 문제에 직면했을때 본인의 판단으로 해결책을 선택할 수 있다. 하지만, 만약 자신의 롤모델이 있다면 그 사람은 이 상황에서 어떻게 행동하고 결정했을까를 상상해볼 수도 있다. 어떤 해결책이 더 낫다고 할 수 없지만, 적어도 내가 본받고 싶어하는 사람의&lt;/p&gt;
&lt;p&gt;입장에서 내린 결정이라면 조금더 신뢰하고 과감히 행동할 수 있지 않을까?&lt;/p&gt;
&lt;p&gt;이렇듯 자신의 성장을 위해 롤모델을 설정하는 것은 매우 바람직한 일이다. 하지만, 롤모델에는 이렇듯 순기능만 있을까? 롤모델을 정하고 그 사람의 인생을 답습하면 성공이 보장될까? 그렇지 않다. 롤모델을 너무 맹신하다가는 자칫 독이 될 수도 있다. 예를 들어보자. 어떤 사람은 롤모델이 너무 자주 바꾼다. 투자에 관심을 가지더니 워렌 버핏이 자신의 롤모델이라 말한다. 그러면서 버핏의 책을 두어권 읽어본다. 또 몇개월이 지나자 이번에는 스티브 잡스 같은 성공한 기업가가 되고 싶다고 한다. 아마 스티브 잡스의 전기를 읽었는지도 모르겠다. 그러다가 또 어느날은 성공한 예술가의 삶, 화려하고 지적이며 존경받는 삶을 꿈꾼다. 이 사람은 왜 이렇게 자주 롤모델이 바뀔까?&lt;/p&gt;
&lt;p&gt;근본적인 문제는 자신이 정말 무얼 원하는지를 모르고 있다는 것이다. 스스로가 어떤 삶을 살아야할지를 모르는 상태에서 성공한 사람들의 단편적인 모습만 보고 이 사람처럼 되고 싶다고 마음먹는다. 처음에는 그 사람의 책을 읽고 그 사람이 어떤 삶을 살아왔는지 공부하기 시작한다. 하지만 이 노력은 십중팔구 오래가지 못한다. 왜냐하면 얼마 못가서 또 다른 사람에게 이끌려 이전에 선정했던 롤모델을 바꿔버리기 때문이다. 이렇게 자주 롤모델을 바꿔서는 아무것도 배울 수 없다. 오히려 &lt;em&gt;여러 사람의 단편적 모습만을 따라하면서 인생을 낭비할 수도 있다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;롤모델은 자신을 발전을 위한 최선의 방법중 하나임에는 틀림없다. 하지만, 롤모델을 선정하기 전에 내가 원하는 삶이 무엇인지를 명확히 하는게 먼저다. 그렇지 않으면 오히려 내 인생을 망치는 독이 될 수도 있다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[페이스 조절이 필요하다]]></title><description><![CDATA[마라톤이 20 여일 앞으로 다가왔다. 등록하고 2 주가 지났는데, 그 동안 6 번정도 달려보았다. 마음먹고 달려본지가 몇년은 더 된거 같다. 절대 무리해선 안된다. 이제 팔팔한 2…]]></description><link>https://blueshw.github.io/2018/08/29/face_adjustment/</link><guid isPermaLink="false">https://blueshw.github.io/2018/08/29/face_adjustment/</guid><pubDate>Wed, 29 Aug 2018 02:32:11 GMT</pubDate><content:encoded>&lt;p&gt;마라톤이 20 여일 앞으로 다가왔다. 등록하고 2 주가 지났는데, 그 동안 6 번정도 달려보았다. 마음먹고 달려본지가 몇년은 더 된거 같다. 절대 무리해선 안된다. 이제 팔팔한 20 대 청년도 아니고, 잘못하다가는 오히려 약값이 더 들지도 모른다. 가급적 무리하지 않는 선에서 하루에 4~5Km 정도만 달리기로 결정했다. 조금씩 거리를 늘려가다가 대회 며칠전에 8~10Km 정도를 한번 뛰어보는것으로 계획을 잡았다. 처음 뛸때는 정말 1Km 만 뛰어도 숨이 턱 밑까지 차서 죽을것만 같았다. 서너번 뛰고나니 어느정도 몸이 적응한건지, 3Km 정도까지는 쉬지않고 한번에 뛸 수 있었다. 하지만 대회는 10km 다. 10Km 면 아무나 다 뛸수 있다고 말하는 사람이 있지만, 한번도 해보지 않았기 때문에 준비해서 나쁠건 없다. 그런데 몇번 뛰다보니 과연 이런식으로 10Km 완주가 가능할지 의문이 들었다. 왜냐하면 2~3Km 뛰고 걷고, 또 뛰고 걷는걸 반복하다보니 체력이 급속도로 고갈되는 느낌이 들었기 때문이다.&lt;/p&gt;
&lt;p&gt;마라톤 경험이 있는 친구에게 조언을 구해보았다.&lt;/p&gt;
&lt;p&gt;“내가 뛴 기록인데, 한번 봐줘”&lt;/p&gt;
&lt;p&gt;그 친구는 내가 뛴 기록을 훑어 보더니,&lt;/p&gt;
&lt;p&gt;“음… 이런식으로 뛰면 10Km 못 뛰어요”&lt;/p&gt;
&lt;p&gt;라고??&lt;/p&gt;
&lt;p&gt;“그럼 어떻게 해야하냐?”&lt;/p&gt;
&lt;p&gt;“처음에 천천히 뛰셔야죠”&lt;/p&gt;
&lt;p&gt;라네…&lt;/p&gt;
&lt;p&gt;이 친구의 조언을 듣기 전 뛰었던 결과는 아래와 같다.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/0-3d56012f3b75c49334ef2fb00494355c-32589.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 320px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 177.5%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAkCAYAAACJ8xqgAAAACXBIWXMAAAsSAAALEgHS3X78AAAEqUlEQVRIx41WaW8cRRDt//8b+ABCCBBIUQIhEGISCwKWwciY4Gt3fXvv+/BMTx+PVz3Ts7OzjpKW3vQ1XV1VXZc6bzZx3mhgMBjAWgtp3vsAacYYXF1dBfR6PcQm406ng+Pj47w/O8OrnR2oZDKGWczhKkTqRPv9PtrtNrIsK/fkcudc6GWeDQfQyyUU5iQ2m8IXP8ogEosEz3j7yclJ4DYSrDd3dQHMZ1CGt4SfXH6rcJFlpoKsPCQEN/c5tg6ZcMj9jDSU1hp3FKfd7WK+WOS3Ob/BpYgmqK4FyL9Ul+134Siyo7RqOpth7+AAR1TuKR9nQ6woWnW8VnLeLRdw/R7caAgnOhSBdRAjw4ILJr507WDBeo54wSO6VFitRDlbr+tFRJPlj8V9r9N8XIMrzomkHZqS8rRDPx7nP1T1JD+/fgm3/zu86Gf3FfxlC+7PPfjphP0fcM+fwN/fBoIZL03TlAQv+NzTaUW8tSjux+/gvvwU7sVTuK8+C7CffwL35Gu4b74ox4Goya0hEPSTSWmHvmJn7s3PsD88hX3xDPan7wPcy+ecc42XWY6drD37NkjhA8EWOSTBrdcUvf36C/xvr+Hf7rJ/s4bM367nbncHWC4e4TDqkLblT97BU0/+6G/4w4P3whEgkvEIq6DDcQM+KR5F/FJEbZ7B/nMAe9GEbZ5/EL51jiUJTukYyi+4kAzXprBawvE1ba8L2+18FFyvgwd6yYImqLy+oNtc0tppGu07+NvrnCg3XdH7h4dybgn/wDFhiznShCpcYETzU85w0WXhkNiXeMpDkub6FB/mXOxL+qhj8X/xrOjnMh7xHboMcyrVNEi9jiii2FsGitjEETsMvplz5dqQnCzFw8QYrAmBZTAakY6m65EziWO+cQZ/zgdq0oxaLc4bJSDeJGPGRdzdhTDX5NqSvh/bPaN2EBma9rNs09ppT+ML2FkPhgHXUskCUyCM6a+iSyG4t7eHEbkKUnD+LwPw5c0NU4BbInG0Q3MDq2kGukkxNAxjogTfKkRsSRWis/39ffrDpCT4LhKc0wfn4hVW9JHD8mO5VocpemlHR0clh/Iw/52e4vr2FspaSTQCU4H9IALxMM7Pm3ChhcqKm2USIfnCbOSVbZjiXFYEZxPOZHkK+OvwMIT/aAof1WIKoMsFz6JDOI5Vmmq0O7Sj4ZAY0RRWlVTpNwl4v0UQIbKbcq42L/WPQw5FX69nxILQjK4nBq9kaiVz0R/LQ7VkHyJQkgT4+sWFByXcE5XlHDJahIg76MMzx26IJllQLpSgwbJlKxPWs96MxjmhPVnepJlbND0ivblG2r4PiUczPKWdNjSJ6VYDKWOkjA19XvY0xTTkLCVW5FLN+MoTEgpliEBMgb1m4taMPpqchzJDzEUI0C1lT8YZ40DKJJ9dXWJGwkMyp97Lu8Q9UQM5xmbqD6biSfRRkR991ZAODBxFi2mh+gCh7JiMtx+IUHmQXJuAq8x9LJxCsRSLpvq/rqwcBGpFPehKySb6vGNsK0s4HugwEsfqNhSgDLiLIhaK+8n/Eg9lTfla5RqrUhR1S8pbE3rRimlBbE38NpZ29WpWxv8DGNTeHSGafgcAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;img0&quot;
        title=&quot;&quot;
        src=&quot;/static/0-3d56012f3b75c49334ef2fb00494355c-32589.jpg&quot;
        srcset=&quot;/static/0-3d56012f3b75c49334ef2fb00494355c-b04cf.jpg 148w,
/static/0-3d56012f3b75c49334ef2fb00494355c-29bf1.jpg 295w,
/static/0-3d56012f3b75c49334ef2fb00494355c-32589.jpg 320w&quot;
        sizes=&quot;(max-width: 320px) 100vw, 320px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;&amp;#x3C; 초기의 기록: 심장이 터질거 같다 &gt;&lt;/p&gt;
&lt;p&gt;위의 그래프는 초기에 4Km 를 뛴 결과의 일부를 발췌했다. 윗부분의 심박수 영역을 보면, 최고 심박수가 거의 190 이다(심장 터지는거 아냐?). 10 분도 안되서 심박수가 190 에 도달했다. 문제가 있는거겠지? 아마 처음부터 너무 빠르게 뛰어서 몸이 갑자기 힘들어한것 같다. 아랫부분의 속도 그래프를 보면, 좀더 명확하게 드러난다. 확실히 초기에 빠르게 뛴게 보인다. 속도가 거의 15Km/h 에 가깝다. 15Km/h 가 엄청나게 빠른 속도는 아니지만, 나처럼 오랜만에 뛰기 시작하는 사람에게는 충분히 빠른 속도다. 초반을 지나고 시간이 지날 수록 속도는 점점 느려진다. 심박수가 너무 높게 올라가니 어쩔수 없다. 걸어야한다. 그래서 두번에 걸쳐 속도가 확 떨어진 구간이 보인다. 걷는것도 문제지만 전체적으로 봐도 페이스가 점점 떨어지고 있다. 이렇게 뛰어서는 정말 그 친구 말대로 10Km 완주가 힘들지도 모르겠다(도착은 하겠지만, 많이 힘들것 같다. 기록도 나쁘겠지).&lt;/p&gt;
&lt;p&gt;그럼, 조언을 듣고나서 뛴 결과를 보자.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/1-f4d1ccd660d017151c56f0d014a37a12-32589.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 320px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 177.5%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAkCAYAAACJ8xqgAAAACXBIWXMAAAsSAAALEgHS3X78AAAEz0lEQVRIx51WaXPbNhDl//8FnX7p9GPbaZsm0zSH3MSOZ+y4teOmka3Ltm5FFyWRlEiCAF7f8pBkWe6kxcwbECB2AezxFk6t0UCtXsd4PIbWGtKstSmkJUmCZrOJVquVrinacDjEYDDA1dVV1lerKB0cwAlnLhLfg9lSUigsxqPRKBUS5cV/2dwYk/YyVpMx4sCHAyqzi8V64XYrxlXufn19fU/hbjPNW8BbwFHa8HScYJ8kGnGsoNQGMi7klUru/VOyljKKCpT8Z+/IrnOe0PN9RHGc7carGP4soLVZX3Eznx9ktYKez6CpQ74dUXZ0coKziwtU6Jx919nbCntTmem0YAY9GH47ck3PD7DwPIynU8RKPWqnx5RuNwdGrvnQGXvBa64h3hXz5DLLMOSh6BTr1WHCaWYPWbhPuEC+9RrLAObDHwDhdtoYTCY8YXwHm9AORjydG54KTb77PSzmMH3aisLm8hz6yffQ33wF++3X8Bk2UzrWaas2PJ3HYQHa0Y5HMLVrmE9/wXSpoFKGfv4E+pcfoJ/+CP3zd9DPfoJ+8Qz2xVN43Q6GLp1Sp1ZXAlaErv6GuS7DHL+Fef0c5tWvMKXfsm/p35Zg3r2BOfp90x8eAOw9nnw8o8KGbzFzPeDkCPb0OMP5e9jLPx+CtrIXO5A5rgftmXq54Wu45Wug8gn6hg5qVGHqFV73C1DPQdNYBrVNFU4CuNU66WMA3e8SvQyDLeyOd0E5q7Isc6pDD5NWB1gtoRncxv+fSFR2wvkqRhgs06hPw6ZAmrcmJY1szmzNaWg6svgnshPXRbBckm2EURK1zpKAxm22WxtaooJOr4cwijbkSn5cMDoKAu6RK4ck36WQg12FzJQIwtXcMEViNt/pWCcp22iTQVq/38eKCopNB2Rwdz5npoQMmWAIzD4AkzNgylSaSBh0SXA0RRwwk2gdgTJpysSkuaOjI7i8pjTZ7CNLwS3LhKNMgEiPMF+eYha8I46zfvUebsgcDS8xTVyMlItBNMGC631e9/DwEIuc6eWEtZub9JSOr2MM4xXezEZ46X7GqzUGRB+v3R5eTlo4DzqoRW309IQxvESpVCIxz9cKy5UKmp0OHK0tOdAgCC18IgixQZTB57dOcoawmSM8hpiUBJsXqiU9HJLCnKJ0ykojxqfH9yGNhhyiSFNRIjWGXlPcRLQkUlOklnwsl9G4u1uHRsaJu0S7Q8Amo1bjTqHvbqBJadolH0rs1Bo3aHe6GI0nqQe/qAQUNUUyJFyJ68WYDJvt2ppXtUdLwF5slQAh2P8mvB/S/CDALA3sNVc/Xskev7J9YJ7NCYUA+D6x/1b1CuwUqyKnFbG2obBG0qhtFhZeXo93vqXuCOPkTlx4PkZS9cSYwW0DSeUKir3QkmZ9NRRIX1cSFlGYURbn5cmR9DpQsp6holiLktEw9XB65SkLy+ezUyS8bjToI2zdIWIpiLg4bDcRk61D0lnIqhb3ulAUjkmoERk+ZtzGVBTRuzZ/mTm5AbKrSM/3SWpok9k1I0kyDoXtzhvDbjlEnjKSJGlgx6I9/zGncJ+EWTRJzR7JMymUc92IY1FQOENYpkt+lDmneKYVTXJWkhw5F8Tc1SNDL0nCURSnnpRsUluPKklZmRM9/wDtP9r7GQ+v2QAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;img1&quot;
        title=&quot;&quot;
        src=&quot;/static/1-f4d1ccd660d017151c56f0d014a37a12-32589.jpg&quot;
        srcset=&quot;/static/1-f4d1ccd660d017151c56f0d014a37a12-b04cf.jpg 148w,
/static/1-f4d1ccd660d017151c56f0d014a37a12-29bf1.jpg 295w,
/static/1-f4d1ccd660d017151c56f0d014a37a12-32589.jpg 320w&quot;
        sizes=&quot;(max-width: 320px) 100vw, 320px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;&amp;#x3C; 페이스 조절한 뒤 기록: 그래프 이쁘네 &gt;&lt;/p&gt;
&lt;p&gt;친구가 조언해준 내용을 잘 상기하면서 처음에 천천히 달렸다. 위쪽 그래프의 속도를 보면 초반에 거의 14Km/h 정도가 되는데, 이번 그래프의 초반 속도는 대략 10~11Km/h 정도밖에 안된다. 확실히 느려졌다. 초반 속도가 느려지긴 했지만, 전체적으로 일정한 속도로 달렸다. 오히려 시간이 지날수록 약간 속도가 올라간걸 볼 수 있다. 그리고 중요한 점은, 걷는 구간이 없다!!! 이전에 뛸때는 4Km 구간밖에 안되는데도 불구하고 두번이나 걸었다. 그런데 이번에는 지난번보다 1.2Km 정도 더 늘어난 5.2Km 구간을 뛰었다. 그럼에도 한번도 쉬지 않고 뛰었다. 당연히 전체 기록도 더 빨라졌다.&lt;/p&gt;
&lt;p&gt;내가 몇번 더 뛰었다고 체력이 늘었다고 볼 수는 없다. 몸이 조금 적응했을지는 모르지만, 갑자기 오래 달릴 수 있다는건 말도 안된다. 이건 페이스 조절을 했기 때문에 가능한 변화다. 마라톤에는 페이스 조절이 필수다. 마라톤은 단시간에 승부를 내는 운동이 아니다. 오랜 시간을 두고 천천히 완주하는게 목표인 운동이다. 42.195Km 를 뛰는 선수들 조차 페이스 조절이 힘들어서 별도의 페이스 메이커를 두는 경우가 있다. 하물며 마라톤의 ‘마’자도 모르는 생초보가 체력 안배를 위한 페이스 조절 없이 완주 하겠다는건 어불성설에 가깝다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[히가시노 게이고의 최신작 중 하나를 골라보았다 <눈보라 체이스 : 히가시노 게이고>]]></title><description><![CDATA[…]]></description><link>https://blueshw.github.io/2018/08/26/best_of_keigo_higashino/</link><guid isPermaLink="false">https://blueshw.github.io/2018/08/26/best_of_keigo_higashino/</guid><pubDate>Sun, 26 Aug 2018 23:28:33 GMT</pubDate><content:encoded>&lt;p&gt;주구장창 히가시노 게이고 작품을 읽고 있다. 너무 재미있고 흡인력이 뛰어나서 계속 읽는건 아니다. 한 작가를 평가하려면 최소한 그동안 작가가 출간한 작품의 절반은 읽어봐야 한다고 생각한다. 히가시노 게이고의 경우에는 출간한 소설은 너무 많아서 절반 읽기도 어려울것 같다. 10 권 정도면 괜찮지 않을까 생각한다. 이번에 읽은 책은 &amp;#x3C;눈보라 체이스&gt;라는 소설이다. 작가의 최근작 중 하나로 설산 시리즈(이 책을 읽으면서 처음 알았다)의 세번째 작품이라고 한다. 그 전 작품들(&amp;#x3C;백은의 잭&gt;, &amp;#x3C;질풍론도&gt;)은 읽어보지 않았으므로 굳이 언급하지는 않겠다. 궁금하다면 직접 찾아보기 바란다.&lt;/p&gt;
&lt;p&gt;지난번 읽은 두 권(&amp;#x3C;백마산장 살인사건&gt;, &amp;#x3C;11 문자 살인사건&gt;)이 우연히 히가시노 게이고의 극 초기작이었다. 진짜 의도적인건 아니었다. 정말 우연이었다. 그저 책의 제목(설마, ‘살인사건’이라는 이름 때문인가…)만 보고 선택했기 때문이다. 이 두 추리소설은 작가의 초기작이라서 그런지 밀실살인, 트릭, 외부와의 단절, 나중에 밝혀지는 인물들간의 과거 등 고전적인 추리소설의 요소를 많이 차용한다. 고전적인 추리소설을 많이 읽어보지 않아서 그 예를 들기는 어렵지만, &amp;#x3C;소년탐정, 김전일&gt;과 비슷한 느낌이다. &amp;#x3C;소년탐정, 김전일&gt;이 오래된 만화기도 하지만, 추리소설의 정석을 많이 보여준다. 이 만화를 봤던 독자라면 위에서 나열한 요소들이 대거 등장함을 알 수 있다. 그래서 히가시노 게이고의 초기작들을 읽다보면 마치 &amp;#x3C;소년탐정, 김전일&gt;의 에피소드 하나를 책으로 읽는듯한 느낌이 든다.&lt;/p&gt;
&lt;p&gt;그래서 의도적으로 최신작을 골랐다. 최신작을 고른 이유는 과거 작품에 비해 훨씬 완성도 있는 작품일 거라는 기대감 때문이다. 일관성 있게 비슷한 스타일로 작품을 쓰는 작가도 있지만, 히가시노 게이고는 &amp;#x3C;비밀&gt;이나 &amp;#x3C;나미야 잡화점의 기적&gt;에서 처럼 추리적인 요소를 최대한 배제한채 집필한 작품도 있다. 그만큼 다양한 시도를 해보았을 것이다. 이런 측면에서 보면, 최신작품이 고전적 추리소설의 형태를 띌꺼라 생각하기 쉽지 않다. &amp;#x3C;눈보라 체이스&gt;도 그렇다. ‘체이스’라는 이름에서도 보이듯이 이 소설은 추격전이다. 소설에서 ‘추격전’? 글로 추격전을 표현하는 것이 가능한건가? 가능하다면 어떤식으로 표현할까? 보통 추격전이라 하면 영화에서 많이 다룬다. 아무래도 자동차나 오토바이 추격씬 등 속도가 있고 극적인 장면을 연출하기 위한 수단으로 많이 사용한다. 그런데 소설에서 어떻게 추격전을 묘사하는거지? 조금 궁금해졌다.&lt;/p&gt;
&lt;p&gt;어느날, 대학생인 주인공이 살인사건의 용의자로 지목된다. 그가 개 산책 아르바이트를 하던 집의 할아버지가 살해당한 것이다. 모든 정황이 그를 용의자로 지목하고 있는 상황, 그는 친구와 함께 자신의 알리바이를 증명해줄 유일한 사람인 ‘여신’을 찾기 위해 도주한다. ‘여신’이란 할아버지가 살해당한 날 주인공이 갔던 스키장에서 유일하게 만났던 아름다운 여인이다. 하지만, 이름도 모르고 연락처도 모른다. 아는 것이라고는 그녀가 입고 있던 독특한 디자인의 스키복과 활동하는 지역이 사토자와 온천 스키장이라는것 뿐이다. 주인공은 경찰의 감시를 피해 무작정 사토자와 온천 스키장으로 향한다. 스키장에 도착해 그녀를 찾기위해 사방팔방으로 휘젓고 다녀보지만 그녀의 흔적을 찾기란 쉽지 않다. 그때 우연히 발견한 스키복, 그녀가 틀림없다. 하지만, 낯선 스키장의 비공식 코스에서 그녀를 따라잡기란 쉬운 일이 아니었다. 그녀의 실력도 실력이지만, 스키장의 규모가 워낙 방대하기 때문이다. 경찰의 수사망이 좁혀지면서 차안에서 며칠간 숙식을 해결하던 주인공에게 남은 시간은 점점 줄어든다. 그때 스키장에서 ‘여신’이 입고 있었던 그 스키복을 입은 사람들을 발견하고, 스키장에서 만난 사람들의 도움으로 ‘여신’의 정체를 알게되면서 그의 무죄가 증명된다.&lt;/p&gt;
&lt;p&gt;간단히 요약해보았다. 물론, 마지막부분은 두리뭉실하게 정리했다. 좀더 구체적으로 쓸수도 있지만, 이런 추리소설류의 작품에서 스포일러는 독과 같다. 마치 식스센스에서 내가 이미 죽었다는걸 알고서 보는것과 같다. &amp;#x3C;눈보라 체이스&gt;는 추격전을 표방하는 소실이긴 하지만, 영화에서 보이는 그런 추격전만큼 스릴이 넘치진 않는다. 작가 특유의 빠른 전개는 여전하지만, 제목에서처럼 스키(또는 보드)를 타면서 쫓고 쫓기는 추격씬을 상상한 독자라면 자칫 실망스러울수도 있다. 스토리는 추격전보다는 ‘여신’의 정체를 알아가는 과정에 초점을 맞춘다. 추격전, ‘여신’의 정체 등 소설의 소재가 다소 무겁게 느껴질 수 있는데, 막상 책을 읽어보면 훨씬 가볍게 느껴진다. 아마 등장인물들의 분위기 때문인지도 모르겠다. 살인사건으로 시작됨에도 등장하는 인물들은 어둡지 않다. 특히 주인공은 하얀 눈을 보면 스노보드를 타고싶은 마음에 흥분을 감추지 못할만큼 순진하고 낙천적이다. 그 순간에는 자기가 경찰에 쫓기고 있다는 것도 잊은 듯이 그저 눈위를 달린다. 주인공을 도와주는 주변 인물들 또한 그리 심각해보이진 않는다. 가장 냉철하게 주인공의 현 상황을 깨우쳐주는 주인공의 친구조차 무사히 돌아가면 맛있는 음식을 사달라는 둥 전혀 쫓기는 사람처럼 보이지 않는다.&lt;/p&gt;
&lt;p&gt;&amp;#x3C;눈보라 체이스&gt;는 확실히 초기작들보다는 재밌다. 30 년 세월동안 쌓아올린 작가의 노하우는 스토리를 훨씬 탄탄하고 짜임새있고 만들었다. 다만 아쉬운점이 한가지 있다면, 책의 제목이 눈보라 ‘체이스’임에도 추격전이라는 장르의 특색이 크게 도드라지지 않는다. 굳이 따지자면, 추격전 요소가 가미된 추리소설 정도가 되겠다. 이 단점을 배제하고 읽는다면 충분히 즐길만한 소설이다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[내겐 읽기 힘든 책 <사피엔스>]]></title><description><![CDATA[…]]></description><link>https://blueshw.github.io/2018/08/22/sapiens/</link><guid isPermaLink="false">https://blueshw.github.io/2018/08/22/sapiens/</guid><pubDate>Wed, 22 Aug 2018 23:43:19 GMT</pubDate><content:encoded>&lt;p&gt;내겐 읽기 힘든 종류의 책이 있다. 예를 들면, 재레드 다이아몬드의 &amp;#x3C;총,균,쇠&gt;, 리처드 도킨스의 &amp;#x3C;이기적 유전자&gt;나 &amp;#x3C;만들어진 신&gt;, 칼 세이건의 &amp;#x3C;코스모스&gt; 등이 있다. 네가지 책 모두 스터디 셀러로 꾸준히 사랑받고 있다. 특히 코스모스는 발간된지 거의 40 년(1980 년 출간)이 다 되가지만 여전히 많은 이들에게 읽히고 있다. 이 책들의 종류를 굳이 따지자면 과학교양서다. 그렇다고 단순한 과학 교양서는 아니다. 역사를 바라보는 시각이나, 사회 비판적인 시선, 또는 사회 현상을 바라보는 새로운 시각이 담겨있다. 그런데 나는 이런 종류의 책이 힘들다. 네 가지 책 중에 완독한건 &amp;#x3C;이기적 유전자&gt; 밖에 없다. 읽을때도 꽤나 힘들었다. 그래서인지 몰라도 기억나는 내용도 거의 없고 전체적인 내용도 제대로 파악하지 못했다. 과학책이기 때문일지도 모르지만, 어쨌든 교양서기 때문에 전문가 수준의 사전 지식을 요구하는 것도 아니다. 관련된 상식만 충분히 인지하고 있으면 충분히 읽을 수 있는 수준이다. 그래서 언제가 됐든 &amp;#x3C;이기적 유전자&gt;도 다시 읽어볼 생각이다.&lt;/p&gt;
&lt;p&gt;그렇다면 왜 이런 책을 읽기 힘들어 할까? 몇가지 이유를 생각해보면 다음과 같다.&lt;/p&gt;
&lt;p&gt;첫째, 과학(또는 역사) 분야의 책이라 생소한 개념이 많다. 아무리 기본적인 상식만으로 읽을 수 있더라도 생소한 개념이 없을수는 없다. 책을 읽을때 단어의 뜻이나 개념을 모르면 흐름이 끊기기 때문에 전체적인 맥락을 이해하는데 방해가 될 수 있다.&lt;/p&gt;
&lt;p&gt;두번째, 두께가 문제다. 모든 과학 교양서가 두꺼운것은 아니다. 하지만 내가 언급한 책들은 500~700 페이지 정도 되는 분량이다. 쉽게 읽히지 않는 점을 감안하면 꽤 부담스러운 분량임에 틀림없다.&lt;/p&gt;
&lt;p&gt;세번째, 읽는 속도가 느리다. 아무래도 쉽게 읽히지 않는 분야의 책이기 때문에 빠르게 읽기는 힘들다. 또한 첫번째 이유처럼 생소한 개념이 나올때마다 흐름이 끊겨 더욱 책 읽는 속도가 느려진다. 또한 꽤나 두꺼운 편이기 때문에 더더욱 속도가 느려질 수 밖에 없다.&lt;/p&gt;
&lt;p&gt;&amp;#x3C;사피엔스&gt;도 위에 언급한 책과 비슷한 부류에 속한다. 두껍고(636 쪽) 어려운 개념이 많이 등장한다. 완독하는데 거의 3 주가 걸렸다. 거의 매일매일 읽었는데 이렇게나 오래 걸렸다. 책이 두꺼운것도 사실이고, 어려운 개념이 나오는 것도 사실이다. 하지만, &amp;#x3C;이기전 유전자&gt;와 비교했을때 훨씬 더 쉬웠다. 아무래도 과학 기반의 책이 아니라 역사 기반의 책이라서 그런것 같다. 번역도 한 몫 한다. &amp;#x3C;사피엔스&gt;는 번역이 매우 잘된 책에 속한다. 이런 종류의 책을 번역할때는 역자의 역량이 특히 중요하다. 책 내용을 완전히 파악하지 못한 역자가 번역한 책은 정말 읽기 어렵다. 본인도 이해 못하는데, 그 글을 읽는 사람은 오죽하겠는가.&lt;/p&gt;
&lt;p&gt;이스라엘 출신의 역사가 유발 하라리가 집필한 &amp;#x3C;사피엔스&gt;는 엄밀히 따지면 역사책에 속한다. 하지만, 동시에 과학책이기도 하고 사회과학 책이라고 해도 무방하다. 간단하게 내용을 언급하자면, 인류(사피엔스)가 지구의 지배자가 될 수 있었던 이유부터 시작해서 경제, 종교, 정치 등 인류가 만들어 낸 모든 발명에 대한 통찰을 보여준다. 농업혁명이 왜 인류를 더 빈곤하게 만들었는지, 공산주의가 왜 실패했으며 자본주의가 그 자리를 대체할 수 있었던 이유라던지, 다양한 정치 체제의 성공과 실패를 반복하면서 어떻게 민주주의에 도달했는지 등 현대의 모든 이데올로기(또는 종교)의 완성 과정을 인류의 역사를 통해 깨닫게 해준다. 읽으면서 매순간 감탄사가 터져 나왔다. 이런책은 정말 오랜만이다. 전자책으로 읽었지만 소장해두고 오랫동안 읽고 싶은 정도로 훌륭한 책이다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[목표를 잡았다 (feat. 2018 아디다스 마이런 서울)]]></title><description><![CDATA[목표를 잡았다. 마라톤을 뛰기로 했다. 3 년전 등록했다가 일본 출장 때문에 참가하지 못했던 아디다스 마이런(mirun)을 다시 등록했다. 날짜는 9 월 16 일 일요일, 이제 한달도 채 남지 않았다. 여의도에서 출발해서 상암운동장에 도착하는 10Km…]]></description><link>https://blueshw.github.io/2018/08/21/2018_mirun_seoul/</link><guid isPermaLink="false">https://blueshw.github.io/2018/08/21/2018_mirun_seoul/</guid><pubDate>Tue, 21 Aug 2018 00:53:19 GMT</pubDate><content:encoded>&lt;p&gt;목표를 잡았다. 마라톤을 뛰기로 했다. 3 년전 등록했다가 일본 출장 때문에 참가하지 못했던 아디다스 마이런(mirun)을 다시 등록했다. 날짜는 9 월 16 일 일요일, 이제 한달도 채 남지 않았다. 여의도에서 출발해서 상암운동장에 도착하는 10Km 코스다(마이런은 10km 코스 밖에 없다). 10km 코스라고 만만하게 볼 생각은 없다. 거의 10 년간 제대로된 러닝을 해본적이 없기 때문에 남은 기간동안 최대한 연습해야한다. 오늘까지 총 네번 연습했다. 대략 일주일에 3~4 번 정도 생각하고 있다. 마라톤 대회가 있는 날까지 대략 15 번 정도의 러닝이 가능하다.&lt;/p&gt;
&lt;p&gt;나는 주로 저녁에 달린다. 아이를 재우고 10 시가 넘으면 달리기 시작한다. 이사 온 동네 앞에 하천이 흐르는데, 제법 괜찮게 정비를 해두었다. 아직 내게 딱 맞는 코스를 찾지는 못했다. 매일매일 다른 코스를 달려보면서 내게 최적화된 코스를 찾는 중이다. 늦은 시간임에도 불구하고 생각보다 하천에는 사람들이 많다. 나처럼 러닝하는 사람, 강아지 산책시키는 사람, 부부끼리 산책하는 사람 등 다양한 사람들이 하천을 이용한다.&lt;/p&gt;
&lt;p&gt;순토(suunto) 시계도 잘 활용하고 있다. 순토를 사용한지 2 년 넘는 시간동안 단 한번도 러닝을 해본적이 없었다. 등산 몇번에, 스쿼시, 수영이 전부였다. 순토 시계를 차고 몇번 달려보니 꽤 쓸만하다. GPS 가 내장되어 있어 스마트폰이 없어도 달리는 경로를 확인할 수 있다. 그리고 평균속도, 최대속도, 심박수, 케이던스(분당 걸음수), 칼로리 소모 등 다양한 수치를 확인하면서 나름의 쏠쏠한 재미도 느낀다. 자극도 된다.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/0-83a55258757893f89c739e837d3472e2-3f0b4.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 58.29268292682927%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsSAAALEgHS3X78AAADVklEQVQozz2Te0+TBxTG+ymWfYAlUFknGRftYMDG/ZYoKmTZhoKVQiuXIWgFJjJwIGEB5aaFglgECl5KQXp5396gBTRMiCQTkpVBdOyvxQ02GI7ktxez7SRPzslJzsnznCdHlp+fj1KpJDIyktiYGKKiovgkLo6Po6OJjDhCUFAQh+Ry5BKCg4P/x0FfoVC8nQ0LD5cQRujhw8iWl5f5XKXiWE4OaVlZxKSl8umxTJTJqeSciWd09GsEcRq73YbT6cIlQRBF3G43Nqv1be13izjtInPz88gam5oIk1iV63S03+6ivuU68dlZvPPhUXLPK1h9NsKc+3ue+mYRBZEXiyv4ZuawCA6Mg/e42d7JpPkhtik7ByGLkKTKJepfFqm5eLWGgcE7NLS1kFdejFXoYtHrZd4xg2vSyn3TGH7BS1d3N4bBAc7kFZCeksF7cgUx6fFs/7GN7ANJd0J8PA319RQWajEYe7k3MUyHsZPdrV+Zd/vxix6J5Qx+u5OeW3p6Db0MmYapq9Jhv2PgZE42cRkp7OzsIEtLSSIpNZm65iYaW5spqasgv6qM/oHv2Fj2YBkbx2YeR7BMMNDTS23DNfweLx6vn9pLZRgaajhyYGJyIn/t7SFTpsZRWFpIYOMnnC47z5YWsDoFXj33sDRtZ0Dfi8NsZshg4HzFJdputDI37cHx4AEatYZrNbUY21o5p1YRWFtD9v5HoejbmyWXJum4eR3j2CiPPS6eP7qPobMdU38f5qEh8kvKOHlOTV9PN9YpM6WnPyMqNpHYhDQq8nJprK3ih9VVZFFHI0hMSqBSV0y1TkuetoCH43aWTBO4RDvrgQCZeSpCUjPQXiin53YHw8Y+Tmcfp6ComCdPF8jKTKdGc5bf/5RuqDgUREiogjGziSmLmZG7ep6Is1j677Lg89A3PMK7ymjiTp3icrWOzq4bFGnV0iOEc/XKtyzOLlFS8hVFRVrJlF1kZ784jsFwi+kZL4LDhsNhZW5CoLbyIiqNhtgTJwiRjMvVqKm+UoW+T091fR0qrZYLFZcpK63km4Zmxh5Z2N2VFra31DHj8+Lz+RBsU4hTFl7/9pr1ly9ZerHCylqAHzfWebX5M5u/bLK1vcV/sb+/z5u/37An5f1/e/8Ah9OAX5K1pVcAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;img0&quot;
        title=&quot;&quot;
        src=&quot;/static/0-83a55258757893f89c739e837d3472e2-f8fb9.jpg&quot;
        srcset=&quot;/static/0-83a55258757893f89c739e837d3472e2-e8976.jpg 148w,
/static/0-83a55258757893f89c739e837d3472e2-63df2.jpg 295w,
/static/0-83a55258757893f89c739e837d3472e2-f8fb9.jpg 590w,
/static/0-83a55258757893f89c739e837d3472e2-3f0b4.jpg 820w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;무슨일을 시작할때 목표를 잡는건 매우 중요하다. 목표 없이 어떤 일을 지속하기란 정말 힘들다. 특히, 달리기나 마라톤처럼 인내가 필요한 운동은 더더욱 그렇다. 누구나 운동을 시작할때는 나름의 계기가 있다. 너무 살이 쪄서 예전에 입었던 옷들이 맞지 않는다거나, 체력이 급격히 떨어져서 의욕이 없다거나, TV 에 나오는 잘생기고 이쁘고 날씬한 연예인들을 보고 그들처럼 되기 위해 운동을 시작한다. 하지만, 목표를 설정하지 않고 막연하게 시작하는 운동은 오래가지 못한다. 편한 옷을 새로 산다던가, 푹 자고 영양가 높은 음식을 먹고 체력을 회복했다던가, TV 속 연예인에게 관심이 사라졌을때 우리는 운동을 그만둘 가능성이 높아진다. 운동을 해야하는 이유가 사라졌기 때문이다. 운동을 할 때 목표를 잡으면 지속성이 높아진다. 운동 뿐 아니라 어떤일을 할때도 마찬가지다. 친구와 내기를 해도 좋다. 서로 각자의 목표를 설정하고 서로 경쟁을 하는것이다. 지는 사람이 간단히 밥을 산다는 정도로 내기하더라도 친구와 경쟁한다는 심리 때문에 혼자서 할때보다 훨씬 열심히 하게 된다.&lt;/p&gt;
&lt;p&gt;여러번 작은 목표를 설정하고 달성해본다. 몇번 하다보면 너무 무리하지 않을(내가 포기하지 않을) 정도로 목표를 잡는 요령도 생길 것이다. 몇번 성공하고 나면 큰 목표를 설정한다. 마라톤으로 예를 들면, 우선 몇번의 10km 코스에 도전한다. 10km 가 충분히 몸에 익으면 하프 마라톤에 도전한다. 그리고 최종적으로 풀코스에 도전한다. 처음부터 풀코스 마라톤을 뛰어야 겠다는 목표를 설정하면 너무 버겁다. 1km 만 뛰어도 숨이 턱밑까지 차오르는데, 내가 무슨수로 42.195km 를 뛸수 있을까? 이런 의구심이 들 수 있다. 그래서 이렇게 작은 목표로 시작해서 큰 목표로 나아가는 것이 바람직하다.&lt;/p&gt;
&lt;p&gt;같은 10km 마라톤에 도전하더라도 그 안에서 이렇게 세부적인 목표를 잡으면 훨씬 효과적이다. 1 시간 10 분 완주를 목표로 시작했다가 점점 줄여본다. 그리고 50 분안에 완주하게 되면 그 다음 하프 마라톤에 도전해보는 식이다. 이는 집앞에서 연습할때도 마찬가지로 적용할 수 있다. 하루에 5km 를 뛴다고 가정할때 처음에는 1km 뛰고 500m 걷기를 반복하다가 그다음은 2km 뛰고 500m 걷는걸 목표로 한다. 그리고 좀 더 익숙해지면 3km, 나아가 5km 동안 한번도 걷지 않고 뛸수 있도록 해본다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[도대체 11문자가 뭐야? <11문자 살인사건 : 히가시노 게이고>]]></title><description><![CDATA[히가시노 게이고의 두 번째 책을 읽었다. 몰랐는데, 전에 읽었던 <백마산장 살인사건>은 히가시노 게이고의 초기작에 속한다. 데뷔 이후에 3 번째로 쓰여진 작품이다. 작가마다 다르지만 보통…]]></description><link>https://blueshw.github.io/2018/08/18/11_text/</link><guid isPermaLink="false">https://blueshw.github.io/2018/08/18/11_text/</guid><pubDate>Sat, 18 Aug 2018 01:02:32 GMT</pubDate><content:encoded>&lt;p&gt;히가시노 게이고의 두 번째 책을 읽었다. 몰랐는데, 전에 읽었던 &amp;#x3C;백마산장 살인사건&gt;은 히가시노 게이고의 초기작에 속한다. 데뷔 이후에 3 번째로 쓰여진 작품이다. 작가마다 다르지만 보통 3 번째 쓰여진 책을 초기작이라하지 않는다. 하지만, 히가시노 게이고가 워낙에 다작하는 작가라 수십권의 작품을 쓴 그에게 3 번째 책은 완전히 초기작이라 할 수 있다. 연도를 살펴보면 데뷔하고 1 년만에 쓰여졌다. 나는 &amp;#x3C;백마산장 살인사건&gt;이 이렇게 오래된 책인지 몰랐다. 그래서 이 책을 읽고 그의 명성에 비해서 재미는 떨어진다 생각했다. 조금만 더 관심을 기울여 인기작과 초기작, 최신작을 구분해서 읽었어야 했다. 그랬으면 지난번처럼 쉽게 혹평을 내리지는 않았을거다. 히가시노 게이고 작가에게 사과의 말을 전해야 할 것 같다.&lt;/p&gt;
&lt;p&gt;두 번째 읽은 책은 &amp;#x3C;11 문자 살인사건&gt;이다. 이 또한 제목에 이끌려 선택했다. 그런데, 공교롭게도 두 번째 선택한 이 책 또한 히가시노 게이고의 대표적인 초기작이다. 이번에는 5 번째 작품이다. 그래서인지 몰라도 결론부터 말하잠면, 그다지 재미없었다. 빠른 전개 때문에 지난번 책과 마찬가지로 흡인력 하나는 인정할만하다. 하지만, 내가 왜 재미없다고 느꼈을까? 우선 간단한 줄거리를 살펴보자. 생각나는대로 적어보았다(스포일러가 될만한 부분은 제거하였다).&lt;/p&gt;
&lt;p&gt;어느날 같이 술을 마시던 남자친구가 이렇게 말한다. “누군가 날 죽이려는것 같아” 하지만 자세한 얘기는 해주지 않는다. 그리고 얼마뒤 그가 말한것처럼 진짜 죽어버린다. 누군가에게 살해당한 것이다. 추리작가인 주인공은 남자친구의 죽음에 의문을 품고 자신의 담당 편집자이자 친구인 후유코와 함께 개인적으로 수사를 시작한다. 끈질긴 추적 끝에 남자친구의 죽음이 1 년 전 요트 여행에서의 사고와 관련이 있다는 사실을 알아낸다. 1 년 전의 요트 사고에서는 남자 1 명이 죽었고, 나머지는 모두 구출되었다. 주인공의 남자친구는 그 때 구출된 사람중의 한명이었다. 사건은 여기서 끝이 아니었다. 진실에 가까워지면 가까워질수록 당시 구출된 사람들이 하나씩 살해되어간다. 다급해진 주인공은 구출된 사람들에게 그 날의 진실을 말해달라고 요청하지만, 사람들은 하나같이 그녀의 요청을 거절한다(또는 거짓말한다). 앞을 보지 못하는 사장의 딸만이 그녀에게 넌지시 진실을 말해준다. 하지만, 앞을 보지 못하는 아이기 때문에 사건을 해결하기 위한 결정적 실마리는 얻지 못한다. 사건이 점점 미궁에 빠지던 찰나 작년의 요트 여행을 주최했던 야마모토 사장이 올해도 그때와 똑같이 요트여행을 계획한다. 주인공과 그의 친구 후유코를 여행에 초대하고 Y 섬으로 향한다. 이 섬은 저주 받은 것일까? 아니면 누군가 계획한 것일까? 작년처럼 이번에도 한사람이 죽는다. 모두들 자살이라고 생각하지만, 주인공은 그렇게 생각하지 않는다. 여행을 마치고 돌아온 주인공은 1 년전 요트 여행에서 죽은 남자의 집에서 결정적인 증거를 발견하고 결국 사건의 전말을 알게된다.&lt;/p&gt;
&lt;p&gt;추리 소설의 묘미는 범행 현장과 주변 사람들의 행동을 통해 진짜 범인을 유추하는데 있다. 독자들은 사건의 단서들로 범인을 추측하고 맞추는데서 짜릿함을 느낀다. 하지만, &amp;#x3C;11 문자 살인사건&gt;에는 범인을 유추하기 위한 단서가 부족하다. 사건은 일어나지만, 사건을 통해 얻을 수 있는 힌트는 빈약하다. 빠르게 전개되는 이야기에는 몰입이 잘 되지만, 추리소설을 읽는 독자들에게는 그것만으로는 부족하다. 그리고 또하나 결정적인 단점은 이 책의 제목이다. 책 어디에도 살인사건과 11 문자의 관계를 설명하지 않는다. 다만, 책의 마지막 부분에서 범인이 살인 할 때마다 11 글자로 메세지를 보낸다는게 전부다. 책 제목으로 쓸 정도의 인과관계는 전혀 보이지 않는다. 11 문자가 아니라 12 문자나 20 문자라해도 크게 달라지는 부분이 없다. 다소 아쉬운 부분이다. 책 제목을 &amp;#x3C;11 문자 살인사건&gt;이라고 쓰기 위해서는 11 문자와 사인사건의 관계가 명확해야한다. 11 문자가 아니면 안되는 이유가 반드시 있어야 한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[이직률이 낮은 회사는 좋은 회사일까?]]></title><description><![CDATA[…]]></description><link>https://blueshw.github.io/2018/08/17/relationship_between_work_and_turnover/</link><guid isPermaLink="false">https://blueshw.github.io/2018/08/17/relationship_between_work_and_turnover/</guid><pubDate>Fri, 17 Aug 2018 01:18:03 GMT</pubDate><content:encoded>&lt;p&gt;이직을 논하기 전에 먼저, 좋은 회사란 무엇일까? ‘좋은’ 이라는 단어 자체가 풍기는 이미지가 지극히 주관적이다. 그래서 좋은 회사를 단적으로 정의할 수는 없다. 다만, 좀 더 많은 사람들이 만족해하는 회사를 일반적으로 ‘좋은’ 회사라고 간주할 수는 있다. 그러면, 사람들이 좋다고 말하는 회사는 어떤 특징을 가지고 있을까? (참고로 아래에 나열한 특징은 그간의 회사생활(그래봐야 10 년도 안된다)을 통해 나 나름대로 정한 매우 주관적인 요소들이다)&lt;/p&gt;
&lt;p&gt;첫째는 연봉이 높다. 사람들이 직업을 선택하고 회사에 취직하는 이유는 다양하겠지만, 가장 큰 이유는 돈을 벌기 위해서다. 자아를 실현하겠다거나, 사회에 공헌하겠다는 뜻을 가지고 회사를 선택할 수도 있다. 하지만, 대부분의 사람들은 그런 거창한 사명감으로 회사에 다니지 않는다. 실제로 일하다보면 앞서 말한 뜻은 전혀 의미 없는 이상에 불과한 경우라는 것을 깨닫게 된다(모두 그렇다는건 아니다). 회사는 먹고 살기 위해 다닌다. 회사를 다니는 가장 큰 이유가 먹고 살기 위해서라면 이왕이면 잘 먹고 잘 살면 더 좋겠다. 주 5 일 8 시간 일하고 연간 2000 만원을 받을 수 있는 회사보다는 야근이 좀 있더라도 연간 5000 만원 받을 수 있는 곳을 선호할 수 밖에 없다. 생활 수준이 달라지기 때문이다. 혼자사는 사람이라면 별 상관없지만, 매달 집 대출금에 두 아이 학원비와 생활비까지 대야하는 사람이라면 연봉 작은 회사를 선택하는것은 불가능에 가깝다. 두 회사간에 연봉의 갭이 작다면 얘기가 달라지지만, 그 차이가 크면 클수록 다른 단점은 모두 상쇄된다.&lt;/p&gt;
&lt;p&gt;두번째는 수평구조다. 수평적 회사는 호불호가 갈리는 특징일수 있다. 하지만, 실제 설문(블라인드 앱 설문조사)에서도 유연하고 수평적인 조직문화를 가진 회사를 다니는 사람들의 만족도가 높았다. 지금 내가 다니는 회사도 매우 유연한 편에 속한다. 내가 지금까지 다녀보거나 들어본 회사중에 이 정도로 수평적 문화를 가진 회사는 처음이다. 회사 문화가 언론에 많이 알려지지 않았을 뿐이지 대한민국 어떤 회사와 비교하더라도 이정도로 수평적이고 유연한 회사는 찾기 힘들것이다. 보통 한국 회사에서 대표에게 직접 의견을 개진하는게 쉬운일이 아니다. 하지만, 내가 다니는 회사는 대표에게 어떤 얘기라도 스스럼없이 얘기한다. 대표 또한 구성원들의 어떤 불만이나 요구사항이라도 쉽게 무시하거나 가볍게 넘기지 않는다. 직급과 상관없이 서로서로 존중하며 신뢰하고 있다보니 자연스럽게 이런 문화가 만들어졌다. 유연하고 수평적인 문화를 만드는것도 어렵지만 유지하는 것은 더 어렵다. 특히 회사 규모가 가장 큰 변수다. 아무래도 회사의 규모가 작을때는 대부분 수평적일 수 밖에 없다. 예를 들어 어떤 의사결정이 필요할때 모든 조직원들과 상의해도 큰 리스크가 없고 시간이 많이 소요되지도 않는다. 하지만 조직이 커지고 다양한 사람들이 모이면, 이전의 수평적인 문화를 유지하는게 점점 어려워진다. 아직은 우리회사의 규모(100~200 명)가 큰 편은 아니라서 여전히 예전의 유연한 문화를 유지하고 있다. 하지만, 우리 회사도 점점 커지고 있어 앞으로 조금씩 바뀔것 같은 예감이 든다.&lt;/p&gt;
&lt;p&gt;세번째는 문제의 이직률이다. 이직률이 왜 문제냐면, 이직률이 낮다고해서 반드시 건강하고 좋은 회사는 아니기 때문이다. 우리 회사는 이직률이 매우 낮다. 특히 내가 속한 개발팀의 경우, 최근 5 년간 나간사람보다 들어온 사람이 훨씬 많다. 구성원 개개인도 대부분 5 년 이상의 근속년수를 보이고 있다(나도 5 년 넘었다). 그만큼 회사를 떠나기 힘든 어떤 이유들이 있는 것이다. 앞서 말한 유연한 문화도 한몫한다. 윗사람이 내 출퇴근에 대해 간섭하는 경우가 거의 없고, 필요하다면 양해를 구하고 늦게 출근하거나 먼저 퇴근하는 것도 어렵지 않다. 그래서 유부남, 유부녀가 많다!! 그렇다. 유부녀도 많다. 특히 아이가 있다면 이 회사는 정말 다니기 편하고 좋은 회사다. 아이가 아프거나 볼 사람이 없더라도 시간 조정이 가능하고 눈치주는 사람도 없다. 오히려 그런 사람들을 더 배려한다. 이직률이 낮은 또 다른 이유는 일에 큰 부담이 없다. 최근에는 많이 달라졌지만, 그전에는 일정에 쫓기거나 지나치게 무리한 업무를 주는 경우는 거의 없었다. 하청을 받아서 일하는 구조가 아니라 서비스를 만들기 때문에 가능하기도 하지만, 구성원 대부분의 능력이 뛰어나고 책임감이 강하기 때문에 가능했던것 같다.&lt;/p&gt;
&lt;p&gt;그런데, 이럼 장점들에도 불구하고 이직률이 낮다고 해서 반드시 좋은 회사일까? 결론부터 말하자면 아니다. 적절하게 이직률을 유지해야 오히려 건강한 조직이라 말할 수 있다. 왜 그런걸까? 회사를 다니는 사람들은 세 부류가 있다. 첫째는 지금 다니는 회사에서 최선을 다하는 사람이다. 매사에 열심히기 때문에 능력도 뛰어나다. 이 부류의 사람들은 회사에 큰 불만도 없다. 주축을 이루는 사람들이기 때문에 회사도 인정한다. 그래서 다른 부류의 사람들에 비해 연봉도 높다. 두번째는 불만만 많은 사람이다. 능력이 있고 없고는 중요하지 않다. 회사의 정책이나 복지 등에서 불합리한 부분에 대해 매우 비판적이다. 그래서 연봉인상률, 인센티브에 민감하다. 특히나 회사는 성장하는데 내 연봉과 인센티브가 오르지 않으면 화를 낸다. 결국, 이렇게 불만만 많은 사람들은 회사에 만족하지 못하고 떠나게 된다. 세번째는 불만도 없고 능력도 없는 사람이다. 이 부류의 사람이 많은 회사는 위험하다. 발전이 없기 때문이다. 그리고 이 부류의 사람이 많은 회사는 이직률도 낮다. 내가 이직률이 낮으면 좋은 회사가 아니라고 말한 부분이 기억날것이다. 이들은 현상 유지를 최고의 미덕으로 여긴다. 나보다 더 뛰어난 사람이 들어오는것을 반기지 않는다. 내 자리를 빼앗길수도 있기 때문이다. 이 부류의 사람들이 많은 회사에 첫째 부류(열성적인)의 사람이 들어오면 적응하기 힘들다. 우선 사람들이 모두 방어적이고 조금 겪어보면 내가 여기서 배울것도 없어 보이기 때문이다. 그러다보면 결국 능력있는 사람들은 모두 떠나고 점점 자리만 차지하려는 사람들만 남게된다. 이런 조직이 얼마나 건강하겠는가? 미래가 뻔히 보이는 회사다.&lt;/p&gt;
&lt;p&gt;처음에도 말했지만 좋은 회사란 지극히 주관적이다. 누가 좋은 회사라고 말한다고 해서 본인에게도 항상 좋은 회사일수는 없다. 하지만, 업무강도가 높아 야근이 많거나 상하관계과 엄격한 회사는 누가 다녀도 좋다고 말하지 않는다. 요즘 젊은이들은 워라밸(work 와 life 의 균형)을 중시한다. 아무리 능력이 뛰어나도 일과 꼰대가 많은 회사는 다니고 싶어하지 않는다. 이에 맞춰 대기업들도 점점 변하고 있다. 능력있는 젊은 사람들의 의식이 바뀜에 따라 이들을 수용하기 위해 지금까지 이어오던 문화를 서서히 바꿔가고 있다. 물론, 아직은 소수에 불과하다. 여전히 예전 문화를 고수하는 회사가 많다. 하지만, 일을 많이 한다고 해서 효율이 높지 않다는 것은 여러 연구결과로 밝혀졌다. 아직도 밤에 사무실에 불이 켜져 있어야만 일좀 하는 회사라는 소리는 옛말이 됐다. 이제는 국내 기업뿐 아니라 글로벌 기업과도 경쟁해야 하는 세상이다. 그들과 경쟁할때 오래되고 나태한 조직문화는 치명적인 약점으로 작용할 것이다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[취미로써의 책읽기 <백마산장 살인사건 : 히가시노 게이고>]]></title><description><![CDATA[최근 몇년간 나의 책읽기는 미래를 위한 책읽기였다. 미래를 위한 책 읽기는 취향보다는 도움되는 책을 선택하는 책읽기 방식을 말한다. 미래를 위한 책읽기의 반대개념은 취미로써의 책읽기다. 책을 읽는게 취미가 되려면 10…]]></description><link>https://blueshw.github.io/2018/08/15/reading_as_hobby/</link><guid isPermaLink="false">https://blueshw.github.io/2018/08/15/reading_as_hobby/</guid><pubDate>Wed, 15 Aug 2018 23:04:29 GMT</pubDate><content:encoded>&lt;p&gt;최근 몇년간 나의 책읽기는 미래를 위한 책읽기였다. 미래를 위한 책 읽기는 취향보다는 도움되는 책을 선택하는 책읽기 방식을 말한다. 미래를 위한 책읽기의 반대개념은 취미로써의 책읽기다. 책을 읽는게 취미가 되려면 100% 취향으로 책을 선택해야한다. 공부가 된다거나 인생을 바꾸고 싶은 마음에 책을 선택할 필요는 없다. 평소에 읽고 싶었던 소설, 무협지, 라노벨(라이트 노벨), 판타지, 로맨스 등 평소 본인이 읽고 싶었던 어떤 책이든 마음대로 선택하면 된다.&lt;/p&gt;
&lt;p&gt;최근에는 &amp;#x3C;사피엔스&gt;를 읽었다. 아직 서평을 쓰지는 않았지만, 읽는동안 유발 하라리의 역사를 꿰뚫는 통찰에 여러번 감탄했던 기억이 있다. 그래서 감히 서평을 쓰기가 무서웠다. 또 이 책은 꽤 두껍다. 물론 나는 전자책으로 읽어서 정확히 몇쪽인지 모르고 읽었지만, 나중에 찾아보니 636 쪽이었다. 소설이나 에세이었다면 그다지 부담스러운 분량은 아니겠지만, 역사(또는 사회과학)책은 잘 읽히는 종류의 책이 아니라서 600 페이지가 넘으면 꽤 부담스럽다. 내가 좀 지쳤을까? 다음번에는 이전과 비슷한 책을 선택하고 싶지 않았다. 책 때문에 지친것도 있지만 최근의 이사, 바쁜 회사일, 살인적인 더위 등으로 체력이 고갈된것이 더 컸다. 그래서 가벼운 책을 읽고 싶었다.&lt;/p&gt;
&lt;p&gt;최근에는 취미로써의 책읽기를 거의 안했다. 예전에는 하루키 소설이나 역사소설(대망, 사카모토 료마 등 일본 역사)을 자주 읽었다. 하지만, 이들도 그렇게 가볍게 읽기는 부담이 되는것도 사실이다. 그래서 더 가벼운 책이 필요했다. 아무 생각 없이 책을 찾아보다가 예전부터 눈여겨 보던 히가시노 게이고의 추리소설을 읽어보면 좋겠다는 생각이 들었다. 추리소설의 광팬은 아니지만 일본의 유명한 추리 만화들은 대부분 챙겨봤던 편이고, 미미여사로 유명한 미야베 미유키 소설도 몇권 읽어보았다. 굳이 일본식 추리에 끌리는건 아니다. 하지만, 요즘 한국에서 유명한 추리소설은 대체로 일본 작가의 것들이다. 이들중 어떤 책을 선택하더라도 대체로 실패하지는 않는다. 그만큼 일본의 추리소설이 다양하고 팬층도 두텁다는 얘기다. 물론 코난도일의 셜록홈즈 시리즈, 아거사 크리스티의 추리소설 시리즈도 재밌지만 내겐 조금 올드한 느낌이라 잘 읽히지 않는다. 히가시노 게이고 작품중 가장 대중적인건 &amp;#x3C;나미야 잡화점의 기적&gt;, &amp;#x3C;용의자 X 의 헌신&gt;이다. 딱히 유명한 작품을 먼저 읽고 싶은 생각은 아니었기에, 제목만으로 책을 선택했다. 그렇게 고른 책이 바로 &amp;#x3C;백마산장 살인사건&gt;이다.&lt;/p&gt;
&lt;p&gt;&amp;#x3C;백마산장 살인사건&gt;은 제목에서도 풍기듯이 산장에 모인 사람들 사이에 벌어지는 살인사건을 다룬다. 산장에 새겨진 암호를 풀어가는 과정, 사람들 사이의 촘촘히 엮인 과거, 밀실 살인, 범인을 찾아내는 과정 등 마치 &amp;#x3C;소년탐정 김전일&gt; 시리즈의 한 챕터를 자세히 보는 느낌이었다. 쉽게 읽히고 전개가 빠른점은 칭찬할만 했다. 그래서 몰입감은 뛰어났다. 하지만, 생각보다 싱거웠다. 최소한 책 한권의 분량으로 담아낸 내용은 소년탐정 김전일의 에피소드 하나보다는 훨씬 깊고 방대한 스토리가 나올줄 알았기 때문이다. 조금은 실망했다. 내가 너무 기대했던 탓일까? 한 권 만으로 유명한 두 작가(미야베 미유키, 히가시노 게이고)를 비교하기는 무리가 있다. 하지만 내게는 미야베 미유키 작품이 훨씬 흥미로웠다. 다음에는 좀 더 유명한 히가시노 게이고의 작품을 읽어볼 생각이다. 그래서 히가시노 게이고가 미야베 미유키 만큼이나 인기 있는건 그만한 이유가 있다는걸 깨달았으면 좋겠다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[식물을 키워보자]]></title><description><![CDATA[…]]></description><link>https://blueshw.github.io/2018/08/13/raise_plant/</link><guid isPermaLink="false">https://blueshw.github.io/2018/08/13/raise_plant/</guid><pubDate>Mon, 13 Aug 2018 00:08:09 GMT</pubDate><content:encoded>&lt;p&gt;새집에는 새집증후군이 있다. 새집증후군이란 새집에 사용한 가구나 벽지 콘크리트 등에서 나오는 유해물질 때문에 눈이 따갑고 피부가 가렵거나 두드러기가 나는 증상을 말한다. 새아파트라고 하더라도 보통 인테리어에 비싼 재료를 쓰지는 않는다. 천연벽지대신 저렴한 실크벽지, 원목대신 MDF 와 시트지, 고급줄눈대신 백색시멘트를 사용한다. 그러다보니 유해물질이 나오는걸 막을도리가 없다. 새 가구에서 나오는 유해물질은 특히 아이들에게 치명적이다. 한창 자라는 아이의 피부는 새집의 유해물질 때문에 아토피가 유발할 수 있다. 집에 포름알데히드(HCHO)와 휘발성유기화합물(TVOC) 수치를 보여주는 간단한 측정기가 있다. 근데 이사한 뒤로 이 녀석이 연신 빨간불을 보인다. 수치가 높아서 위험하다는 신호다. 피톤치드에 야자화성탄에 환기도 열심히 하지만, 문을 닫고 에어컨을 켜면 어김없이 수치가 올라간다. 에어컨을 끄고 환기만 시킬수도 있지만, 요즘같은 더위에 에어컨 없이 지낸다는건 고문에 가깝다.&lt;/p&gt;
&lt;p&gt;어떤 사람은 며칠 지나니 눈이 따갑다고하고, 어떤 사람은 두드러기가 난다고 한다. 나도 피부가 예민한 편인데 이번에는 별달리 새집증후근을 못느꼈다. 대신 와이프와 아이의 몸에 두드러기 같은게 나기 시작했다. 그리 심한편은 아니지만, 더 나빠지기 전에 공기 정화용 식물을 데려오기로 결정했다.&lt;/p&gt;
&lt;p&gt;우선, 검색부터 시작했다. 공기정화가 탁월하면서 초보자도 키우기 쉬운 식물이 어떤게 있나 찾아보았다. 산세베리아, 고무나무, 스투키, 각종 다육식물 등이 나왔다. 검색도 마쳤으니 어디서 살지만 결정하면 됐다. 보통은 양재꽃시장을 가겠지만, 내가 사는 용인과 다소 거리가 있을뿐 아니라 주말에는 특히 서울쪽으로 가기가 싫다. 차도 많고 사람도 많아서 가급적이면 주말의 서울은 피하고 본다. 그래서 대안을 찾아보았다. 요즘 한창 용인 경제신도시로 주목을 받았던 구성 인근에도 화원이 좀 있는걸로 알고 있다. 하지만, 경부고속도로와 맞은편 대로 사이에 껴있는 곳이라 공기가 안좋을것 같아서 패스했다. 좀더 알아보았더니 용인에도 화훼단지가 있다는걸 알게됐다. 이름은 남사화훼집하장. 남사면에 있다고한다. 남사하면 떠오르는건 고립된 6000 여세대의 이편한세상밖에 없다. 물량이 쏟아지면서 전세가 1 억 밑으로도 내려가고 있는 곳이다. 새집인데, 1 억도 안된다니…&lt;/p&gt;
&lt;p&gt;아무튼 목적지를 남사로 잡았다. 집에서 대략 30 분, 그리 먼 거리는 아니다. 드라이브하기 딱 좋은 거리다. 한적한 도로를 한참 달려 남사화훼집하장에 도착했다. 알아본것처럼 엄청 많은 식물들이 한자리에 모여있었다. 양재같은 경우는 여러 업체가 한곳에 모여있는걸로 알고 있는데 여기는 한 업체가 이 큰 규모를 운영하고 있었다. 그리고 기대한것처럼 가격도 매우 저렴했다(아쉬운점은 가격표가 없다는것, 사진찍어가서 보여주면 가격을 알려주신다). 연일 35 도를 넘나드는 날씨덕에 쇼핑 시간이 그리 길지는 않았다. 아이가 다육실물에 눈이 돌아가 와이프가 아이와 다육실물을 고르는 사이 나는 미리 검색했던 식물들을 몇개 골랐다. 공기정화 잘 되라고 엄청 큰 녀석들을 데려가고 싶었지만, 직접 가져가야하는 상황이라 혹시라도 가는중에 상할까봐 조금 작은 녀석들로 선택했다. 매장 모퉁이에서 화분도 팔고 있었고 분갈이도 하고 있었다. 딱히 맘에 드는 화분이 없어 일단 식물만 사가지고 나왔다. 스투키 11 개짜리, 고무나무, 다육식물 7 개를 골랐고, 비용은 총 37,000 원이었다. 싸긴 싸다.&lt;/p&gt;
&lt;p&gt;시작한 일을 끝내야 직성에 풀리는 성미라 화분도 당장 사기로 했다. 집 근처에 지앤숍(백남준 아트센터 맞은편)이라고 대규모의 토분을 취급하는 곳이 있는걸 알고 있던 터라 그쪽으로 방향을 잡았다. 맨날 지나만 다니던 곳인데 직접 방문해보니 정말 대규모였다. 주말이라 사람도 엄청 많았다. 여기는 토분만 판매하는 곳이 아니다. 하이드파크라고해서 카페, 레스토랑, 화원, 토분판매, 문화공간 등 복합 문화 공간이다. 식물도 많아서 구경하기에도 좋다. 건물 디자인도 훌륭하다(건축과 출신의 평이라 믿어도 된다). 근처에 사시는 분이라면 꼭 한번 방문해보길 추천한다.&lt;/p&gt;
&lt;p&gt;때마침 지앤숍에서 할인하는 상품이 있었다. 가격은 좀 나가는 편이었다. 두개에 58,000 원, 그것도 할인해서?? 으잉? 토분값이 식물보다 배는 비싸다. 그래도 와이프가 맘에 들어해서 그냥 구매해버렸다. 또 삽, 배양토 등 분갈이에 필요한 재료도 모두 구매했다. 그랬더니, 거의 10 만원!!! 배보다 배꼽이 크다. 집에 도착해서 4 살 아이가 고른 다육식물들은 직접 분갈이 할 수 있도록 도와주었다. 직접 고른 식물이니 아이 방에서 키우면서 직접 돌보도록 할 생각이다. 나름의 교육이 되지 않을까 생각한다. 다육식물의 분갈이가 끝났다. 이제 큰 두 녀석이 남았다. 늦은 시간이었지만 시작했으니 일단 끝을 보기로 했다. 중간에 모래가 모자라서 마트에서 긴급 공수하기도 했지만 우여곡절끝에 분갈이가 모두 끝났다.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/0-ebfca6c43f7006ff5747b3b0c82343bc-3f0b4.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAMEAgX/xAAVAQEBAAAAAAAAAAAAAAAAAAACA//aAAwDAQACEAMQAAAB68O4Zp4gK//EABkQAAIDAQAAAAAAAAAAAAAAAAIDAAESE//aAAgBAQABBQJp81m2+rW0Jt0Y4Oan/8QAFhEBAQEAAAAAAAAAAAAAAAAAABEB/9oACAEDAQE/AYmP/8QAFhEBAQEAAAAAAAAAAAAAAAAAABIB/9oACAECAQE/AaVr/8QAGxAAAgMAAwAAAAAAAAAAAAAAAAECESEDMTL/2gAIAQEABj8CcqujjS8tFFYR6w2LP//EABsQAQACAwEBAAAAAAAAAAAAAAEAETFRYUGB/9oACAEBAAE/IfIxiboL7HaFia7GqlSr66ibzeM//9oADAMBAAIAAwAAABBTz//EABYRAQEBAAAAAAAAAAAAAAAAAAARYf/aAAgBAwEBPxC2z//EABcRAQADAAAAAAAAAAAAAAAAAAABEWH/2gAIAQIBAT8QpLB//8QAHBABAAICAwEAAAAAAAAAAAAAAQARIVExQWFx/9oACAEBAAE/EMwLTRqyGurq6ulc+ajBADgWNSzYX9zFaZBWjVdxyQLOGn3mf//Z&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;img0&quot;
        title=&quot;&quot;
        src=&quot;/static/0-ebfca6c43f7006ff5747b3b0c82343bc-f8fb9.jpg&quot;
        srcset=&quot;/static/0-ebfca6c43f7006ff5747b3b0c82343bc-e8976.jpg 148w,
/static/0-ebfca6c43f7006ff5747b3b0c82343bc-63df2.jpg 295w,
/static/0-ebfca6c43f7006ff5747b3b0c82343bc-f8fb9.jpg 590w,
/static/0-ebfca6c43f7006ff5747b3b0c82343bc-3f0b4.jpg 820w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;분갈이 해놓고 보니 화분이 식물에 비해 좀 커보인다. 큰걸 산 이유는 딱히 없었다. 그냥 괜찮아 보이는걸로 골랐다. 토분은 보통 붉은계열이 많은데, 이번에 가보니 저렇게 회색도 있더라. 처음보면, 시멘트 화분처럼 보이지만 사실은 이태리에서 날라온 귀하신 토분님이시다. 그래서 가격도 후덜덜하다. 세일만 아니었음 진작에 싸구려 토분으로 데려왔을거다. 근데 사진을 보니 붉은색 토분보다는 회색으로 고른게 잘한것 같다. 역시 우리 와이프님!!&lt;/p&gt;
&lt;p&gt;이녀석들, 어서 무럭무럭 자라서 우리집 나쁜 공기 다 먹어치워버렸음 좋겠다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[종교를 가진 사람이 더 행복한 이유]]></title><description><![CDATA[…]]></description><link>https://blueshw.github.io/2018/08/10/relationship_between_religion_and_happiness/</link><guid isPermaLink="false">https://blueshw.github.io/2018/08/10/relationship_between_religion_and_happiness/</guid><pubDate>Fri, 10 Aug 2018 02:38:31 GMT</pubDate><content:encoded>&lt;p&gt;나는 종교가 없다. 부모님도 종교가 없다. 학교 다닐때 작성하는 생활기록부에 종교란은 항상 ‘무교’라고 적어냈다. 그리고 성인이 되어서도 특별히 종교를 가지겠다는 생각을 해본적도 없다. 종교를 가진적이 없다보니, 종교를 가진 삶을 상상하기는 어렵다. 친한친구 중에 독실한 기독교인이 있지만, 그저 타인의 시선일 뿐이다. 그렇기 때문에 그 친구를 오랫동안 잘 관찰하더라도 진실하게 종교를 가진 삶을 느낄수는 없을 것이다. 종교는 보통 신 또는 신의 대리자가 있고, 그들의 따르는 신자가 있다. 신자들은 종교의 가르침을 믿고 따른다. 그럼으로써 자신과 그들 사이에 연결고리가 만들어진다고 느낀다. 이 연결고리는 그 어떤 도구로 만들어지는게 아니고 신자들의 믿음으로 형성된다. 믿음은 지극히 주관적이기 때문에 아무리 타인이 오랫동안 관찰한다 해도 제대로 이해할 수는 없다.&lt;/p&gt;
&lt;p&gt;그렇다면 행복은 무엇일까? 행복은 판단하는 주체가 누구냐에 따라 다르지만(가령, 생물학자에게 행복은 세르토닌과 도파민의 수치가 올라감을 의미한다), 보통 개인의 기대에 따른 만족감을 의미한다. 개인의 기대치가 높다면 기대만큼 성과가 없을때 우울할것이고 기대치가 낮으면 조그만한 성과에도 행복해할 가능성이 높다. 나는 연봉 2 억을 받고 싶은데 고작 1 억밖에 안된다면 우울할 것이고, 연봉이 5000 만원이면 충분한데 6000 만원을 받으면 행복하다 느낀다. 또한 삶의 의미를 가진 사람이 그렇지 않은 사람에 비해서 행복하다. 삶에 의미가 있다면 어떤 어려움이 닥쳐도 극복해낸다. 예를 들어 아이가 있는 부모는 아이를 위해서 무슨일이든 할 수 있다. 이 부모에게 삶의 의미는 바로 아이다. 반대로 삶의 의미가 없는 사람은 무슨일을 하더라도 별로 감흥이 없다. 내가 지금하는 이 일을 반드시 완수하고 꾸준히 이어나가야할 이유를 찾지 못하는 것이다. 그래서 이런 사람들은 미래를 생각하지 않고 현재의 쾌락만 쫓을 가능성이 높다.&lt;/p&gt;
&lt;p&gt;종교를 가진 사람들에게 종교는 하나의 삶의 의미다. 내가 믿고 따르는 신과 신의 대리자의 가르침을 따르고 종교의 교리를 따라 사는 삶에 의미가 있다고 여긴다. 삶에 의미가 있으니 삶을 대하는 태도가 다르다. 종교의 가르침대로 자신의 분야에서 최선을 다하고 가족과 주변 사람들에게 최선을 다한다. 그래서 종교를 가진 사람들이 대체로 성실하고 긍정적이다. 그리고 타인을 대할때도 종교가 없는 사람들보다는 훨씬 부드러웠다(본심이 아니라 하더라도 표면상으로). 적어도 내가 만나본 진실된 종교인들을 정말 그러했다.&lt;/p&gt;
&lt;p&gt;그렇다면 행복해지기 위해 종교를 가져야만 하는걸까? 삶의 의미를 찾기 힘든 사람에게는 손쉬운 선택지가 될 수 있다. 하지만, 종교가 모든것을 해결해주는 만능열쇠는 아니다. 그리고 믿음이라는게 선택만 한다고 만들어지는 것도 아니다. 믿음없이 단지 목적만을 위해 종교를 선택한다면 아마도 그 사람은 종교라는 삶의 의미를 얻지 못할 가능성이 높다.&lt;/p&gt;
&lt;p&gt;내가 생각하는 행복해지기 위한 가장 좋은 방법은 자기성찰이다. 내가 좋아하는것은 무엇이고, 내가 원하는 미래는 어떤것이며 어떤한 방식으로 살아가고 싶은지 끊임없이 고민하고 나 자신과 대화해야한다. 이때 명상이나 글쓰기가 훌륭한 도구가 된다. 그리고, 내 감정과 나를 동일시하지 않고 분리하는 연습도 필요하다. 많은 사람들이 내 감정이 바로 나라고 착각한다. 하지만, 감정이라는것은 일시적이기 때문에 진정한 나 자신이 될 수 없다. 그래서 화, 성적 쾌락 등의 불필요한 감정 표출을 줄이는 연습이 필요하다. 지속적인 자기성찰은 고통이 따른다. 반복해야하고, 꾸준해야한다. 그리고 절제가 필요하다. 행복해지기 위해 이런 고통을 견뎌내야 한다는게 아이러니하게 들릴지도 모르겠다. 하지만 이 모든것은 참다운 나와 내 삶의 의미를 찾아가기 위한 과정이다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[분양 아파트 입주 후기]]></title><description><![CDATA[새 아파트로 이사한지 5 일 지났다. 아직 정리해야 할 짐이 많지만, 그래도 어느정도 구색은 갖춰졌다. 분양권 구매부터 1 년…]]></description><link>https://blueshw.github.io/2018/08/08/review_move_new_apartment/</link><guid isPermaLink="false">https://blueshw.github.io/2018/08/08/review_move_new_apartment/</guid><pubDate>Wed, 08 Aug 2018 01:28:52 GMT</pubDate><content:encoded>&lt;p&gt;새 아파트로 이사한지 5 일 지났다. 아직 정리해야 할 짐이 많지만, 그래도 어느정도 구색은 갖춰졌다. 분양권 구매부터 1 년 4 개월이 흘렀다. 그리 긴 시간은 아니지만, 꽤 오랫동안 기다린 느낌이다. 생각해보면 입주를 기다리면서 처음 알게된것도 많고 배운것도 참 많다. 그래서 그동안 있었던 일들도 정리해볼겸 간단히 입주 후기를 쓰기로 했다.&lt;/p&gt;
&lt;h2&gt;분양권 매매&lt;/h2&gt;
&lt;p&gt;나는 원래 부동산(대표적으로 아파트)에는 별 관심이 없었다. 주변에 아파트 가격이 몇억씩 한다는 얘길 들으면 ‘왜 저 집은 이렇게 비쌀까’라고만 생각했다. 아마도 지금이 젤 비쌀때고 이제 아파트 값은 내려갈 일만 남았다고 확신했다(기억에 2015 년쯤인것 같다. 이때 집 샀어야하는데…). 그래서 어차피 내려갈 가격인데 지금 굳이 아파트를 살 필요는 없다고 여겼다. 지금 생각해보면 몰라도 너무 몰랐다.&lt;/p&gt;
&lt;p&gt;전세로 살던 곳 근처에 도시개발사업 구역이 있었다. 대략 아파트 6000 세대쯤 들어온다 했고, 모두 주상복합이라고 들었다. 모두 주상복합으로 개발되는 이유는 역세권이라 땅의 용도가 상업지역이기 때문이었다. 아파트를 주상복합으로 지으면 일반 주거지역에 지을때보다 용적률(토지 대비 연면적) 및 건폐율(토지 대비 건축면적)의 허용 범위가 훨씬 넓어지기 때문에 더 높고 빽빽하게(?) 지을수 있다. 기업 입장에서는 이윤을 극대화하는게 주 목적이기 때문에 허용하는 범위내에서 최대한 많이 지으려고 했을 것이다. 그래서 이 지역에 들어오는 아파트들은 모두 빽빽했다. 좀 심할정도로 따닥따닥 붙어 있어서 저기서 살면 너무 답답할것 같다고 느꼈다.&lt;/p&gt;
&lt;p&gt;기억에 각 단지들이 절반정도 지어졌을때였다.&lt;/p&gt;
&lt;p&gt;“저기 너무 따닥따닥 붙어 있는거 아냐?”&lt;/p&gt;
&lt;p&gt;내가 말했다.&lt;/p&gt;
&lt;p&gt;“맞아. 그런것 같에”&lt;/p&gt;
&lt;p&gt;“근데, 저기 가격은 얼마정도야?”&lt;/p&gt;
&lt;p&gt;와이프는 주섬주섬 핸드폰으로 부동산앱을 뒤지더니 대략 얼마정도 한다 얘기했다.&lt;/p&gt;
&lt;p&gt;“뭐가 이렇게 비싸?”&lt;/p&gt;
&lt;p&gt;“그런데 p(프리미엄)는 얼마 안되네…”&lt;/p&gt;
&lt;p&gt;p? p 가 뭐지? p 가 뭔지도 몰랐다. p 는 프리미엄의 앞글자를 말하는것으로 웃돈을 말한다. 최초 분양가가 1 억이고 지금 2 억에 가격이 형성되어 있다면 p 가 1 억이 되는것이다.&lt;/p&gt;
&lt;p&gt;그러고는 누가 얘기했는지 기억도 안나지만,&lt;/p&gt;
&lt;p&gt;“우리 저기 살까?”&lt;/p&gt;
&lt;p&gt;이 한마디가 모든 일의 시작이었다.&lt;/p&gt;
&lt;p&gt;아마 위의 대화가 나누고 거의 바로 부동산에 방문했던것 같다. 각 부동산에 등록된 물건의 시세를 확인해보았고, p 는 초역세권 단지만 좀 붙어있는 상황이었다. 작년(2017 년)이면 부동산 폭등기인데 이 정도 시세라면 안오른거나 마찬가지였다. 부동산 폭등기임에도 불구하고 p 가 이정도 밖에 안된다는건 사람들에게 별 관심의 대상이 아니라는 얘기다. 실거주 목적이긴 했지만, 그래도 내가 산 아파트 가격이 오르면 좋겠다는 생각이었기 때문에 조금 망설여졌다. 어찌됐든 부동산 몇군데를 방문해서 브리핑을 들어보았고 각 단지의 장단점에 대해서 들었다. 어떤곳은 역이 제일 가깝고 어떤곳은 상업시설이 제일 가까웠다. 또 어떤 단지는 초등학교가 바로 앞에 지어지고 있었다. 이를 초품아(초등학교를 품은 아파트)라고 한다. 초역세권 단지가 가장 좋긴했지만 가장 비싸게 거래되고 있었다. 당장에 마련할수 있는 자금은 한계가 있었기 때문에 초역세권 아파트 분양권은 사실상 포기해야했다. 차선으로 주변의 다른 단지 몇군데를 알아보았고 우여곡절 끝에 아주 저렴하게 분양권 하나를 구매하게 되었다. 계약하면서 알게된 사실이지만, 분양권 거래시에는 다운계약서 작성하는 경우가 많다고한다. 분양권을 매도하는 입장에서는 꽤 높은 세금을 물어야하기 때문에 세금은 적게 내기 위한 방편으로 다운계약서를 쓰는 것이다. 다운계약서는 불법이고 걸리면 벌금을 내야하니 쓰지도 권하지도 말아야한다.&lt;/p&gt;
&lt;p&gt;수중의 돈은 모두 전세 보증금에 묶여있었기 때문에 신용대출로 계약금을 마련했다. 참고로 분양권 거래의 경우 매도인이 현재까지 납부한 형태에 따라 다른데, 계약금(분양가격의 10%)만 지불한 경우에는 계약금에 프리미엄(p)을 얹어 매도인에게 주면 거래가 성사된다. 먼저 분양권 거래 계약서를 작성했다. 계약금으로 대략 100 만원정도만 지불했던것 같다. 계약금은 정해진건 없고 매도인과 합의하에 결정하면 된다. 계약서를 쓰면서 한달 후에 소유권 이전 및 잔금을 치르기로 했다. 분양권 매매를 위해서는 몇가지 절차가 필요한데, 우선 중도금 대출이 있는 경우에는 대출승계 절차를 위해 은행을 방문해야 한다. 대출승계가 완료되면 아파트 분양사무실에 방문해서 소유권 이전 계약서를 작성해야한다. 분양권, 확장 및 옵션 등 계약한 모든 사항에 대한 이전 계약서가 필요한다. 두가지 절차가 완료되면 비로소 남은 잔금을 매도인에게 넘기고 온전히 분양권을 넘겨받는다.&lt;/p&gt;
&lt;p&gt;모든 과정을 완료하고 분양권을 넘겨받으니 감회가 새로웠다. 처음은 아니었지만 곧 내 집을 갖게된다는 생각에 공사중인 아파트를 보는 시선도 달라졌다. 그렇게 빽빽하고 답답해보이던 곳이 웅장하고 멋있게 보였다. 수시로 현장을 방문해서 몇층까지 올라갔나 세어보고 잘 지어지고 있는지 살펴보았다. 관련 카페도 여러군데 가입해서 관련 소식에 귀기울이고 필요할때는 목소리를 내기도 했다. 그렇게 입주를 기다리면서 겨울이 지나고 새로운 해가 시작되었다. 드디어 입주 해가 된 것이다.&lt;/p&gt;
&lt;h2&gt;입주 행사&lt;/h2&gt;
&lt;p&gt;아파트 단지의 입주가 7 월 예정이었기 때문에 6 월부터 각종 행사가 시작되었다. 먼저 6 월 초에 입주박람회가 개최되었다. 입주박람회는 각종 입주 관련 서비스와 가전, 가구 업체들이 모여 입주민 대상으로 시중가보다 조금 저렴하게 판매하는 행사다. 박람회 부스를 돌아다니다 보면 정말 전부다 하고 싶어진다. 그러나 입주를 앞두고 들뜬 기분으로 이것저것 구매했다가는 낭패를 보기 쉽상이다. 반드시 사전에 계획했던 것만 계약하고 구매하기를 권장한다.&lt;/p&gt;
&lt;p&gt;또하나의 중요한 행사는 내집 방문의 날이다. 내집 방문의 날은 입주를 한달 정도 앞두고 들어갈 집을 직접 방문해보는 행사다. 우리집 조망이 어떻고 햇볕은 잘들어오는지 확인하고 들여놓을 가구, 가전을 위해 실측을 진행한다. 하지만, 무엇보다 중요한것은 바로 하자를 잡아내는 일이다. 본래 하자를 잡아내는 것은 건설사(또는 시행사)에서 해야하는 업무로 알고 있다. 그런데 왜 입주민들에게 이 일을 맡기게 되었을까? 크게 두가지 정도로 생각해볼 수 있는데, 첫번째는 비용 절감이다. 건설사에서 하자를 잡아내려면 사람을 고용해서 직접 찾아내야한다. 그런데 이 일을 입주민들에게 맡기면 불필요한 비용이 줄어든다. 두번째로 본인 집이기 때문에 하자를 더 잘 찾아낸다는 사실이다. 아무래도 사람을 고용해서 처리하다보면, 생각보다 많이 못찾는다. 자기가 살 집도 아닌데 굳이 눈에 불을 켜고 하자를 잡겠는가? 반면에 본인이 살 집의 하자를 찾으라고 한다면 보이지도 않는곳까지 샅샅이 뒤져서 하자를 잡아낼게 분명하다. 어느쪽이 더 효율적이겠는가?&lt;/p&gt;
&lt;h2&gt;입주 시장(market)&lt;/h2&gt;
&lt;p&gt;지난번에 포스팅에도 한번 썼지만 아파트 입주 시장이 이렇게 크다는 것을 처음 알았다. 원래부터 이렇게 큰 규모의 시장은 아니었던것 같은데 최근 몇년 사이에 급성장했다. 아마도 아파트 폭등기를 거치면서 대규모 신규 물량에 맞춰서 만들어진 시장이 아닐까 추측한다. 입주 시장은 두가지 정도로 나눠서 생각해볼수 있다.&lt;/p&gt;
&lt;p&gt;첫번째는 가전, 가구다. 가전과 가구는 오래전부터 형성되어 있던 시장이다. 누구나 한번쯤은 새 집으로 이사갈때 집에있는 가전이나 가구를 바꿨던 경험이 있을 것이다. 왜 유독 이사를 가면서 물건들을 많이 바꿀까? 이사를 간다고 사용하던 물건들이 고장나는것도 아닌데 말이다. 이들은 여전히 쓸만하지만, 새집으로 이사간다는 홀가분한 마음때문에 손쉽게 버려진다. 새집이기 때문에 물건도 새 제품으로 바꾸고 싶은 욕망이 생겨서 그런지도 모르겠다. 아니면 살던 집과 이사갈 집의 구조, 분위기, 인테리어가 기존 물건들과 너무 안맞다고 생각하기 때문일수도 있다.&lt;/p&gt;
&lt;p&gt;하지만, 두번째 시장은 완전히 새로 만들어졌다. 예전에는 퉁쳐서 인테리어라고 했지만, 요즘은 많이 세분화 되었다. 욕실줄눈, 주방상판 연마 및 광택, 화장실 코팅, 마루 코팅, 단열필름, 안전 방충망, LED 등, 입주청소, 중문, 새집증후군, 베란다 탄성코팅 등 이름만 봐서는 뭐가 뭔지도 모를것들이 정말 많다. 각 부스를 돌아다니면서 해당 서비스가 왜 필요한지 들어보면 정말로 해야만 할 것 같은 기분이 든다. 그런데 가격을 물어보면 결코 만만한 수준은 아니다. 혹시나 해서 다른 업체 부스에 가보더라도 비슷한 가격대가 형성되어 있음을 알 수 있다. 그러다보면 원래 이정도 가격이라고 스스로 합리화하면서 불필요하게 돈을 지출할수도 있다. 지금껏 이런 시공 서비스 없이도 잘 살아왔는데, 왜 유독 새집에 이사갈때 이런것들이 필요한것일까? 새집이면 오히려 더 추가시공이 없어야 하는게 아닌가? 정말 아이러니하다.&lt;/p&gt;
&lt;h2&gt;대출은 어떻게 진행되나?&lt;/h2&gt;
&lt;p&gt;아파트 분양을 받을때는 우선 계약금으로 10%만 지불한다. 그리고 보통 60%를 중도금으로 지불하고 나머지 30%를 입주할때 잔금으로 지불한다. 중도금 같은 경우에는 분양 단지마다 조금씩 다르다. 가장 일반적인 경우가 대출 후 매달 이자를 내는 형태다. 또는 시행사가 이자를 대납하고 후불로 이자를 한꺼번에 내기도 한다. 인기없는 지역의 경우 아예 이자가 면제되기도 한다. 고 분양가의 단지의 경우에는 아예 중도금 대출이 불가할 수도 있으니 주의해야한다. 중도금 대출이 마무리되면(보통 6 회로 나눠서 대출) 곧 입주가 시작된다. 통상 2 달정도 입주 기간이 주어진다. 입주자들은 이 기간내에 중도금을 상환하고 잔금을 치르면 키가 불출된다. 내 소유의 집이 된다는 말이다. 그러면 중도금은 어떻게 상환할까? 보통 집단대출을 이용한다. 집단대출이라해서 특별한건 아니다. 한꺼번에 여러 사람들이 대출상품에 가입하기 때문에 시중보다 조금 낮은 금리로 대출신청이 가능하다. 그리고 중도금이나 잔금, 확장비 등의 비용을 대신 처리해줘서 편리하다. 입주민들은 여러 은행이 소개하는 여러 대출 상품 중 입맞에 맞는 상품을 골라 대출만 신청하면 된다. 그 이후에는 중도금 상환, 잔금, 확장비, 옵션 등 모든일을 은행이 알아서 처리해준다.&lt;/p&gt;
&lt;h2&gt;여기서 끝난게 아니다…&lt;/h2&gt;
&lt;p&gt;아파트 등기도 해야한다. 아직 나도 진행하지 않았는데, 단지와 계약한 법무사를 통해 집단으로 등기업무를 처리한다. 잔금을 치뤘으면 내 집인건 맞지만, 아직 국가가 인정하지는 않았다. 물건을 취득했기 때문에 등록하고 세금(취등록세)을 내야한다. 일련의 업무들은 계약한 법무사가 대신 처리해준다.&lt;/p&gt;
&lt;p&gt;또 한가지 유의할 점은 새 아파트에서는 새것 냄새(HCHO(포름알데히드), TVOC(휘발성유기화합물))가 많이난다는 점이다. 주로 벽지나 가구에서 뿜어져나오는데, 오랫동안 냄새를 맡으면 가끔 어지럽거나 머리가 아프다. 되도록 몇달간은 환기를 잘해주자. 혹시 아이가 있다면 더더욱 신경써줘서 환기해줘야한다. 그렇지 않으면 아토피 등 피부 질환이 생길지도 모른다.&lt;/p&gt;
&lt;p&gt;이제 거의 끝났다. 앞으로 잘 사는 일만 남았다. 주변이 하나씩 정리되고 환경이 만들어지는걸 감상하는 재미를 느껴보자. 학교가 만들어지고 있다면 학교 개교를 기다리고, 쇼핑몰이 만들어지면 쇼핑몰 오픈을 기다리자. 새로 역이 만들어진다면 지하철로 출퇴근하는 상상도 해보자.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[아파트 입주시장은 의외로 크다.]]></title><description><![CDATA[…]]></description><link>https://blueshw.github.io/2018/07/31/apartment_market/</link><guid isPermaLink="false">https://blueshw.github.io/2018/07/31/apartment_market/</guid><pubDate>Tue, 31 Jul 2018 00:37:48 GMT</pubDate><content:encoded>&lt;p&gt;처음 신축 아파트에 입주하다보니 생각보다 신경쓸 일이 많다. 구축(연식과 상관없이 신축이 아닌) 아파트에 입주할때는 계약하고 잔금치르고 이사만 하면 대부분 끝이다. 하지만 신축은 알아볼 것도 많고 정도에 따라 추가비용도 만만치 않다. 모든게 새로 만들어진 신축 아파트인데 도대체 뭐를 더 해야한단 말인가? 이상하게 들릴지 모르지만, 사실이 그렇다. 신축일수록 부가적인 비용이 더 많이 든다. 그럼 대체 왜 비용이 많이 드는 것일까?&lt;/p&gt;
&lt;p&gt;입주를 한달 정도 남겨두면 대부분의 단지에서는 입주박람회를 개최한다. 입주박람회를 간단히 설명하자면, 가전이나 가구 또는 각종 인테리어 시공 업체들이 한자리에 모여 예비 입주자들에게 제품과 서비스를 저렴하게 판매하는 행사다. 진짜 저렴하긴 하다. 아니, 저렴한 것처럼 보인다. 그런데 알아보면 아주 조금 저렴한 정도다. 입주박람회 내에서 비교군이 없다보니 업체 사람들 말만 듣고 결정하기 쉬운데, 조금만 더 알아보면 비슷하거나 더 저렴한 곳도 많다. 아무튼, 입주박람회라는 행사에 가보면, 정말 다양한게 많다는걸 알게된다. 타일 줄눈, 욕실 나노코팅, 베란다 탄성코팅, 마루 바닥코팅, 입주청소, 새집증후군, 커튼, 중문, 안전 방충망, 미세먼지 방충망, 인덕션, 음식물 처리기, 이사, 주방상판연마 및 코팅, 붙박이장 등 새집과 관련된 정말 다양한 업체가 행사장에 모인다. 부스에 방문해서 각 업체의 설명을 듣다보면, 이건 정말 해야할껏 같은 기분이 든다. 그렇다고 저렴한것도 아니다. 대부분 적게는 20 만원에서 많게는 수백만원의 비용이 필요하다. 그럼에도 불구하고 내가 처음 들어가는 새집이기 때문에 비용을 들여서라도 좀더 나은 환경을 만들고 싶은 욕구가 샘솟는다.&lt;/p&gt;
&lt;p&gt;나도 입주박람회를 방문하고서 신축 아파트 입주 관련 시장이 이렇게 큰지 처음 알게되었다. 입주박람회를 여는 단지의 경우 대체로 1000 세대 이상인 경우가 많다. 업체 입장에서는 조금 싸게 판매하더라도 한꺼번에 많은 사람에게 판매할 수 있는 입주박람회는 단기간에 매출을 올릴수 있는 절호의 기회다. 공구(공동구매)를 생각하면 쉽다. 사람을 모아서 싸게 판다는 원리는 동일하다. 이렇게 조금이라도 저렴하다보니 사람들이 혹하기 쉽다. 처음에는 별 생각없이 방문했다가도 나올때는 몇장의 계약서와 함께인 경우가 흔하다. 업체의 설명을 듣다보면 정말 필요한것 같고, 하고 싶다는 생각이 들기 때문이다.&lt;/p&gt;
&lt;p&gt;나는 그래도 많이 참았다. 처음부터 하기로 생각했던 것들만 신청했다. 중문, 입주청소, 안전 방충망 이렇게 세가지만 계약했다. 중문은 방음 및 보온을 위해서 반드시 할 생각이었고, 입주청소도 내가 할 수 있지만, 너무 힘들것 같아 신청했다. 안전방충망은 예전에 빌라에 살때 좋았던 기억이 있어 비슷한 브랜드의 더 나은 제품으로 선택했다(그래서 더 비싸다…). 이후에 건조기도 구매하고 세탁기도 새로 샀다. 가스레인지에 미세먼지가 그렇게 많이 나온다고 해서 인덕션도 해외직구로 구매했다. 인덕션을 구매했더니 인덕션 전용 용기가 필요하더라. 그래서 와이프가 예전부터 갖고싶어했던 휘슬러 냄비세트 + 압력밭솥 + 후라이팬(세개 합치면 거의 50 만원ㅠㅠ)을 구매했다. 돈이 계속 나간다. 여기서 끝이 아니다. 딸의 방을 꾸며주겠다고 이케아 어린이 가구도 몇개 샀다. 그리고 드레스룸 규모가 작은듯해서 옷장도 구매했다. 이 넓은 거실에 소파하나 없으면 안되겠다 싶어 소파도 구매했다. 게다가 침대로도 변신하는 녀석이다. 청소가 쉽다해서 주방상판코팅, 욕실 나노코팅도 하고 싶었지만, 코팅 용액 가격에 비해 지나치게 비싸게 느껴져서 셀프로 작업해버렸다(다신 안할꺼다. 냄새도 심하고 힘들다). 여기까지 대략 필요한 것들과 하고싶은 것들의 구매 목록이다. 참 많다. 하지만, 더 충격적인 사실은 우리가 그렇게 많이하는 편이 아니라는 것이다. 도대체 많이 하는 사람들은 얼마를 쓰는걸까?&lt;/p&gt;
&lt;p&gt;새집에 이사할때는 대부분 대출을 끼고 구매한다. 대출 없이 집을 구매하는 사람은 거의 없다. 그렇다보니 대출할때 천만원 정도는 우습게 생각한다. 1 억을 빌리든 1 억 1 천을 빌리든 크게 개의치 않는다. 1 억 빌려도 충분히 입주 가능하지만, 여러가지를 구매하기 위해 1 천만원을 더 빌린다. 은행에서는 두팔벌려 환영이다. 이자 더 내겠다는데 말릴 필요 있을까? 그런데 막상 1 천만원을 갚으려고 하면 만만치 않다. 특히 나처럼 외벌이 직장인이라면 더더욱 힘들다. 애를 키우면서 1 년에 1 천만원을 더 갚으려면 정말 아끼고 아껴야 한다. 그런데 내집에 입주한다는 들뜬 마음 때문에 평소에는 생각하지도 않던 소비를 마음 놓고 해버린다.&lt;/p&gt;
&lt;p&gt;입주시장과 비슷한 시장이 몇가지 있다. 첫번째로 결혼시장이다. 결혼할때는 두 집안이 서로 눈치를 보느라 합리적이고 실용적인 소비가 어렵다. 어른들은 체면도 차려야 하고 자기 자식이 남의 집에서 우습게 보이길 원치 않는다. 그러다 보니 뭐 하나를 하더라도 절대 저렴하게 하지 않는다. 두번째는 아이들 관련 시장이다. 아이들이 입는 옷, 아이들의 교육, 아이들의 장난감 뭐 하나 쉽게 결정하지 않는다. 저렴하지도 않다. 특히나 요즘처럼 한 아이만 키우는 가정이 많다보니 더더욱 애지중지 키운다. 그렇다보니 부모들은 아이들에게 투자를 아끼지 않는다.&lt;/p&gt;
&lt;p&gt;입주 관련 시장은 위에서 말한 결혼과 아이들 관련 시장에 비해 결코 작은 시장이 아니다. 게다가 대출이라는 편리한 제도 때문에 사람들이 더욱 쉽게 지갑을 연다. 나중에 생각해보면 해도 그만 안해도 그만인게 대부분이지만, 이미 쉽게 열린 지갑이 닫히는 법은 없다. 특히 나처럼 처음 새 아파트에 입주하는 사람이라면 자기 집을 더 이쁘고 편하게 꾸미고 싶은 욕망이 있어 뭐라도 더 하고 싶어한다. 역시 사람은 다양한 경험을 해보는게 중요하다. 내가 새 아파트에 입주해보지 않았다면 이런 입주 시장이 클거라고는 전혀 생각지 못했을 것이다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[최고의 스포츠 워치, 순토(suunto)]]></title><description><![CDATA[…]]></description><link>https://blueshw.github.io/2018/07/27/my_watch_suunto/</link><guid isPermaLink="false">https://blueshw.github.io/2018/07/27/my_watch_suunto/</guid><pubDate>Fri, 27 Jul 2018 00:44:55 GMT</pubDate><content:encoded>&lt;p&gt;나는 원래 시계를 잘 차지 않는다. 지금까지 살면서 시계를 오랫동안 착용해본적이 없다. 예전에 와이프가 선물했던 시계도 있었는데, 잠깐 차다 서랍에 넣어버렸다. 시계를 잘 안차는 이유가 뭘까? 시계를 차면 팔목에 땀이 차서 그런건지도 모른다. 특히 가죽밴드 시계를 차면 거의 재앙에 가깝다. 한 달만 착용해도 갈색밴드가 시커멓게 변해버리기 때문이다. 더럽고 냄새난다. 아니면 핸드폰이 있으니 시계가 필요함을 느끼지 못해서일지도 모르겠다. 시계가 시간을 보는거라고? 아니다. 시계는 시간을 보기 위한 용도가 아니다. 시계에 열광하는 대부분의 남자들은 시간을 볼수 있어서 열광하는게 아니다. 그들이 시계에 열광하는 이유는 여자가 반지와 목걸이에 열광하는 이유와 같다. 그래서 시계 가격도 브랜드에 따라 천차만별이고 심하게는 수천만원에서 1 억을 넘어가는 시계도 있다.&lt;/p&gt;
&lt;p&gt;시계를 거의 안차다가 몇년 전, 핏빗(fitbit)이라는 스마트밴드를 써보게 되었다. 스마트밴드는 스마트폰과 블루투스로 연결하여 동작하는 일종의 운동 보조기구다. 내가 핏빗을 구매한 이유가 특별히 운동을 위해서는 아니었다. 다만, 스마트폰 전화 알림이나 문자 알림과 같은 기능을 가진 뭔가 있으면 좋겠다고 생각했었다. 주머니나 가방에 스마트폰을 넣어두다보니 전화를 못받는 경우가 많아서 불편했기 때문이다. 물론 스마트밴드의 알림기능이 주 기능은 아니다. 주 기능은 운동량을 측정하고 걸음을 측정해서 칼로리 소비를 계산하는 등 운동을 도와주는 것이다. 핏빗은 스마트밴드 중에서는 꽤 고급 브랜드에 속한다. 요즘에는 미밴드 등 저렴한 스마트밴드도 많이 출시 되었지만, 처음 핏빗이 등장했을때는 꽤나 비싸게 판매되었다.&lt;/p&gt;
&lt;p&gt;핏빗을 일년 넘게 잘 사용하다가 어느날 잃어버렸다. 여름이었고 버스였다. 너무 땀이 많이 차서 잠깐 벗어두었다가 급하게 내리면서 놓고 내렸다. 너무 잘 사용하고 있었기 때문에 또 사고 싶었다. 하지만, 여전히 핏빗은 고가였고 그 가격이면 조금 더 보태서 스마트워치로 넘어가도 되겠다 생각했다. 그러다 페블(pebble)을 알게되었다. 페블은 킥스타터에서 성공적인 펀딩으로 화제를 불러일으킨 스마트워치의 조상격이다. 페블이 유명세를 타면서 이후 스마트워치가 우후죽순으로 쏟아져나왔다. 대표적으로 애플의 애플워치, 삼성의 기어시리즈가 있다. 애플워치나 기어시리즈도 훌륭한 제품이다. 하지만 가장 큰 단점으로 꼽히는게 바로 배터리다. 거의 매일 충전해야하고 하루라도 충전하지 않으면 방전되기 일쑤다. 나는 매일 충전할 자신이 없었다. 가격도 한몫했다. 치명적인 단점을 가지고 있으면서 가격도 만만치 않다. 그래서 페블을 사기로 마음먹었다.&lt;/p&gt;
&lt;p&gt;페블은 e-ink 를 사용하기 때문에 배터리 지속시간이 길다. 대체로 1~2 주 정도는 한번 충전으로 거뜬하다. 게다가 가격도 저렴하다. 핏빗 살 정도에 몇만원만 보태면 페블을 구매할 수 있었다. 마침 그 즈음, 킥스타터에서 페블 2 를 펀딩하고 있었고 당장 신청했다. 몇개월이 지나서 비보가 들려왔다. 페블이 핏빗에 인수된다고 한다. 그리고 자연스럽게 펀딩은 취소되었다(허허, 만들던건 끝내야지… 내가 다시 킥스타터하나봐라…). 그렇게 몇개월간의 기다린 보람도 없이 내 새로운 시계는 사라져버렸다.&lt;/p&gt;
&lt;p&gt;포기할수 없었다. 한번 사기로 했으니 다른 브랜드를 더 찾아보기로 했다. 아무래도 배터리가 맘에 걸려 애플워치나 기어는 싫었다. 페블처럼 e-ink 를 사용하면서 배터리 지속시간이 긴 워치가 필요했다. 처음 발견한 워치는 카시오의 쥐샥이었다. 쥐샥은 대부분 시계 기능에 충실한 시계지만, 스마트폰과 연동 할수 있는 모델도 몇 개 있었다. 하지만, 출시된지 너무 오래되었고, 후속모델도 더이상 나오지 않는 상황이었다. 내 생각에는 카시오가 더이상 블루투스 모델을 만들 생각이 없는듯했다. 그래서 깔끔하게 접었다.&lt;/p&gt;
&lt;p&gt;그 다음 찾은 브랜드가 순토(suunto)다. 드디어 순토다. 순토는 핀란드위 위치한 스포츠 워치 전문 브랜드다. 대부분의 전자제품(?) 회사들은 본사에서 디자인하고 중국이나 동남아에서 조립하는게 일반적이지만, 순토는 제품의 대부분을 핀란드 현지에서 제작한다. 그래서 믿음이 간다. 핀란드하면 자일리톨밖에 모르는 사람이 많겠지만, 한때 핸드폰 시장을 장악했던 노키아나 게임업계의 공룡기업인 슈퍼셀이나 로비오 엩터테인먼트(앵그리버드 제작사)가 핀란드의 회사다.&lt;/p&gt;
&lt;p&gt;순토 시계는 (개인적인 취향이지만) 이쁘다. 그런데… 가격이 좀 비싸다. 고급모델은 100 만원도 넘는다. 물론 소재가 티타늄이나 사파이어 글래스인 경우지만, 보급 모델의 경우에도 거의 50 만원 이상은 필요하다. 너무 비싸서 새 제품을 살 엄두가 안났다. 그래서 중고나라, 번개장터, 셀잇 등 중고 거래가 가능한 곳이라면 어디든 다 검색해 보았다. 그러다 셀잇에서 트래버스 사파이어블랙 모델(이 정도면 훌륭한 디자인이다)이 저렴하게 나온걸 발견했다. 당장 질렀다. 트래버스는 트래킹에 최적화된 모델로, 내비게이션 기능이 탑재되어있다. 시계에 웬 내비게이션? 이게 무슨 기능이냐면, 미리 좌표를 찍어두고 길 찾기를 선택하면 방향과 거리를 계산해 어디로 가야할지를 알려준다. 또는 지난간 길을 기억해서 원점으로 되돌아 갈 수 있게 도와주는데, 덕유산 갔을때 한번 써본적 있다. 하지만, 한국의 산은 워낙에 길이 잘 닦여 있어 그닥 필요한 기능은 아니다. 이외에도 순토 시계(다이빙 전용을 제외하고)는 기본적으로 달리기나 싸이클 같은 운동의 데이터를 측정하고 분석한다. 모델에 따라서 수영이나, 등산 등 다양한 운동 수십여가지를 지원한다. 각종 센서와 기본으로 탑재된 GPS 로 거리와 움직임을 측정하고 심박센서로 칼로리 소모를 측정한다. 아주 좋다. 시계도 이쁘고 알림도 되고 운동 기능도 다양하다.&lt;/p&gt;
&lt;p&gt;거의 2 년가까이 사용하다보니 계속 눈에 거슬리는게 하나 있었다. 스마트폰에 뜨는 알림 메세지를 시계에도 보여주는데 메세지가 길어지면 짤려서 내용을 볼수가 없다. 특히 카톡같은 경우에는 대략 20~30 자 정도밖에 보여주지 않기 때문에 내용을 정확하게 알 수가 없었다. 이게 너무 불편했다. 시계에서 확인하고 싶은데, 메세지 앞부부만 확인하고 또 핸드폰을 켜야만 했다. 그리고 또 한가지, 순토에서 새로운 모델을 출시했다. 심박센서가 내장되었고 컬러모델(스파르탄 모델)이다. 지금까지 순토 시계에는 심박센서가 내장되어 있지 않았다. 별도의 센서를 사서 가슴부위에 착용한 후 운동량을 측정해야 했다. 아.. 말만 들어도 불편하다.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/0-d3869296d081b84a13e40d98934be686-d3206.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMFAf/EABUBAQEAAAAAAAAAAAAAAAAAAAEC/9oADAMBAAIQAxAAAAGhDciGiaD/AP/EABkQAAMAAwAAAAAAAAAAAAAAAAECAwATFP/aAAgBAQABBQK9dcpu1a89Bj3LCJ1HqGf/xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAwEBPwGI/8QAFhEBAQEAAAAAAAAAAAAAAAAAABEB/9oACAECAQE/Aauv/8QAHBAAAgICAwAAAAAAAAAAAAAAAAECIRESEDGR/9oACAEBAAY/AnJI1qypL0ccZNu+P//EAB0QAAICAQUAAAAAAAAAAAAAAAABIUFhEBExUXH/2gAIAQEAAT8hkYfC3FR3k6K2WBFQasZbOPNL/9oADAMBAAIAAwAAABCsz//EABYRAQEBAAAAAAAAAAAAAAAAAAEQEf/aAAgBAwEBPxBGz//EABcRAQADAAAAAAAAAAAAAAAAAAEQESH/2gAIAQIBAT8QFWxf/8QAGhABAQEBAQEBAAAAAAAAAAAAAREAIUFRkf/aAAgBAQABPxByQ4HRVldbWaiIQWc8xWIO9DRrVpAT7q4Bqb0e4AKP47//2Q==&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;img0&quot;
        title=&quot;&quot;
        src=&quot;/static/0-d3869296d081b84a13e40d98934be686-f8fb9.jpg&quot;
        srcset=&quot;/static/0-d3869296d081b84a13e40d98934be686-e8976.jpg 148w,
/static/0-d3869296d081b84a13e40d98934be686-63df2.jpg 295w,
/static/0-d3869296d081b84a13e40d98934be686-f8fb9.jpg 590w,
/static/0-d3869296d081b84a13e40d98934be686-d3206.jpg 728w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;&amp;#x3C;나의 순토 스파르탄 스포츠 HR&gt;&lt;/p&gt;
&lt;p&gt;사람 욕심은 끝이 없나보다. 잘 쓰던 트래버스 모델을 회사 동료에서 헐값에 넘겼다. 그리고 또 다시 폭풍 검색. 중고 사이트를 모두 뒤지다
저렴하게 나온 스파르탄 스포츠 HR 모델을 발견했다. 당장에 직거래로 구매했다. 시계 외관은 솔직히 트래버스가 한수 위라 생각한다. 스파르탄
모델은 뭔가 밋밋한 느낌이다. 터치스크린을 장착했기 때문이라 생각하지만 그래도 좀 아쉽긴하다. 하지만, 다양한 기능에 컬러 그리고 트래버스의
주 기능인 내비게이션도 지원한다. 무엇보다도 스마트폰 알림 메세지를 전부 확인할 수 있다는게 너무 좋다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[목표를 가져야겠다]]></title><description><![CDATA[몸이 점점 지쳐가는 느낌이다. 체력이 떨어지는게 피부로 느껴진다. 20 대에는 괜찮았는데, 30 대에 접어들면서 체력이 떨어지는게 점점 심해진다. 2…]]></description><link>https://blueshw.github.io/2018/07/25/need_goal/</link><guid isPermaLink="false">https://blueshw.github.io/2018/07/25/need_goal/</guid><pubDate>Wed, 25 Jul 2018 00:29:56 GMT</pubDate><content:encoded>&lt;p&gt;몸이 점점 지쳐가는 느낌이다. 체력이 떨어지는게 피부로 느껴진다. 20 대에는 괜찮았는데, 30 대에 접어들면서 체력이 떨어지는게 점점 심해진다. 20 대에는 밤을 새어도 다음날 멀쩡했지만, 지금 밤을 샛다간 며칠을 골아 떨어질지 모른다. 나이가 들면, 체력이 떨어지는 것은 당연하다. 우리 몸에도 사용기한이 있기 때문에 쓰면 쓸수록 낡고 무뎌진다. 그럼 다른 이유가 있을까? 혹시 아이 키우는게 문제일까? 아이를 키우는게 체력에 영향이 있는건 분명하지만, 문제의 근원은 아니라고 생각한다. 아이를 낳기 전 30 대 초반에도 분명 체력에 대한 문제는 느끼고 있었기 때문이다. 아무리 생각해도 문제는 규칙적인 운동의 부재다.&lt;/p&gt;
&lt;p&gt;회사 동료와 일주일에 2 번정도 수영을 한다(1 번 할때가 더 많다). 보통 점심시간을 이용하는데, 수영장과 거리가 있다보니 실제로 수영할 수 있는 시간은 길지 않다. 대략 15 분 정도밖에 안된다. 맞다. 너무 짧다. 일주일에 두번, 15 분씩 총 30 분의 수영으로 내 몸에 변화가 올거라는 생각은 없다. 다만 안하는 것보다는 낫다는 마음으로 다닌다.&lt;/p&gt;
&lt;p&gt;일주일에 30 분 수영은 해결책이 아니다. 제대로 몸을 변화 시키고 체력을 늘리기 위해서는 이보다 훨씬 강도높고 꾸준한 운동이 필요하다. 뭐가 있을까? 요가를 해볼까? 헬스장을 등록할까? 복싱이나 무술 같은걸 배워볼까? 아니면 예전부터 하고 싶었던 검도를 해볼까? 몇가지가 떠오르지만, 막상 시작하자니 부담스럽다. 헬스를 제외한 어떤 운동이든 장소를 찾고 정해진 시간에 맞춰야하기 때문이다. 아이를 키우는 입장에서 정기적으로 시간을 빼는건 결코 쉬운일이 아니다. 결국, 헬스장을 등록해야 하는건가? 지금껏 헬스장에서 운동하려고 몇번 시도했었다. 하지만 모두 실패했다. 헬스장 운동이 워낙 재미없었기 때문이다. 그래서 망설여진다. 또 몇개월에 십몇만원의 돈으로 헬스장을 등록하고 한두 달 다니다 그만둘 것 같다. 그럼 어떤 방법이 있을까? 다른 운동을 찾아야 할까? 아침에 일어나서 조깅이라도 해볼까? 헬스장 가는것보다 더 어려울것 같다. 뭔가 구체적인 목표가 필요하다.&lt;/p&gt;
&lt;p&gt;목표 설정은 중요하다. 아무리 작은 일이라도 목표가 없으면 실패할 가능성이 높다. 특히나 운동같이 끈기가 필요한 행위는 목표설정이 더욱 중요하다. 살은 얼만큼 빼겠다거나, 하프마라톤을 완주하겠다거나, 각종 아마추어 대회에 참가해보겠다는 것처럼 자신만의 목표가 있어야 한다. 그럼 나는 어떤 목표를 설정해야할까? 마라톤은 어떨까? 물론 하프나 풀코스는 아니고 우선 10km 에 도전해볼까 생각중이다. 10km 야 지금 뛰어도 불가능할 거리는 아니지만, 대회 등록을 하면 목표가 생겨 한번이라도 더 뛸것 같다. 마라톤 대회를 좀 찾아봐야겠다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[나의 책 읽는 방법]]></title><description><![CDATA[…]]></description><link>https://blueshw.github.io/2018/07/21/my_reading/</link><guid isPermaLink="false">https://blueshw.github.io/2018/07/21/my_reading/</guid><pubDate>Sat, 21 Jul 2018 01:49:58 GMT</pubDate><content:encoded>&lt;p&gt;과거에 나는 산만한 독자였다. 맘에 드는 책 한권을 고르면 다 읽기 전에 또 다른 책을 집어들었다. 끌리는대로, 내 생각의 흐름에 따라 원하는 책을 읽었다. 건축서적을 읽다가도 재미있는 소설책이 있다는 소식을 들으면 당장에 구매했다. 만화책을 보고싶으면 언제든 만화책을 읽었다. 또 어떤 감명깊게 읽은 책에서 추천하는 책이 있으면 우선 구매하기 바빴다. 책을 사모으길 즐기는 탐서주의자였고, 책을 읽는 속도보다 사는 속도가 더 빨랐다. 책은 쌓여갔고 책장에는 펴보지도 않은 책으로 가득찼다. 그래도 역시나 책 읽기는 좋아했다. 시간이 날때마다 책을 읽었고, 많이 읽지는 못해도 항상 책은 가지고 다녔다. 그렇다. 책 읽기는 내 취미였다. 읽는 행위가 즐거웠고, 재밌었다. 그래서 내키는대로 읽었다. 그런데, 취미에 규칙같은 강제가 생기면 어떻게 될까? 예를 들어 책을 읽을때 한권을 완독할때까지 다른 책을 집어들면 안된다는 것이나 3 일에 반드시 한권은 읽어야 한다는 것처럼 말이다.&lt;/p&gt;
&lt;p&gt;취미의 독서라면 아무 문제 없다. 책을 완독하는게 중요한것도 아니고, 여러 권을 동시에 읽는다 해서 딱히 문제될건 없다. 여기서 취미의 독서라함은 흥미위주의 책읽기를 말한다. 텍스트를 읽는 목적이 오로지 즐기기 위함일때 흥미위주의 책읽기라 말한다. 소설이 될 수도 있고, 에세이가 될수도 있고, 만화책이나 무협지가 될수도 있다. 자신이 원하는 책을 선택해서 읽으면 된다. 취미기 때문에 규칙따위는 상관하지 않아도 된다. 독서 방법도 마음내키는데로 하면 된다. 원하는 부분만 발췌해서 읽어도 되고 빠르게 훑어봐도 된다. 또는 여러권을 동시에 읽어도 상관없다. 만화책을 읽을때 여러개를 동시에 읽는다고 해서 문제 될껀 없지 않은가? 실제로 연재속도가 느리다보니 여러권의 만화책을 동시에 읽는 사람이 대부분이다.&lt;/p&gt;
&lt;p&gt;그런데 이제는 독서 방법을 바꿨다. 기존의 방법이 잘못돼서 바꾼건 아니다. 기존의 방식도 훌륭한 독서 방법의 하나다. 즐겁지도 않은데 꾸준히 책을 읽으려면 얼마나 힘들겠는가? 다만, 내 독서 방법이 바뀐 이유는 독서의 목적이 바꼈기 때문이다. 예전에는 즐기기 위해 책을 읽었다. 하지만, 지금은 인생을 바꾸기 위해 책을 읽는다. 소프트뱅크의 손기정 회장은 시한부를 선고받고 병원에 입원한 3 년동안 무려 3000 권의 책을 읽었다고 한다. 언제 죽을지도 모르는 상황에서도 책에서 손을 놓지 않고 다가올 미래에 대비했던 것이다. 그렇다면, 책 읽는 방법만 바꾼다고 인생이 바뀔까? 가능하다고 생각한다. 다만, 적절한 전략이 필요하다.&lt;/p&gt;
&lt;p&gt;인생을 바꾸는 독서를 위한 전략은 두가지 측면에서 생각해야 한다. 첫번째는 책을 선택하는 방법이다. 우선은 내가 알고 싶고 관심가는 분야를 선정한다. 관심사가 정해졌으면 해당 분야의 입문서격인 책을 몇권 선택한다. 입문서를 선택하는 이유는 해당 분야에 대한 개괄적인 지식을 얻을 수 있기 때문이다. 만약에 처음부터 깊이있고 어려운 책을 고른다면 한권을 다 읽기도 전에 나가 떨어질지도 모른다. 입문서를 몇권 읽고 나면 자연스럽게 다음 읽고 싶은 책이 생긴다. 예를 들어 부동산 투자에 관한 책을 읽는다고 가정하자. 처음에는 부동산의 전반적인 흐름과 투자방식을 개괄적으로 알수 있는 입문서를 완독한다. 이후에는 몇가지 선택지가 생긴다. 아파트가 될수도 있고, 빌라가 될수도 있다. 또는 땅에 관심이 갈수도 있다. 아니면 경매라는 구매방식에 관심이 갈수도 있다. 또는 부동산 투자보다는 경제상황에 따른 부동산 흐름이나 거시경제로 눈을 돌릴수도 있다. 무엇이 됐든간에 분명 특정 분야로 관심이 쏠릴것이다. 그때는 이전에 읽었던 입문서에 소개된 책들을 읽어 볼 수도 있고, 서점이나 웹에서 관련 전문서를 찾아볼수도 있다. 입문서부터 전문서까지 최소 20 권(딱히 이유는 없고 내 기준이다)이상의 책을 읽어보자. 이때 중간에 다른 책은 읽지 않고 되도록 같은 분야의 책을 연속적으로 읽는것이 좋다. 중간에 다른 분야의 책을 읽으면 관심사가 바뀔수 있기 때문이다. 기껏 한 분야에 책 몇권을 읽고 다른 분야로 옮겨간다면 지금까지 읽은 책은 괜한 시간낭비가 될 수 있다. 한 분야의 책을 20 권 이상 읽기가 완료되면, 이전과는 조금 달라진 모습을 발견할지도 모른다. 예전에는 전혀 이해할수 없었던 글이나 기사가 이해되기 시작한다. 전혀 몰랐던 용어나 개념들이 이해되기 때문에 글이 술술 읽히고 내용도 머리에 쉽게 정리된다.&lt;/p&gt;
&lt;p&gt;두번째는 양적인 측면이다. 위에서 20 권을 읽는다고 했는데, 그렇다면 위에서 말한 20 권을 언제까지 읽어야 할까? 정해진 답은 없다. 본인이 원하는 기간을 잡고 읽으면 된다. 기간이 얼마가 되느냐 보다는 마감시간을 정하는 것이 중요하다(친구와 내기를 해도 좋고, 본인 스스로 약속을 해도 좋다). 어떤 분야의 책, 20 권을 읽는다고 가정하자. 책마다 양이 다르기 때문에 딱 잘라 말하기는 힘들지만, 한 권당 평균 3 일을 잡자(느리게 읽거나 시간이 없으면 더 길게 잡아도 된다). 그럼 3 일에 20 권이니깐 총 60 일, 두달이다. 두달 안에는 반드시 20 권을 읽도록 하자.&lt;/p&gt;
&lt;p&gt;마감 없이 책을 읽는다고 생각해보자. 그러면, 한권을 읽다가 한달이 지날수도 있다. 책이란게 모든 파트가 흥미롭지는 않기 때문에 늘어지는 부분이 있기 마련이다. 늘어지는 부분이 생기면 책 읽는 속도는 확연히 느려진다. 하지만 마감시간을 정하고 책을 읽으면 흥미롭지 않아도 늘어지지 않을 가능성이 높다. 마감시간이 강제성을 부여하기 때문이다.&lt;/p&gt;
&lt;p&gt;위에서 인생을 바꾸는 독서 전략에 대해 알아보았다. 나도 아직 말한것처럼 잘 지키지는 못한다. 회사 일이 바쁘면 조금 느려지기도 하고, 지금처럼 이사를 앞두고 있을때도 정신이 딴데 팔려있어서 책 읽는 시간이 부족할 때도 있다. 하지만, 내가 말한 방식을 꾸준히 잘 지킨다면, 정말 내 인생을 바꿀수 있다는 생각은 변함없다. 구체적으로 어떻게 바뀔지는 전혀 모른다. 아마 끊임없이 책을 읽는 과정 속에서 그 답을 찾아갈 수 있는게 아닐까 생각한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[스페셜리스트(specialist) vs 제너럴리스트(generalist)]]></title><description><![CDATA[제너럴리스트(generalist)라는 단어는 다치바나 다카시의 저서 ‘뇌를 단련하다’에서 처음 알게 되었다. 제너럴리스트(generalist…]]></description><link>https://blueshw.github.io/2018/07/19/specialist_vs_generalist/</link><guid isPermaLink="false">https://blueshw.github.io/2018/07/19/specialist_vs_generalist/</guid><pubDate>Thu, 19 Jul 2018 00:34:31 GMT</pubDate><content:encoded>&lt;p&gt;제너럴리스트(generalist)라는 단어는 다치바나 다카시의 저서 ‘뇌를 단련하다’에서 처음 알게 되었다. 제너럴리스트(generalist)는 사전적으로 ‘모든 일에 능숙한 사람’ 과 같은 의미를 가진다. 책에서는 뉘앙스가 조금 다른데, 모든 일에 능숙하기 보다는 다양한 분야에 폭넑은 지식을 가지고 종합적으로 사고하는 사람을 뜻한다. general 이라는 단어가 ‘일반적인’이라는 의미로 많이 쓰이지만, ‘장군’이라는 뜻으로도 쓰인다. 장군은 하나의 전문화된 특기는 없지만, 군에서 돌아가는 대부분을 알고 있으며 이를 바탕으로 종합적인 판단을 내린다.&lt;/p&gt;
&lt;p&gt;제너럴리스트는 한 분야에 뛰어난 지식은 없을지 몰라도 여러 분야에 대한 지식을 두루 갖추고 있다. 그래서 한쪽으로 치우치지 않고 종합적으로 사고한다. 바로 리더같은 사람들처럼 말이다. 제너럴리스트의 반대는 스페셜리스트(specialist)다. 스페셜리스트는 전문가를 의미한다. 한 가지 분야에 깊은 지식과 경험을 가지고 있는 사람이다. 교수나, 운동선수, 의사 등이 스페셜리스트에 속한다.&lt;/p&gt;
&lt;p&gt;그렇다면 제너럴리스트와 스페셜리스트 중 어느 집단이 더 뛰어날까? 리더가 제너럴리스트인 경우가 많다고 해서 반드시 제너럴리스트가 뛰어나다고 말할 수 없다. 예를들어 전기공사가 필요하다면 두루두루 알고 있는 제너럴리스트보다는 전기 분야에 전문가인 스페셜리스트가 적합하다. 또는 생사가 걸린 환자가 있다면, 환자의 병에 특화된 전문의(스페셜리스트)가 수술하는게 바람직하다. 즉, 제너럴리스트와 스페셜리스트 중 어느 집단이 더 뛰어나다는 것은 어불성설이다. 단지 맡은 업무의 종류와 성격에 따라 적합한 집단이 다를뿐이다.&lt;/p&gt;
&lt;p&gt;나는 제너럴리스트를 지향한다. 내가 리더에 맞는 사람이라서 그런건 아니다. 이는 내 성격과 관련있다. 우선 나는 한 분야에 몰입하기가 힘들다. 끈기가 없어서일수도 있지만, 호기심이 많아서 그렇다고 볼 수도 있다. 하나에 빠져있다가도 어느새 다른쪽에 관심을 기울인다. 대학에서 건축을 공부하고 실무에서 일하다가 서른이 되어서 프로그래밍에 빠진것도 비슷한 맥락이다. 한가지 아쉬운점은 너무 쉽게 관심사가 바뀌는 것이다. 다양한 분야에 폭넓은 지식을 가지기 위해서는 최소한의 시간은 투자해야한다. 흔히 말하는 &lt;code class=&quot;language-text&quot;&gt;1만시간의 법칙&lt;/code&gt; 처럼 1 만 시간(하루 3 시간이면 거의 10 년)을 투자하지 않더라도 최소 3 년 정도는 꾸준할 필요가 있다. 영어공부를 해야겠다하면 꾸준하게 3 년 이상 해야 할 것이고, 글쓰기를 한다면 일주일에 최소 몇개 이상 3 년은 써봐야 글쓰는 실력도 좋아질 것이다.&lt;/p&gt;
&lt;p&gt;또 한가지는 내 삶의 방향과 관계 있다. 건축할때도 마찬가지고 프로그래머로 살고 있는 지금도 마찬가지인데, 이 분야에 전문가가 되어 평생 살고 싶다는 생각이 없다. 나만의 일을 갖고 싶고 나만의 회사를 만들고 싶다. 대기업같은 회사를 만들겠다는건 아니다. 일하고 싶을때 일하고, 일할 수 있는 나이까지 일하고, 쉬고 싶을때 쉴수 있는 일을 하고 싶다. 굳이 말하자면 1 인 기업에 가까운 형태다. 그런데 1 인 기업을 운영하기 위해서는 스페셜리스트로는 무리가 있다. 일의 성격에 따라 다르겠지만, 경영에서 부터 회계 및 운영 전반을 혼자서 책임져야한다. 그렇기 때문에 다양한 분야의 지식을 쌓는것은 필수다.&lt;/p&gt;
&lt;p&gt;나는 회사에 고용되어 하루에 8 시간씩 매여있기 싫다. 우리가 회사에 고용되어서 받는 혜택도 많이 있지만, 반대로 회사에 고용되었기 때문에 포기해야하는 일도 많다. 예를 들면 몸이 좀 안좋아도 마음대로 쉴수 없는 것이나, 아이와 맘껏 놀아주지 못하는것 등이 있다. 결정적으로 회사는 이익을 추구하는 집단이기 때문에 내 미래를 절대 보장해주지 않는다.&lt;/p&gt;
&lt;p&gt;나만의 일을 만들자.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[나는 왜 산만할까?]]></title><description><![CDATA[…]]></description><link>https://blueshw.github.io/2018/07/17/why_am_i_distracted/</link><guid isPermaLink="false">https://blueshw.github.io/2018/07/17/why_am_i_distracted/</guid><pubDate>Tue, 17 Jul 2018 00:48:01 GMT</pubDate><content:encoded>&lt;p&gt;‘주위가 산만함’. 초등학교(당시에는 국민학교)시절 내 성적표 한켠에 적혀져 있던 담임 선생님의 평가다. 내가 말썽꾸러기였기 때문에 선생님이 그렇게 쓴건 아니다. 주위가 산만하다는 평가를 제외하면 성적표에는 항상 수와 우로 가득차 있었기 때문이다. 그렇다. 나는 정말 산만한 아이였던 것이다. 선생님이 아무리 좋게 보려고 해도 지나치게 산만했기 때문에 어쩔 수 없이 그런 평가를 내린게 틀림없다. 산만함을 호기심이 많다는 걸로 포장해볼수도 있다. 하지만, 성인이 되어서도 한 가지에 집중을 못하는걸 보면 산만하다는 선생님의 평가는 정확한것 같다.&lt;/p&gt;
&lt;p&gt;나는 한가지에 빠져 있다가도 금세 다른데로 눈을 돌린다. 건축에 빠져있다가 어느새 사업에 관심을 두기도 하고, 얼마 못가 컴퓨터와 모바일에 열을 쏟았다. 또다시 사업에 관심을 두는가 싶더니 글쓰기에 몰두한다. 이렇게 다양한 것에 관심을 두는게 나쁜건 아니다. 한가지 분야만 깊이파는 전문가(스페셜리스트)도 있지만, 다양한 분야에 관심을 가지는 사람(제너럴리스트)도 있기 마련이다. 다만, 한가지 분야에 어느정도 성과를 거둔 다음 다른데로 눈을 돌려야 하는데 그러지 못하는게 문제다. 그렇다보니 지금까지 살면서 내세울만한 것 하나 이루지 못했다.&lt;/p&gt;
&lt;p&gt;왜 나는 산만할까? 누가 딱 집어서 알려주면 좋겠지만, 나보다 나 자신을 잘 아는 사람은 없다. 누가 대신 나에 대해 말해준다 해서 쉽게 받아들이긴 힘들다. 그보다는 스스로 돌이켜보면서 자신을 반성하는 시간을 갖는게 훨씬 낫다. 그렇다면, 왜 나는 산만할까? 나를 산만하다고 생각한 이유는 다음과 같다. 첫째, 겁이 많다. 겁이 많은거랑 산만한게 무슨 관계가 있을까? 나는 겁이 많아서 뭔가를 시작할때 지나치게 많이 생각한다. 특히 안되는 이유를 많이 찾아낸다. 그러다가 결국, 이런저런 이유를 들어 중도에 포기해버린다. 한 분야에 대해서 어느정도 식견을 가지기 위해서는 일정 시간 이상을 투자해야 하는 법이다. 그런데 나는 그 최소한의 시간도 버티지 못하고 쉽게 포기해버려 아무것도 남는게 없다.&lt;/p&gt;
&lt;p&gt;내가 산만한 두번째 이유는 팔랑귀이기 때문이다. 나는 고집이 쎄고 주장이 강한 편인데 팔랑귀라니? 일반적인 의미의 팔랑귀와는 조금 다르다. 주변 사람들이 하는 말에는 그다지 휘둘리는 편은 아니지만, 많은 사람들에게 인기있고(베스트셀러 작가라든지) 존경받는 사람의 말과 행동에는 쉽게 흔들린다. 예를 들어 우리의 인생은 장기적으로 1 인 기업가 형태로 진화해야 살아남을 수 있다고 말하는 책을 읽으면, 나도 1 인 기업가가 되야겠다고 다짐한다. 또는 인생을 바꾸기 위해서는 매일 쓰는 습관을 들여야 한다는 말을 들으면 곧장 새 블로그를 만드는 일에 착수한다.&lt;/p&gt;
&lt;p&gt;산만함이 나쁜것만은 아니다. 처음에도 잠깐 언급했지만, 산만함은 호기심의 부정적 표현이다. 호기심이란 다양한 분야에 관심을 두고 여러가지를 경험해 보는 것이라 할 수 있는데, 이는 관점을 넓힐 수 있는 아주 훌륭한 방법이다. 하지만 몰입과 끈기가 부족하다면 호기심은 단순히 산만함으로 끝나버린다. 한 가지 분야에 어느정도 성과를 거두기 위해서는 최소한 3 년은 꾸준히 실행해봐야 한다고 생각한다. 최근에는 내 산만함을 극복하기 위해 몇가지를 시도하고 있다. 첫째로는 1 년이 넘은 매일 아침 영어듣기다. 출근시간에만 듣고 있지만, 1 년 넘게 꾸준히 하는건 누구에게나 쉽지 않다. 아직 별다른 성과는 없지만 계속해서 꾸준히 할 생각이다. 두번째는 글쓰기다. 지금 쓰고 있는 이 블로그는 만든지 얼마 안됐다. 고작해야 4 주 정도 되었고 20 개 가량 글을 썼다. 처음 블로그를 시작할때 일주일에 4~5 개씩 최소 3 년간 꾸준히 쓰기를 목표로 정했다. 아직은 시작한지 얼마 안되서 뭐라 평가하긴 어렵지만, 영어듣기를 꾸준히 하고 있듯이 글쓰기도 꾸준히 할 수 있도록 노력해야겠다.&lt;/p&gt;
&lt;p&gt;30 년 넘게 이어져온 개인의 성향을 바꾸는건 무척 어려운 일이다. 그래서 나는 산만함을 바꾸려고 생각하지는 않는다. 대신 지금까지 부정적인 영향을 주던 내 산만함을 긍적적인 영향을 주는 산만함으로 개선하고 싶다. 그러기 위해선 지금 하고 있는 영어듣기와 글쓰기를 꾸준히 해서 어느정도 성과를 얻어야 한다. 3 년 후에 내가 다시 이 글을 본다면, 그때는 과거의 3 년에 대해 스스로 만족할 수 있었으면 좋겠다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[역사서를 위한 패키지 여행 <역사의 역사>]]></title><description><![CDATA[…]]></description><link>https://blueshw.github.io/2018/07/16/history_of_history/</link><guid isPermaLink="false">https://blueshw.github.io/2018/07/16/history_of_history/</guid><pubDate>Mon, 16 Jul 2018 01:06:16 GMT</pubDate><content:encoded>&lt;p&gt;유시민의 책을 읽는 빈도가 잦아졌다. 그의 책을 읽다보면 유시민이라는 사람의 폭넓은 지식과 다양한 관심분야와 간결한 문체에 반하게 된다. 문장을 간결하게 쓰다보니 아무리 어려운 주제의 책이라도 어렵지 않게 읽힌다.&lt;/p&gt;
&lt;p&gt;유시민의 최신작, &amp;#x3C;역사의 역사&gt;는 역사라는 쉽지 않은 주제를 다룬다. 최초의 역사가라고 불리는 헤르도토스부터 책 사피엔스로 유명세를 타고 있는 유발 하라리까지 다양한 역사가의 시각을 통해 역사가 무엇이고 어떻게 기술되어 왔는지 설명한다. 역사는 사실을 기록한다는 의미를 가지만 사실상 모든 역사를 기록하기란 불가능하다. 과거에 어떤 사건이 발생했을때, 그 사건이 발생한 원인과 사건의 경과 그리고 사건 이후의 영향을 상세히 기록했다면 더할나위 없다. 하지만, 어떤 사건은 단 한줄만 남아있는 경우도 있다. 그래서 역사적 사건 사이에는 공백이 존재할 수밖에 없다. 이때 역사가는 이 공백을 자신의 상상력으로 메꾼다. 이 부분이 매우 중요하다. 역사가가 그 공백을 어떤식으로 기록했냐에 따라서 전혀 다른 이야기가 탄생할 수도 있다. 만약, 역사가가 보수적이고 민족주의 성향이라면 자기 민족에게 유리하게 이야기를 풀어나갈 것이다. 일본의 보수성향 역사가들은 제국 일본의 만행을 부정하고 그때의 정치인들을 영웅으로 그리는것 처럼 말이다.&lt;/p&gt;
&lt;p&gt;10 여년쯤 전에 에드워드 카의 &amp;#x3C;역사란 무엇인가?&gt;를 읽었던게 기억난다. 특별히 역사에 관심이 있어서 읽었던건 아니다. 다만 그 당시에는 유명하다는 책은 닥치는대로 읽다보니 우연히 &amp;#x3C;역사란 무엇인가?&gt;를 읽게 되었다. 에드워드 카가 사람이 어떤 사람인지 알아볼 생각도 없었고, 그가 쓴 역사서가 어떤 관점으로 쓰여졌는지 전혀 관심없었다. 그러다보니 다 읽은 뒤에도 기억나는게 전혀 없었다. &amp;#x3C;역사의 역사&gt;에서는 &amp;#x3C;역사란 무엇인가?&gt;를 역사 이론서로 규정한다. 이론서다 보니 읽기 편한 재밌는 이야기가 있는 것도 아니다. 그리고 방대한 양을 압축된 문장으로 표현한다. 그렇다보니 유럽의 역사와 철학자에 대해 제대로 아는 사람만이 수월하게 읽을수 있다. 내가 아무것도 기억 못하는게 어찌보면 당연하다. 나는 유럽의 역사에 대해서 단편적인 사실만 알고 있고, 유럽의 철학자도 이름정도만 아는 사람이 대다수다. 이렇게 사전 지식 없는 내가 &amp;#x3C;역사란 무엇인가?&gt;를 읽는다고 어떤 통찰을 얻는것은 불가능에 가깝다.&lt;/p&gt;
&lt;p&gt;이 책을 한마디로 평가하자면 ‘역사서를 제대로 읽기 위한 입문서’ 정도가 되겠다. &amp;#x3C;역사의 역사&gt;는 역사에 대해 공부하고 싶은데, 도대체 어떤 역사가의 책을 읽으면 좋을지 고민하는 사람에게 강력히 추천한다. 유시민은 마치 해외 패키지 여행의 가이드처럼 각 역사서의 배경과 책을 쓴 역사가의 관점을 간략히 설명해준다. 우리는 가이드의 설명을 듣고 원하는 역사서를 선택할 수 있다. 재미있는 역사 이야기를 읽기 원하거나 역사를 연대기 순으로 알고 싶거나, 또는 역사 이론이 궁금한 사람이라면 &amp;#x3C;역사의 역사&gt;가 그 해답을 줄 수 있을 것이다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[아이의 성장, 도전과 응전의 역사]]></title><description><![CDATA[날씨가 너무 덥다. 한낮의 기온이 35 도에 육박하고 밤에도 2…]]></description><link>https://blueshw.github.io/2018/07/15/growth_child/</link><guid isPermaLink="false">https://blueshw.github.io/2018/07/15/growth_child/</guid><pubDate>Sun, 15 Jul 2018 01:11:54 GMT</pubDate><content:encoded>&lt;p&gt;날씨가 너무 덥다. 한낮의 기온이 35 도에 육박하고 밤에도 25 도 이상의 열대야가 지속되고 있다. 집에서는 더위를 이겨내기 너무 힘들어(이동식 에어컨으로 감당이 안된다) 에어컨이 빵빵한 장소들을 골라 순례하기로 했다. 점심을 먹고 카페에 들렸다가 아이가 너무 심심해하는것 같아 자주 가던 키즈카페로 향했다. 한시간쯤 지났을까, 7 살 정도로 되어 보이는 몇몇 아이들이 이렇게 얘기하는게 들렸다.&lt;/p&gt;
&lt;p&gt;“쟤 쫓아온다. 도망가자.”&lt;/p&gt;
&lt;p&gt;첨에는 애들끼리 노는가보다라 생각하고 대수롭지 않게 넘겼다. 그런데 몇번 반복되다 보니 조금 이상한 느낌이 들었다. 자세히 보니 우리 딸이 언니들이랑 놀고 싶어 쫓아가고 있었고 언니로 추정되는(6~7 살쯤 되어보이는) 아이들은 우리딸에게서 도망가고 있었따. 그리고는 ‘쟤 쫓아온다’고 말하면서 도망가는 짓(나쁜 행동이니 ‘짓’이라 하겠다)을 반복하고 있었다. 심지어는 주변 아이들에게 쟤 쫓아오니깐 도망가야 된다면서 여론을 조성하고 있었다. 그렇다. 우리딸이 왕따를 당하고 있었다. 왕따는 학교나가야 있는줄 알았는데, 이렇게 어린 아이들 세계에서도 쉽게 나타날 수 있다는것을 보고 적지않은 충격을 받았다. 나중에는 그 언니들이 우리아이를 트램폴린에서 일부러 넘어뜨리기까지 했다. 이건 좀 아니다 싶었다. 예닐곱살밖에 되지 않은 아이들이 자기보다 훨씬 어린 친구를 악의적으로 왕따시키고 괴롭히고 있다는 사실에 화가 치밀어 올랐다. 당장이라도 아이를 잡고 혼내고 부모를 찾아가 따지고 싶었다. 하지만, 지금 따졌다가는 감정이 폭발해 싸움이 날것 같았다. 가까스로 참고 아이를 데리고 나왔다.&lt;/p&gt;
&lt;p&gt;감정을 추스르고 생각해보았다. 이럴때 어떻게 대처해야하지? 그 아이들을 혼내면 끝나는건가? 그 아이들을 혼내면, 내 기분이 조금 풀릴지도 모르겠다. 하지만, 이는 적절한 대응책이 아니다. 이미 우리 아이는 마음의 상처를 받았다. 내가 정말 우리 아이를 생각한다면 외부의 압력(도전)을 제거하는데 집중할게 아니라 아이가 이 상황을 어떻게 받아들일지를 생각해야한다. 아이가 아직 어리고 감정적이기 때문에(4 살) 스스로 극복하기란 쉽지 않다. 부모는 아이가 이 사건을 잘 받아들이도록 설명해줘야 한다. 또한 다시 그런 일이 발생했을 때 적절하게 대응할 수 있는 방법을 알려줘야 한다. 그게 부모의 역할이다.&lt;/p&gt;
&lt;p&gt;요즘 읽고있는 유시민의 신작 &amp;#x3C;역사의 역사&gt;에는 역사가 아놀드 토인비가 나온다. 토인비는 ‘도전과 응전의 역사’라는 이론을 바탕으로 &amp;#x3C;역사의 연구&gt;라는 책을 썼다. 간단히 설명하자면 문명의 탄생과 쇠락, 발전은 내외적인 도전과 그에 대한 응전에 따라 결정된다는 것이다. 예를 들어 고대 이집트 문명이 나타나기 전, 현재 사하라 사막은 지금의 지중해나 유럽의 기후와 비슷했다. 사계절이 있고 일정한 시기에 비가 내리는 등 사람이 살기에 적합한 곳이었다. 그래서 북아프리카 지역에는 수렵생활을 하던 많은 인류가 살고 있었다. 시간이 흘러 유럽의 빙하지역이 점점 축소됨에 따라 북아프리카 지역이 건조화 되기 시작했다. 기후라는 외부의 도전이 발생한것이다. 이 때 사람들은 세가지 방법 중 하나를 선택해야했다. 변화된 기후에 별다른 대응없이 근근히 수렵생활을 이어가거나, 건조화된 땅을 떠나 북으로 이동하거나, 또는 응전하여 건조화된 기후에 맞도록 삶의 방식(농경 등)을 변경시켜야 했다. 환경의 변화라는 외부의 도전에 각자 자신들이 선택한 방법으로 응전했고, 마지막 방식으로 도전을 이겨낸 인류가 이집트 문명을 만들어냈다.&lt;/p&gt;
&lt;p&gt;문명의 흥망을 ‘도전과 응전의 역사’로 설명했듯이 한 아이의 성장도 도전과 응전으로 설명할 수 있다. 아이는 커가면서 많은 시련(도전)을 겪는다. 예를들어 먹고싶은게 있는데 엄마가 못먹게 하는 상황이 있다. 아이들에게는 이게 시련이다. 이때 아이들은 자신이 원하는걸 얻기 위해서 다양한 방법을 선택한다. 울면서 떼쓰는 아이도 있고, 엄마와 타협을 하고 나중에 먹기로 한다. 또는 모든걸 사주는 아빠에게 달려가 얘기할 수도 있다. 다양한 방식의 해법(응전)이 있고 그에 따라 먹고 싶은걸 얻기도 하고 그렇지 못하기도 한다. 이런게 무슨 성장이냐고 말할지도 모르겠다. 하지만, 아이는 어떤 시련에 대해 스스로 각자의 응전 방법을 생각하고 행동한다. 이런 응전의 방법이 쌓이고 쌓이다보면, 인생에서 정말 필요한 순간에 큰 힘이 될 수 있다.&lt;/p&gt;
&lt;p&gt;다시 우리 아이의 상황을 보자. 키즈카페에서 언니들로 인해 따돌림을 당했다. 외적인 시련이 발생했다. 엄마에게 달려와 언니들이 안놀아준다고 얘기할수도 있다. 아니면 언니들에게 ‘하지마!’라고 강하게 어필할 수도 있다. 또 다른 방법들로는 울거나, 무시하는 방법이 있다. 4 살배기 아이들은 아직 생각이 미숙하다. 그래서 감정적이다. 언니들의 왕따는 무지 슬프다. 그래서 토라지거나 엄마에게 달려와 우는게 고작이다. 돌아오는 차안에서 나는 아이에게 몇가지 조언을 해줬다. 우선, 언니들이 안놀아 주면 따라다니지 말라고 말했다. 괜히 귀찮게 만들어 괴롭히는 빌미를 제공할수도 있기 때문이다. 그리고 언니나 오빠들이 따돌리고 괴롭히면 큰 소리로 이렇게 얘기하라고 말했다.&lt;/p&gt;
&lt;p&gt;“하지마!!!”&lt;/p&gt;
&lt;p&gt;내가 잘 가르쳐준걸까? 내가 아이의 입장에서 생각해본 응전이 적절했을까? 만약 아이가 다른 상황에서 내가 말한대로 했을때 앞으로 어떤 일이 벌어질까? 더 괴롭힘 당하는건 아닐까? 조금 걱정이 돼서 다시 말했다. 엄마랑 아빠 있을때만 그렇게 말하라고… 내가 생각할때 어떠한 종류의 괴롭힘도 강한 저항 앞에서는 약해지기 마련이다. 나보다 상대가 약해보이면 괴롭힌다. 상대는 나보다 약하기 때문에 내가 괴롭혀도 저항하지 않을꺼라 믿고 행동한다. 하지만, 상대가 예상치못하게 강하게 저항하면 움츠러들기 마련이다. 그래서 나는 아이에게 강하게 말하라고 조언했던 것이다. 그래도 불안하다. 내 아이의 일이라서 더 그런가보다. 그런데 만약, 아이가 너무 걱정되고 안타까워서 그 아이를 대신 혼내주고 아이의 부모와 싸웠다면 우리 아이는 이렇게 생각할 수 있다. 어떤 일이든 엄마가 다 해결해줄 수 있다고. 그래서 자기 스스로 해결책을 찾기보다 시련이 발생할 때마다 계속해서 엄마에게 의존할지도 모른다. 아이는 크면서 겪게되는 시련을 스스로 해결할 수 있는 방법을 찾아야 한다.&lt;/p&gt;
&lt;p&gt;사람은 살면서 계속 시련에 부딪힌다. 시험에 떨어질수도 있고, 친했던 아이와 싸워서 서로 모른척할 수도 있다. 또는 남자친구가 바람이나 헤어질수도 있다. 대기업 면접에 수십번 떨어질수도 있고, 겨우 회사에 들어가더라도 또라이 상사때문에 고생할 수도 있다. 그 때마다 아이는 자신이 생각한 적절한 방법을 선택한다. 시험을 또 볼수도 있고, 친구에게 먼저 사과할수도 있다. 바람핀 남자지만 매달릴수도 있고 과감히 버릴수도 있다. 대기업 면접에 떨어져 중소기업을 선택할수도 있고 회사의 또라이 상사때문에 회사를 때려칠수도 있다. 이렇게 한 사람의 시련은 계속해서 찾아온다. 그럴때마다 스스로를 잘 다스리기 위해서는 적절한 응전이 필요하다. 잘못된 방법을 선택하면 몸과 마음이 힘들어져 정상적인 생활을 하지 못할수도 있다. 외롭고 고독한 삶을 살수도 있고 우울증에 걸려 약에 의존해야 할 수도 있다. 심하게는 자살도 생각할지도 모른다. 문명의 흥망이 문명 내외부에서 발생하는 도전과 그에 대한 적절한 응전으로 결정되듯이, 개인 한 사람에게도 외부의 시련(도전)에 적절한 방법(응전)을 찾는것이 중요하다. 그래야만 성장할 수 있고, 제대로된 삶을 영위할 수 있을 것이다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[자신을 잃어버리지 말자]]></title><description><![CDATA[…]]></description><link>https://blueshw.github.io/2018/07/11/do_not_loose_myself/</link><guid isPermaLink="false">https://blueshw.github.io/2018/07/11/do_not_loose_myself/</guid><pubDate>Wed, 11 Jul 2018 23:54:24 GMT</pubDate><content:encoded>&lt;p&gt;나는 자기애가 강한편이다. 아니, 강한편이라 생각했다. 그래서 나는 변하지 않으리라 생각했다. 결혼을하고 아이를 낳아도 내 자아는 그대로 유지될꺼라 굳게 믿었다. 우리 부모세대 처럼 자식만 바라보며 살고 싶지는 않았다. 우리 부모들은 자식의 일이라면 어떤 일도 마다하지 않았다. 주말이 없는 삶도 마다하지 않았고, 매일같이 밤늦은 퇴근도 마다하지 않았다. 자식이 원하는게 있으면 어려운 형편에도 뭐든지 사주려했고, 자신이 입는 옷은 낡아서 구멍이 날때까지 새옷을 사는 법이 없었다. 모두 자식의 성공과 행복을 위해 자신을 희생한다는 마음이 있기에 가능한 일이었다.&lt;/p&gt;
&lt;p&gt;그런 내가 부모가 되었다. 결혼을 했고 아이를 가질 때가 되어 아이를 낳았다. 너무나 사랑스러운 아이가 태어났다. 눈은 나를 닮았고 코는 아내를 닮았다. 머리가 조금 큰게 나를 닮은것 같아 안타까웠지만, 그래도 너무 사랑스러웠다. 너무나 사랑스러웠기 때문에 뭐든지 해주고 싶었다. 음식을 사도 아이가 먹을꺼니까 더 비싼 유기농을 사고, 입는 옷도 비싸더라도 순면으로 된 옷을 사줬다. 아이가 크는 모습을 보는 것 만으로도 더할나위 없이 행복했다. 크게 아프지 않아서 너무 감사했다. 가끔 아이가 아플때면 어떻게 될까 싶어 밤새 간호하기도 했다.&lt;/p&gt;
&lt;p&gt;아이가 점점 커가면서 자아가 생기기 시작했다. 고집을 부리기 시작했고, 기호도 생겼다. 대화가 가능해지니 갓난아기 시절과는 또 다른 재미가 생겼다. 단어를 가르치고 같이 놀아주고 노래를 불러주었다. 놀아주고 선물을 사주고 좋아하는 음식을 사줬을때 아이는 기뻐하고 나를 안아줬다. 아무리 힘들어도 아이의 포옹 하나면 그날의 피로는 씻은듯 사라졌다. 그렇게 정신없이 아이를 키우면서 몇년이 지났고 문득 이런 생각이 들었다.&lt;/p&gt;
&lt;p&gt;‘내가 변한건가?’&lt;/p&gt;
&lt;p&gt;결혼하고 아이를 낳고 아이를 키우다 보니 내가 변한것 같다는 생각이 들었다. 나를 사랑하고 신념이 확고했던 철없는 20 대의 내가 사라진것 같았다. 뭘해도 아이를 기준으로 생각하고 행동했다. 패션감각도 내려놓았다. 패피 정도는 아니었지만, 늘 패션감각이 떨어지지 않도록 아침마다 입을 옷을 신경썼고 옷도 많이 샀다. 그런데 어느 순간부터 옷을 사지 않는다. 옷장에 아이의 옷은 늘어만가는데, 내 옷은 점점 줄어간다. 집도 거의다 아이의 성장에 맞춰졌다. 카페 같은 거실도 포기한지 오래다. 아이가 다치지 않도록 모서리가 둥근 가구로 바꿨고 온 집안은 아이의 장난감으로 넘친다. 정해진 수입으로 지출을 나누다보니 나를 위한 소비는 점점 줄어간다. 커피 한잔 사먹는 것도 아깝고 술 한잔 마시는것도 꺼려진다. 그렇지만 아이를 위한 지출에는 전혀 망설임이 없다.&lt;/p&gt;
&lt;p&gt;이대로 괜찮은걸까? 모든것을 아이의 인생에 맞춰도 괜찮은걸까? 그렇게 나를 사랑하고 확고했던 신념이 이대로 사라져도 상관없을까? 무서운 생각이 든다. 점점 우리 부모 세대처럼 변하는 느낌이다. 어차피 한번뿐인 인생, 내가 없는 삶은 살고 싶지않다. 여행도 포기하기 싫고, 패션감각도 포기하기 싫다. 아이의 뒷바라지를 위한 일이 아니라 정말 내가 원하는 일을 하며 살고 싶다. 자신을 잃어버리 말아야한다. 아이는 크면 언젠가는 내 품을 떠난다. 그렇기 때문에 아이를 키우는 것만큼이나 내 인생도 중요하다. 내가 불행한데 어떻게 아이만 행복할 수 있을까? 아이도 커가면서 자신을 잃어버린 부모보다는 자신의 삶을 확고히 살아가는 부모에게 더 많은것을 배운다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[왜 회사에서 반드시 일주일에 5일동안 하루 8시간씩 근무해야할까?]]></title><description><![CDATA[아주 작은 소규모의 벤처나 소상공인 또는 악덕 회사가 아니라면 우리는 보통 일주일에 5 일 일하고 하루에 8 시간 근무한다. 합하면 주당 40 시간이다. 여기서 주당 40 시간은 연장근무없는 통상적인 근로시간만을 뜻한다. 최근 시행되는 ‘주 5…]]></description><link>https://blueshw.github.io/2018/07/10/why_work_during_40_hours/</link><guid isPermaLink="false">https://blueshw.github.io/2018/07/10/why_work_during_40_hours/</guid><pubDate>Tue, 10 Jul 2018 01:15:45 GMT</pubDate><content:encoded>&lt;p&gt;아주 작은 소규모의 벤처나 소상공인 또는 악덕 회사가 아니라면 우리는 보통 일주일에 5 일 일하고 하루에 8 시간 근무한다. 합하면 주당 40 시간이다. 여기서 주당 40 시간은 연장근무없는 통상적인 근로시간만을 뜻한다. 최근 시행되는 ‘주 52 시간 근무제’와 헷갈릴수 있는데, 이는 통상적인 40 시간에 연장근로를 합쳤을때 52 시간이 넘으면 안됨을 뜻한다. 주 52 시간이 얼마나 지켜질지는 의문이다. 하지만, 대기업에서 앞다투어 시행하는것 보면 조만간 자리잡을 수 있을꺼 같다. 주 5 일 근무를 처음 시행할때도 얼마나 많은 말들이 나왔었는지 생각해보면, 주 52 시간 근무제도 금방 자리잡을 것이다.&lt;/p&gt;
&lt;p&gt;요즘은 최근 몇달에 비해 조금 덜 바쁘다. 앞선 두 세달은 눈코뜰새 없이 바빴다. 급한일들은 거의 마무리되었고 조금은 여유가 생겼다. 바쁘다가 갑자기 여유가 생겨서 그런지 몰라도 요즘은 출근하는게 조금 힘들다. 진짜 바쁠때는 출근이 힘들다 느낀적이 전혀 없다. 당시에는 처리해야할 일에 온갖 정신이 빼앗겨 있었기 때문에 잠들기 전까지 내일 할 일만 생각할 때도 있었다. 그렇게 바쁘다 조금 여유로워 졌을 뿐인데 출근이 힘들어지다니, 인간이란 참 환경에 쉽게 변하는 생물이다.&lt;/p&gt;
&lt;p&gt;업종에 따라 다르겠지만, 회사일은 시기에 따라 강약이 존재한다. 재무와 관련된 일을 하는 사람에게는 연초와 연말이 가장 바쁘다. 프로젝트 단위로 일을 하는 사람은 프로젝트 마감이 가까워질수록 점점 바빠진다. 그런데 왜 근무시간은 40 시간 / 52 시간으로 고정되어 있을까? 일에는 강약에 있는데 왜 하루에 8 시간, 일주일에 40 시간 / 52 시간동안 일해야만 할까? 일주일에 몇시간을 해야한다는 규정은 제조업에나 적합하다. 제조업의 생산성은 시간에 비례하기 때문이다. 하지만, 제조업이 아닌 창의적인 일을 하는 사람에게는 하루 또는 일주일 단위로 시간을 정하는 방식은 적합하지 않다. 창의적인 일의 생산성은 시간에 비례하지 않기 때문이다. 일주일에 100 시간을 일하더라도 일에 진척이 없을 수도 있고 10 시간만 일하더라도 충분한 결과물을 얻을 수도 있다. 일을 하는 시간은 일의 종류에 따라서 다르게 책정되어야 한다. 제조업에 가까울수록 시간을 정해놓는 편이 나을테고, 창의적인 일일수록 시간에 얽매이지 않도록 해야할 필요가 있다. 물론 규정을 만드는 입장에서 일을 종류에 따라 세분화하고 각각에 맞는 규정을 별도로 만들기는 사실상 불가능하다.&lt;/p&gt;
&lt;p&gt;현재 대부분의 노동자들은 회사라는 시스템에 속한 채로 일한다. 회사라는 형태는 생각보다 오래전에 만들어졌다. 초기의 회사는 대부분 제조업 중심이었고, 제조업의 생산성은 위에서 언급했듯이 시간에 비례한다. 그래서 과거의 회사들은 노동자에게 정해진 시간동안 일을 하도록 요구하였다. 시간이 흘러 일의 형태가 다양화되고 세분화되었다. 하지마, 여전히 우리는 과거의 근무 시스템에 맞춰 일하고 있다. 물론 처음보다는 일의 절대량은 많이 줄었다. 때문에 근무환경은 훨씬 개선되었고 여가시간도 많이 늘었다. 하지만, 일의 절대량이 아닌 근무형태로 보면 과거나 지금이나 별반 다르지 않다. 현대의 일은 과거 제조업과는 다르게 창의적인 일이 많다. 그렇기 때문에 과거의 근무 시스템과 맞지 않는 경우가 더러 있다. 일이 바쁠때는 더 많은 시간을 일해야하는게 당연하다. 반대로 일이 없을때는 일하는 시간을 줄이는게 맞다. 지금처럼 일의 강약과 상관없이 하루 몇시간 또는 주당 몇시간 근무로 정해지면, 어느순간 요즘의 나처럼 출근하는게 고역이 된다. 회사에 나가도 크게 할일은 없는데 출근해서 근무시간은 반드시 채워야 하기 때문이다.&lt;/p&gt;
&lt;p&gt;한가지 엉뚱한 제안을 해보겠다. 세부적인 계획은 전혀 없지만, 월간 근로시간을 도입하면 어떨까 생각해본다. 우선 한달(또는 프로젝트 단위)동안 해야할 일을 미리 정한다. 정해진 일은 기간 안에 일을 완수하는것을 목표로 한다. 근무시간은 한달동안 최소 100~150 시간 정도로 책정한다(현행보다 적다). 회사는 근로자가 하루에 몇시간을 일하든 전혀 관여하지 않는다. 다만 각 직원은 반드시 해야하는 일(예를들어 미팅같은)에는 의무를 다해야한다. 반면에 혼자만 일하는 시간은 본인 스스로 정할수 있도록 한다. 주말이 될 수도 있고 늦은 밤이 될수도 있다. 또는 극단적으로 2 주는 쉬고 2 주만 일할 수도 있겠다. 2 주동안 휴가를 다녀온 뒤 남은 2 주는 휴일 없이 하루 10 시간 정도 근무하면 대략적인 근무시간은 충족할 수 있다. 얼마나 멋진가?&lt;/p&gt;</content:encoded></item><item><title><![CDATA[단문과 복문 <유시민의 글쓰기 특강>]]></title><description><![CDATA[<유시민의 글쓰기 특강>, 내가 처음 완독한 유시민 작가님(앞으로 존칭은 생략한다)의 책이다. 1…]]></description><link>https://blueshw.github.io/2018/07/09/single_or_double_sentences/</link><guid isPermaLink="false">https://blueshw.github.io/2018/07/09/single_or_double_sentences/</guid><pubDate>Mon, 09 Jul 2018 00:10:37 GMT</pubDate><content:encoded>&lt;p&gt;&amp;#x3C;유시민의 글쓰기 특강&gt;, 내가 처음 완독한 유시민 작가님(앞으로 존칭은 생략한다)의 책이다. 15 년 정도 전에 발간된 &amp;#x3C;경제학 카페&gt;를 읽으려고 시도한적은 있었다. 왜 그랬는지 이유는 잘 기억나지 않지만, 앞 부분만 조금 읽고 그대로 덮어버렸다. 그래서 어떤 책이었는지 전혀 기억나지 않는다. 내 기억에 15 년 전에는 유시민에 대해 잘 몰랐다. 정치에 관심도 크게 없었기 때문에 이름만 알고 있는 수준이었다. 15 년이 지난 지금도 여전히 정치에 별 관심이 없다. &amp;#x3C;유시민의 글쓰기 특강&gt;을 선택한 계기는 별게 없다. 글쓰기에 대한 책이 뭐가 대단할까 싶어 보통은 안읽었는데(괜찮은 글쓰기 책은 몇권 읽어보길 추천한다), 그저 요즘 잘나가는 유시민(정치할 때보다 훨씬 나아보인다)이라서 선택했다. 지금 생각해보면 정말 탁월한 선택이었다.&lt;/p&gt;
&lt;p&gt;다른 글쓰기 책과 마찬가지로 유시민은 이 책을 통해 글을 잘 쓰기 위한 방법을 여럿 제시한다. 대부분은 다른책과 비슷하다. 꾸준히 써야하고 책을 많이 읽어야 한다는 등 일반적인 방법이다. 일반적인 방법이지만, 작가의 표현력과 구성에 따라 받아들이는 입장에서 더욱 크게 와닿을 수 있다. 예를 들어 단문과 복문에 대해 이렇게 설명한다(대여로 읽은 책이라 내 기억으로 재 구성한다, 참고로 문장에 주어와 서술어가 하나면 단문, 두개 이상씩이면 복문이라 한다).&lt;/p&gt;
&lt;p&gt;단문과 복문을 사용하는것은 노래에 비유할 수 있다. 지나치게 복문을 많이 사용하는 것은 노래 시작부터 끝까지 고음으로만 부르는것과 같다. 고음이 과학적으로 사람에게 큰 울림을 주는 것은 사실이나 처음부터 끝까지 고음만으로 노래를 하면 오히려 감동이 반감된다. K 팝스타에서 고음만으로 노래를 한 참가자에게 박진영이 얘기했다. 노래 자랑하러 나오셨나고… 노래에도 기승전결이 필요하다. 곡 전체가 고음으로 일관된 노래보다는 차분히 시작하면서 서서히 절정에 다다르는 노래가 사람들에게 전율을 느끼게한다. 글쓰기도 마찬가지다. 글 전체에서 복문을 주로 사용하는 것은 고음으로만 노래하는 것과 같다. 그보다는 읽기 쉬운 단문을 주로 사용하면서 자신의 주제를 드러낼때 복문을 사용하면 훨씬 효과적이다. 기승전결이 꼭 내용에만 국한되는지는 않는다. 단문과 복문을 사용할때도 기승전결의 구성이 필요하다.&lt;/p&gt;
&lt;p&gt;(내 기억으로 완전히 각색한) 이 대목에서 나는 지금껏 정말 글을 못쓰는 사람이었다는 사실을 깨달았다. 예전에 쓴 글을 보면 대부분 주어와 서술어가 여러개인 복문으로 도배되어 있었다. 그런 방식으로 쓰는 글을 잘 쓰는 글이라 믿었다. 나름대로는 어색하지 않게 여러번 퇴고하면서 썼다. 하지만, 읽는 이의 입장에서는 한번에 이해하기 어려운 문장 투성이었다. 유시민의 글과 책을 읽어보면 참 쉽게 읽힌다. 결코 쉬운 내용이 아님에도 쉽게 잘 읽히는건 단문을 주로 사용하기 때문이다. 반대로 문장 하나를 이해하기 위해서 여러번 반복해서 읽어야 하는 글도 있다. 이러면 흐름이 방해되어 글 전체에 대한 이해가 떨어진다. 번역서나 연구 서적에서 많이 볼 수 있는 형태다. 이런 글과 책을 쓴 사람들은 글쓰기에 대해 제대로 배운적이 없을 것이다. 그렇지 않고서야 이토록 읽기 어렵게 쓰지는 않았을 것이다. 아니면 많은 사람에게 읽히기 위함이 아니라 지식을 자랑하고 인정받으려고 일부러 어렵게 쓴것이 분명하다.&lt;/p&gt;
&lt;p&gt;이번 블로그를 만든 뒤로는 단문 위주로 글을 쓰려고 노력한다. 사람들이 읽기 쉬운 글을 쓰고 싶기 때문이다. 그렇다고 이 블로그의 목적이 글쓰기 연습이라고 단정지을수는 없다. 앞으로 어떤 주제로 글을 쓰게 될지는 정말 모른다. 주제가 무엇이든 사람들이 쉽게 읽을 수 있으면 좋겠다는게 내 마음이다. 혼자만의 비밀을 간직하기 위함이라면 어떻게 써도 상관없다. 하지만, 사람들과 공유하고 공감하기 위한 글쓰기라면 최소한 읽는 사람의 입장을 헤아려 글을 써야한다. 큰 가르침을 주신 유시민 작가님에 감사드린다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[이케아를 다녀왔습니다.]]></title><description><![CDATA[…]]></description><link>https://blueshw.github.io/2018/07/08/went_ikea/</link><guid isPermaLink="false">https://blueshw.github.io/2018/07/08/went_ikea/</guid><pubDate>Sun, 08 Jul 2018 01:21:40 GMT</pubDate><content:encoded>&lt;p&gt;오랜만에 이케아를 다녀왔다. 다음달 초에 이사하는 아파트에 필요한 가구를 사기 위해서다. 처음 이케아 광명점이 오픈할때만 해도 주차장에 들어가는데 한두시간은 기본으로 기다려야했다(그 때 가보진 않았지만 지인에게 들었다). 오픈한 이후로 처음만큼은 아니지만 주말만 되면 이케아에 들어가려는 차로 도로가 마비되었다. 그나마 최근에 고양점이 생긴 이래로 고객이 분산되면서 조금 나아진 것 같다.&lt;/p&gt;
&lt;p&gt;도로에서 10 여분 기다려 주차하고 매장에 들어섰다. 오후 1 시가 넘은 아직은 이른 시각이라 조금 여유로워 보였다. 그렇다고 한가하지는 않았다. 이케아는 역시 이케아다. 오늘의 목적은 소파와 옷장이다. 이사를 하면서 사고 싶었던 가구를 모두 사면 좋겠지만, 언제 또 이사갈지도 모를 일이라 필요한것만 최소한으로 구매하기로 했다. 그렇게 결정한것이 소파와 옷장이다. 소파 코너에 들어서니 역시 이케아라는 생각이 들었다. 소파 하나만해도 수십가지가 있다. 1 인 소파부터 3 인, 코너형 등 형태도 다양하다. 또 소재나 기능에 따라서 가격도 천차만별이다. 정말 고르기 쉽지 않다.&lt;/p&gt;
&lt;p&gt;이케아가 지금처럼 세계적인 기업이 된 이유가 여러가지 있겠지만, 소비자가 직접 조립한다는 점이 크게 작용했다. 우선 소비자가 직접 조립하면서 인건비가 크게 감소했다. 가구를 운반할 배송기사도 필요없고(지금은 배송 서비스를 하고 있다), 설치기사도 필요없었다. 마트처럼 전시하고 계산하고 청소하는 직원이 대부분이었다. 인건비가 크게 들지 않으니 자연스레 제품의 가격을 낮출 수 있었다. 저렴한 가격과 더불어 특히 남자들에게는 직접 가구를 만든다는것이 하나의 놀이처럼 인식되었다. 가격도 저렴하고 직접 만들어도 볼수 있는 이케아 가구에 전세계 사람들은 열광했고, 세계적인 기업으로 성장할 수 있었다.&lt;/p&gt;
&lt;p&gt;가끔 뉴스에 이런 기사가 나온다. 폐목재로 가구를 만들었다거나, 소파를 쓰레기 솜으로 만들었다는 기사다. 책장, 장농, 침대, 소파 등 대형 가구들은 속까지 잘 안보인다. 양심불량 업체들이 단가를 낮추기 위해 속에 사용하는 재료를 폐목재나 쓰레기 솜을 사용한 것이다. 어떻게 소비자가 모를수 있나 생각되지만, 겉이 멀쩡하고 기능상 문제가 없으니 굳이 속까지 살펴보는 소비자가 거의 없었기 때문에 이런일이 벌어진 것이다.&lt;/p&gt;
&lt;p&gt;과거에는 가구가 무척 고가였다. 결혼할때 남자는 집을사고, 여자는 혼수로 가구와 가전을 샀다. 지금이야 집값이 워낙에 비싸기 때문에 이런 공식이 성립하기 어렵지만(아직도 이렇게 해야된다고 생각하는 사람이 많은것 같다), 과거에는 비용이 비슷할만큼 고가인 가구가 많았다(아마도 거품이 심했을거 같다). 20~30 년 전에도 10 자 장농이 2~3 백만원에 팔린 정도였으니 말 다했다. 그런데 이케아가 팔리기 시작했다. 초기에는 인터넷 직구로 구매했다. 인터넷 직구로 구매해도 국내에서 파는 가구보다 훨씬 저렴하게 구입할 수 있었다. 당연히 사람들은 직구로라도 이케아 가구를 사기 시작했고 점점 그 수가 많아지다보니 국내 가구 업체들은 긴장하기 시작했다. 어쩔수 없이 단가를 낮출수 밖에 없었다. 저렴하고 품질이 나쁘지 않은(좋다고 할수만은 없다, 각성비가 좋을뿐) 이케아를 이기기 힘들었기 때문이다. 결국 가구업체들은 살아남기위해 품질을 높여 고가 전략을 취할지 아니면 단가를 낮출지 둘 중 하나를 선택해야만 했다. 그런데 후자를 선택한 업체들이 단가를 낮추는데는 한계가 있었다. 인건비는 자꾸 올라가는데 단가를 낮추기란 사실상 불가능했던 것이다. 그래서 사람들 눈에 안띄는 부분을 폐목재나 재활용 부품으로 만들어 단가를 낮춘것이다. 겉은 멀쩡했기 때문에 제품을 구매한 소비자들은 알 방법이 없었다. 하지만 시간이 지나고 점차 제품에 문제가 있다는 생각을 한 소비자가 나타나기 시작했다.&lt;/p&gt;
&lt;p&gt;악덕 가구 업체의 이런 행태는 국내 모든 가구업체의 불신으로 이어졌다. 단 몇개의 악덕 업체만 쓰레기 재료를 사용했을 것이다. 소비자들은 완제품 가구에 의심을 하기 시작했다. 이는 오히려 이케아의 인기에 불을 지폈다. 사람들은 속에 어떤 재료가 있는지도 모를 제품을 구매하지 않은 것이다. 완성된 채로 배달되는 가구(요즘은 배달후 조립하는 가구도 많이 늘었다)보다는 이케아와 같이 직접 조립하는 가구들은 소재를 전부 알수 있었기 때문에 이케아를 신뢰했다.&lt;/p&gt;
&lt;p&gt;오늘 나도 소파를 둘러보고 나서 고민이 생겼다. 이케아 가구가 전부 저렴하지는 않다. 비싼것도 꽤 많다. 그런데 내가 사고 싶은 소파가 꽤 고가에 속한다. 인터넷을 찾아보니 한 국내 업체도 이와 비슷한 형태와 기능으로 만들어진 제품을팔고 있었다. 게다가 설치와 조립까지 모두 해준다. 그런데 가격은 절반 수준이다. 순간 위에서 언급했던 뉴스가 생갔났다. 혹시 가구의 재료가 저렴한건 아닌지 의심이 생긴것이다. 만약에 쓰레기 목재나 솜을 사용한건 아닐까? 조립까지 직접하는 이케아가 왜 더 비쌀까? 어떻게 할지 모르겠다. 가격이냐, 믿음이냐?&lt;/p&gt;</content:encoded></item><item><title><![CDATA[아파트와 우드슬랩 식탁이 어울릴까?]]></title><description><![CDATA[…]]></description><link>https://blueshw.github.io/2018/07/06/wood_slab_table/</link><guid isPermaLink="false">https://blueshw.github.io/2018/07/06/wood_slab_table/</guid><pubDate>Fri, 06 Jul 2018 01:42:34 GMT</pubDate><content:encoded>&lt;p&gt;우드슬랩(구글 검색결과)이 유행인가보다. 우드슬랩이란 통원목 테이블을 말한다. 형태가 잘 떠오르지 않는다면(혹은 구글 검색 결과를 클릭해보지 않았다면), 카페에서 흔히 보이는 테이블을 상상하면 된다. 보통 규격화 된 사각 원목테이블을 만들 때는 가공한 나무 조각을 여러개 이어 붙여 만든다. 그런데 우드슬랩은 하나의 통원목으로 테이블을 만든다. 그래서 가격도 비싸다. 통원목을 그대로 잘라 만들다보니 모서리가 울퉁불퉁하고 옹이 부분이 군데군데 비어 있는 경우도 더러 있다. 누구는 이렇게 깔끔하지 않은 형태를 선호하지 않을 수도 있다. 하지만, 우드슬랩을 원하는 사람들은 이렇게 가공되지 않은 날것의 유니크함에 더 열광한다.&lt;/p&gt;
&lt;p&gt;나에게 훌륭한 디자인이란 조화로움이다. 이탈리아의 도시 피렌체를 예로 들어보자. 피렌체는 건물 지붕의 색이 엷은 주황색으로 거의 동일하다. 건물의 형태는 도로에 따라 조금씩 다르지만 높이는 거의 비슷하다. 벽과 지붕의 색상도 거의 같다. 이런 건물로 둘러쌓여있어서인지 모르겠지만, 피렌체 두오모에 올라보면 도시 전체가 하나의 완성된 모습이라는 느낌이 든다(이 역시 사람에 따라 다르다). 그런데 만약에 이런 도시에 가운데 커튼월(유리벽)로 감싼 초고층 빌딩이 들어선다면 어떻겠는가? 아니면 혼자만 완전히 다른 색과 다른 모양의 현대적인 건물이 들어선다면 또 어떻겠는가? 그럴리는 없겠지만(아마 시에서 허가하지 않을거다) 지금까지 이어오던 피렌체의 명성이 하루아침에 날아가 버릴지도 모른다.&lt;/p&gt;
&lt;p&gt;조화로움은 꼭 도시만의 얘기는 아니다. 집안에서도 조화로움은 중요하다. 사람들이 한 브랜드의 가구를 사는 것도 같은 이유라 생각한다. 같은 브랜드의 가구는 디자인이 비슷하고 디자인이 비슷하면 아무래도 조화롭게 느낄수 있다. 반대로 모양도 형태도 스타일도 제각각인 가구를 하나씩 구매했다고 생각해보자 이리 배치해보고 저리 배치해봐도 조화롭게 만들기는 어렵다.&lt;/p&gt;
&lt;p&gt;아파트는 인위적이다. 싱크대의 수납장, 각진 인공대리석의 싱크대 상판, 실크벽지, 네모 반듯한 타일의 아트월 등 새 아파트에 들어서는 인테리어는 인위적이다(가격 문제도 있을거다). 그런데 여기에 우드슬랩 식탁을 놓는다 상상해보자. 쉽게 어울릴것 같지 않다.&lt;/p&gt;
&lt;p&gt;어떤 카페가 있다. 벽에는 별다른 마감을 하지 않아 콘크리트가 그대로 노출되어 있다. 천정도 막지않아 공조도 모두 오픈되어 있다. 인테리어의 대부분은 나무나 벽돌 또는 철판이다. 재료의 질감이 모두 살아있다. 요즘 많이 볼 수 있는 카페, 레스트랑의 모습이다. 이런곳에 형태가 일정치 않은 기다란 우드슬랩 테이블이 놓여있다고 상상해보자. 아주 잘 어울린다.&lt;/p&gt;
&lt;p&gt;훌륭한 디자인이라는건 주관적인 기호에 가깝다. 누군가에게는 형편없지만 다른 누군가에게는 최고의 디자인일수 있다. 그래서 내 디자인 취향을 남에게 강요해서는 안되고 남의 선택에 대해서도 왈가왈부해서는 안된다. 하지만 날것은 날것들과 더 어울린다(지극히 주관적인 생각이니 오해마시길). 가구를 살때 그 가구의 디자인만 봐서는 안된다. 집에 사용하는 가구의 형태와 색상, 질감을 상상해보고 사려는 것과 잘 어우러지는지 가늠해봐야 한다. 만약 그렇지 않다면 아무리 아름답다 하더라도 포기하는게 맞다. 옷이라면 안입으면 그만이지만 가구는 가격도 비싸고 오랫동안 함께 지내야하기 때문이다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[텍스트는 해석하기 나름이다.]]></title><description><![CDATA[…]]></description><link>https://blueshw.github.io/2018/07/04/interpret_text/</link><guid isPermaLink="false">https://blueshw.github.io/2018/07/04/interpret_text/</guid><pubDate>Wed, 04 Jul 2018 00:34:09 GMT</pubDate><content:encoded>&lt;p&gt;여자와 남가자 있다. 메신저로 대화를 한다. 여자는 온갖 이모티콘과 특수문자를 사용하여 긴 장문을 상대에게 보내는데, 남자의 대답은 ‘ㅇㅇ’다. 열받는다. 나는 상대에게 이처럼 정성스레 톡을 보내는데 상대는 나를 귀찮아 하는것 같다. 내가 귀찮냐고 물어보면 바빠서 그렇다고 답한다. 예전에는 이러지 않았는데 요즘들어 변한것 같다. 여자는 슬퍼지려한다. 남자는 요즘들어 정말 바쁜 프로젝트를 진행중이다. 휴가는 고사하고 정시 퇴근하면 다행이다. 이렇게 바쁜데, 여자에게 톡이 온다. 정신은 없지만 대답은 해야한다. 대답을 안하면 또 무슨일이 벌어질지 모른다. ‘읽씹’은 재앙에 가깝다. 할 수 없이 간단하게 ‘ㅇㅇ’로 답했다. 하지만, 이어지는 여자의 하소연, 남자는 정말 바빠 죽겠는데 여자는 요즘 변했다는둥 투정을 늘어 놓는다. 정말 죽겠다.&lt;/p&gt;
&lt;p&gt;두 사람의 대화에 ‘ㅇㅇ’라는 텍스트가 있다. ‘ㅇㅇ’는 ‘응’, ‘맞다’, ‘동의한다’, ‘yes’ 등의 의미를 가지는 채팅 문자다. 풀 텍스트로 쓰기 귀찮을 때 가볍게 작성하기에 편리하다. 단 2 개의 자음으로 이뤄진 단순한 텍스트지만, 받아들이는 사람에 따라 해석은 전혀 다르다. 누구는 귀찮음의 표현이고 누구에게는 최소한의 대답이다. 이처럼 동일한 표현이라 하더라도 받아들이는 사람에 따라 해석은 천차만별이다. 특히 그 사람의 처한 환경, 문맥, 기분에 따라 다양하게 해석 가능하다.&lt;/p&gt;
&lt;p&gt;텍스트의 해석은 해석하는 주체가 누구냐에 따라 분쟁의 불씨가 되기도 한다. 대표적인 예로 종교가 있다. 특히 유일신을 섬기는 종교에서 이런 현상이 자주 나타난다. 유일신을 섬기는 종교 집단은 대체로 배타적인 성향이 강하기 때문에 텍스트에 대한 다른 해석을 용납하지 않는다. 가볍게는 이단으로 몰리고, 심하면 종교전쟁까지 불사한다. 또한 오래된 텍스트일수록 해석의 차이가 많이 날 수 있다. 오래전에는 기록하기 위한 도구가 부족했고, 문자를 아는 사람도 많지 않았다. 그 때문에 남아 있는 텍스트 역시 부족하다. 텍스트가 부족하기 때문에 이를 바탕으로 역사를 유추하기 위해서는 해석하는 역사가의 주관이 첨가될 수 밖에 없다. 역사가의 주관은 역사관이라 한다. 이는 그들이 어떤 교육을 받아왔고 연구해왔는지에 따라 결정된다. 국가주의 역사관을 가진 역사학자는 자신이 속한 국가에 유리하도록 역사를 해석할 것이다. 이게 심한 경우에는 역사 왜곡이 될 수 있다. 일본의 국가주의 역사가들에게서 흔히 볼 수 있는 모습이다. 독도가 일본땅이라고 주장하거나, 식민지 시대의 만행을 부정하는 등의 주장이 그 예라 할 수 있다.&lt;/p&gt;
&lt;p&gt;텍스트 해석 차이의 문제는 다양한 사회문제를 유발한다. 대표적인 예로 지역 감정이 있다. 지역 감정이 영남과 호남에만 존재하는건 아니다. 넓게보면 그렇지만 좁게 보면 옆 동네와도 흔히 발생한다. 다양한 원인으로 두 지역의 분쟁이 발생할 수 있지만, 텍스트의 해석 차이로 발생하는 경우도 꽤 많다. 예를 들어 두 지역을 관할하는 관청에서 어떤 사업을 진행하려한다. 이때 명확하지 않은 텍스트의 사용으로 잠정적인 문제를 야기시킬 수 있다. 한 지역은 지하철이 지나가고 한 지역은 지하철이 안지나간다. 지하철이 안지나가는 지역 사람들은 십수년간 불편한 교통에 시달려 관청에 지속적으로 민원을 넣고 있다. 민원이 과도하게 접수가 되다보니 지역 사람들을 달래기 위해 이렇게 말한다. 신 교통수단을 도입해서 획기적으로 교통 문제를 해결해 주겠다고. 교통이 불편한 지역에 살던 사람들은 ‘획기적인 신교통수단’이라는 텍스트를 해석하기 시작한다. 요즘 뜨는 새로운 교통수단이라는 의미가 트램이 아닐까 생각한다. 그게 아니더라도 전철 분기 정도는 될꺼라 믿는다. 지하철이 지나가는 지역의 사람들은 또 다르게 생각한다. 트램이나 전철 분기를 하려면 못해도 수천억의 사업비가 필요한데 한 지역만을 위해서 그 많은 돈을 들여 트램이나 전철 분기를 할 이유가 없다. 아마도 버스 노선을 늘리거나 배차 시간을 줄여주는 정도로 끝날 것 같다. 텍스트 해석을 마친 두 지역 사람들은 이제 온라인 카페에서 논쟁을 시작한다. 서로 자기 말이 맞다, 니 말이 틀리다를 반복한다. 반복하다보면 그 중에는 감정적으로 대응하는 사람들이 나오게 마련이다. 욕설과 비방이 오가며 서로를 헐뜯는다. 어느 순간 두 지역은 철천지 원수로 변하고 그쪽 동네 사람들과는 말조차 섞기 싫어한다.&lt;/p&gt;
&lt;p&gt;위의 사례가 특수한 경우가 아니다. 부동산이나 개발 등의 온라인 카페에서 아주 흔하게 발생한다. 두 지역 사람들의 인성이 틀려먹어서 발생한 문제는 아닐 것이다. 두 지역을 관할하는 관청이 애매모호한 표현을 쓴 것이 문제다. ‘획기적인 신 교통수단’에서 ‘획기적인’이라는 표현과 ‘신’이라는 표현은 매우 추상적이다. 받아들이는 사람의 입장에서는 획기적일수도 있고 아닐수도 있다. 마찬가지로 새로운이라는 뜻의 ‘신’ 또한 받아 들이는 사람에 따라 새로울 수도 있고 아닐 수도 있다. 애초에 관청에서 확실한 표현으로 두 지역의 갈등을 조장하지 않았어야 했다. 예를들어 ‘A 에서 B 까지 연결하고 C 를 통과하는 ‘트램’을 만들겠다’라고 했다면 두 지역간의 갈등은 지금보다 훨씬 적었을 것이다.&lt;/p&gt;
&lt;p&gt;텍스트는 해석하기 나름이다. 텍스트를 해석하는데 그 어떠한 제약을 줄 수는 없다. 해석은 자유지만, 쓸때는 분명하게 작성해야 한다. 분쟁이 발생할 여지가 있는 텍스트를 써야할 필요가 있을때는 반드시 주의를 기울여야 한다. 내가 작성한 문장 하나 때문에 두 지역이 철천지 원수가 될수도 있다. 또한 내가 작성한 계약서에 잘못 사용된 텍스트가 있어 계약이 무효가 될 수도 있다. 텍스트를 사용하는 입장에서는 충분히 제대로 알고 있다 하더라도 받아들이는 입장을 항상 고려해야 한다. 읽는 사람이 누구인지 정도는 정확히 파악하고 있어야 오해가 없는 글쓰기가 가능하다. 내 글이 불특정 다수의 사람이 볼지, 학생들이 볼지, 아이들이 볼지, 여자가 볼지 남자가 볼지를 명확히 해야한다. 그렇지 않으면 언제든 분쟁의 씨앗이 뿌려 질 수 있다는 것을 명심해야 한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[1년 동안의 매일 아침 듣기, 효과 있었을까?]]></title><description><![CDATA[…]]></description><link>https://blueshw.github.io/2018/07/03/listening_english_everyday/</link><guid isPermaLink="false">https://blueshw.github.io/2018/07/03/listening_english_everyday/</guid><pubDate>Tue, 03 Jul 2018 00:26:46 GMT</pubDate><content:encoded>&lt;p&gt;처음 프로그래머가 되고자 했을때는 해외에서 근무하고 싶었다. 구체적인 방법은 생각해본적 없지만 막연하게 해외 직장 생활을 동경해왔던것 같다. 해외에서 취업하기 위해서는 필요한것이 많겠지만, 누가 머라해도 가장 중요한 것은 영어(영미권이 아니라면 해당 나라의 언어, 앞으로는 영어로 대표한다)다. 일한다는 것은 의사소통이 전제되기 때문에 영어가 안된다면 해외 취업은 사실상 무리다. 아무리 실력이 뛰어난 프로그래머라도 기본적인(협업이 가능한(?)) 영어 실력 없이는 해외에서 직장을 구하기란 어렵다.&lt;/p&gt;
&lt;p&gt;한국인에게 영어는 가장 필요로 하지만, 가장 정복하기 어려운 것 중에 하나다. 2000 년대 학번의 대학생이라면 졸업을 위한 토익 시험을 한번쯤 봤을 것이다. 학과에 따라 다르지만, 대략 600~700 점 정도가 필요했던 것으로 기억한다. 영어관련 학과나 무역 또는 경영 관련 학과라면 졸업후에 영어가 필요할지도 모른다. 하지만 대부분의 학과는 졸업하고나면 영어를 사용하는 일은 거의 없다. 심지어는 이런 경우도 있다. 국문학과 출신의 소설가 지망생이 졸업 하기 위해 토익 공부를 해야한다. 이 얼마나 어불성설인가?&lt;/p&gt;
&lt;p&gt;인터넷에서 영어 공부방법을 찾아보면 정말 어마어마하게 많이 나온다. 광고도 많다. 세달만 따라하면 말이 술술 나온다던가, 몇 주 만에 자막없이 영화 볼 수 있다는 식이다. 아직 다양한 방법을 시도해 본건 아니지만, 대체로 실효성이 없다는 것에 다들 동의할 것이다(광고는 광고일 뿐). 몇 달 만에 기적같이 영어를 잘 할 수 있으면 그 누가 십수년간 고생하며 공부하고 있을까. 모든 일을 제쳐두고 영어에만 올인하면 6 개월만 열심히 해도 어느정도 성과가 있을것이다. 하지만, 유학을 준비하는 학생이 아니고서야 6 개월 정도의 시간은 할애 하기란 쉽지 않다. 그래서 직장인들이 할 수 있는 방법은 매일매일 조금씩 꾸준히 공부하는 것밖에 없다(너무 당연한가…).&lt;/p&gt;
&lt;p&gt;그런데 정말 그럴까? 그냥 조금씩 꾸준하게 공부 하기만하면 실력이 팍팍 늘까? 글쎄다. 나는 대략 1 년 전부터 매일 아침(주말 제외) 출근길에 미국 드라마(모던패밀리)를 반복 시청하고 있다. 한 편당 50 회를 반복한다. 일주일에 5 번 보게 되니까 한편을 다 보려면 10 주가 걸린다. 1 년이 지나면 대략 다섯 편 정도를 끝낼 수 있다. 1 년 정도 하다보니 습관이 들어서 매일매일 보고 듣는게 크게 힘들지 않다. 딱히 모바일 게임을 하는 것도 아니라서 다른데 시간을 뺏길 염려도 없다. 한 편을 50 번 반복해서 듣다보니 웬만한 표현은 알파벳 하나까지 다 들리기도 한다.&lt;/p&gt;
&lt;p&gt;그런데 이 방법이 효과가 있었을까? 1 년쯤 지나다 보니 정말 효과가 있을지 의문이 들기 시작했다. 별도로 영어 회화스터디를 하는것도 아니고 학원을 다니지도 않아서 내 실력이 늘었다는 걸 가늠 하기가 어렵다. 하지만 영어 뉴스를 듣거나 영화를 볼 때 예전에 비해서는 조금 편안하다는 느낌은 있다. 기존에는 영어 단어 하나 문장 하나를 곱씹어 생각하다 보니 정작 문맥을 놓치는 경우가 많았다. 영어 듣기에서 가장 중요한게 문맥이 아닌가. 한번 문맥을 놓치면 그 다음은 전혀 들리지 않는다. 그렇다고 불시에 외국인을 만나서 자유롭게 의사소통 하라면 할 수 있을까? 확신은 없다. 미리 할 말을 생각하고 말하면 가능할지 몰라도 갑자기 말해보라 하면 자연스러운 문장이 나오기는 힘들것 같다.&lt;/p&gt;
&lt;p&gt;1 년으로 성과를 바라는건 무리일 수 있다. 1 년 내내 영어만 공부했다면 모를까, 출근시간에만 잠깐씩 듣는 걸로 실력이 일취월장 하기를 바라는건 무리다. 그래서 앞으로 1 년 더 해볼 생각이다. 지금과 똑같이 할지 좀더 개선된 방법을 찾을지는 미지수다. 일단은 큰 변화없이 계속 이어나갈 생각이다. 계속 하다보면 욕심이 생기고 욕심이 생기면 더 나은 방법을 스스로 찾을꺼 같다. 굳이 조급하게 새로운 방법에 도전하는건 위험할 수 있다. 자칫 부담을 느껴 그만두는 사태가 발생할지도 모르기 때문이다. 이 글은 1 년 뒤에 다시 읽어볼 생각이다. 1 년 후에 이 글을 다시 읽었을때, 지금과 비교해서 얼마만큼의 성과가 있었고 변했을지 가늠해볼 수 있지 않을까?&lt;/p&gt;</content:encoded></item><item><title><![CDATA[앞으로 뭐 먹고 살까?]]></title><description><![CDATA[…]]></description><link>https://blueshw.github.io/2018/07/02/what_will_i_do/</link><guid isPermaLink="false">https://blueshw.github.io/2018/07/02/what_will_i_do/</guid><pubDate>Mon, 02 Jul 2018 02:13:53 GMT</pubDate><content:encoded>&lt;p&gt;지금 다니는 직장과 하고 있는 일에 불만은 없다. 자유로운 문화에 일에 대한 스트레스도 적기 때문이다. 이 정도 직장이면 평생 다녀도 좋다는 생각이다. 하지만, 평생 직장이란 개념이 사라진지 오래다. 그리고 스스로도 은퇴할때까지 버티고 싶지는 않다. 이직도 대안이 될 수 있지만, 회사에 매여 있는건 똑같기 때문에 고려대상이 아니다. 회사에 매여서 월급 받는 생활은 이제 그만하고 싶다. 내 인생을 스스로 컨트롤 할 수 있는 그런 일을 찾으려 한다. 이를 특정 범주에 넣어보면 ‘1 인 기업’쯤 되겠다. 그 동안 몇가지 고민해 왔던 일들을 정리해 보고 내가 정말 하고싶은 일이 뭔지 고민해 볼 시기가 온것 같다.&lt;/p&gt;
&lt;p&gt;참고로 순서는 아무 의미 없다. 생각나는대로 적어봤다.&lt;/p&gt;
&lt;h3&gt;부동산 전문가 or 부동산 서비스 개발&lt;/h3&gt;
&lt;p&gt;이번에 집을 장만하면서 부동산 및 경제 서적을 닥치는대로 읽었다. 그동안 워낙에 관심이 없었기도 했지만 기초 지식이 많이 부족한것 같아 기초를 다지는 마음으로 책을 읽고 또 읽었다. 대략 6 개월 안에 20 권 이상 읽어본것 같다. 부동산 인터넷 카페도 수시로 방문해서 사람들의 다양한 견해도 살펴보고 전문가들의 예측이나 부동산 뉴스도 꼼꼼히 챙겨봤다. 아직 채 1 년도 안됐지만, 지속적으로 관심을 가지고 있다보니 이쪽 계통도 나쁘지 않다는 생각이 들었다.&lt;/p&gt;
&lt;p&gt;갑자기 내가 부동산 전문가가 되서 뉴스에 칼럼을 쓰거나 책을 쓰거나 방송에 출연할 수는 없다. 카페든 블로그든 여러 채널을 통해서 부동산 지식을 쌓고 그 지식을 사람들과 나누면서 소통해야 가능한 일이다. 그것도 꽤 오랜 시간이 필요하다.&lt;/p&gt;
&lt;p&gt;또 다른 방법으로 부동산 서비스를 제작하는 것이다. 구체적인 아이디어를 언급할 수는 없지만, 지금 내가 해오고 있는 일(프로그래밍)과 잘 접목시켜 인터넷 서비스를 개발할 수 있다. 무료 서비스를 제공하여 유저를 모으고 그 유저의 트래픽으로 수입을 창출하는 방식은 아니다. 이런 방식은 수익을 얻기 까지 버틸 시간과 자금이 넉넉해야 성공 가능성이 높다. 나는 무료 서비스 대신 유료화 서비스를 바탕으로 소수의 유저에게 양질의 데이터를 제공하는 방식을 생각하고 있다.&lt;/p&gt;
&lt;h3&gt;아이디어 제품 제작 및 판매&lt;/h3&gt;
&lt;p&gt;아이디어를 가지고 제품을 만들어 판매하는 지극히 일반적인 사업 방식이다. 이 방식의 문제점은 초기 비용이 많이 드는데 있다. 아이디어를 가지고 제품을 만들면 초기 비용이 만만치 않게 필요하다. 그리고 자신이 생각하기에 멋진 아이디어로 제품을 만들었다 해도 남들이 볼때는 전혀 필요없거나 엉터리 아이디어 일수 있다. 그렇기 때문에 초기에 비용을 들여서 제품을 만들어 놓기에는 리스크가 있다. 이 문제를 해결하기 위해 크라우드 펀딩을 이용할 수 있다. 킥스타터 같은 크라우드 펀딩 서비스를 이용하면 제품을 만들기 위한 초기 자본을 모을 수 있고 투자자들에게 제품을 제공하기 때문에 적절하게 제품홍보도 이뤄질 수 있다는 장점이 있다.&lt;/p&gt;
&lt;p&gt;또 다른 문제는 제품을 제작해서 팔기 까지 배워야 할게 많다는 것이다. 이를 문제가 아니라 배움의 기회로 삼으면 좋겠지만, 직장에 다니면서 짬을 내어 제품을 만들고 팔기까지는 많은 시간이 소요될 것이다. 시간이 길어지면 자칫 쓸모 없는 아이디어가 될 수도 있다. 어떤 아이디어에 따라서 다르지만, 판매하는 시기가 굉장히 중요한 경우도 있기 때문이다. 그래서 아이디어를 생각할 때 시기가 중요한 것은 배제하려고 한다. 몇달이 지나서 생각해도 여전히 훌륭한 아이디어인 경우에만 제품화에 도전할 생각이다.&lt;/p&gt;
&lt;p&gt;이 두가지 문제를 극복한다면, 그 다음엔 판매전략이 필요한데, 거기까지는 생각 못했다. 어떤 방식으로 팔지는 좀더 공부해보고 연구해봐야 할 것 같다.&lt;/p&gt;
&lt;h3&gt;책 쓰기&lt;/h3&gt;
&lt;p&gt;20 대부터 생각해오던 일이다. 책이라는 결과물이 중요하긴 하지만, 꼭 목표가 책일 필요는 없다. 책은 상징적인 의미이고, 글로써 삶을 영위할 수 있으면 좋겠다는 생각이다. 이를 실현하려고 그동안 몇번이나 블로그를 만들었다가 중도에 포기했는지 모른다. 아마 이번이 6 번째 쯤 될것 같다. 지금까지 실패한 이유를 생각해보면, 좀 거창했다는 느낌이었다. 내가 정말 좋아해서라기 보다는 필요에 의해 시작했거나, 특정 목적이 있어 시작한 경우였는데 그러다보니 글을 쓰려는 의욕이 얼마 못가 사라졌다. 그래서 이번에는 조금 다르게 접근하기로 했다. 처음부터 거창한 주제로 글을 쓰기 보다는 일기처럼 그날 있었던 일이나 생각을 간단하게 적기로 했다. 그러다 정말 쓰고 싶은 주제를 발견하면 그 때가서 추가로 카테고리를 만들면 될거라는 생각이 들었다.&lt;/p&gt;
&lt;p&gt;만약에 글쓰기로 먹고살 수 없다 하더라도(실제로 어렵다) 꾸준히 해볼 생각이다. 어떤 일을 하든 글을 쓰는 일이 없는 경우는 없다. 제품을 만들어 판다면 제품의 홍보글을 쓰거나 고객의 항의 메일에 답장을 쓸 수도 있다. 또는 투자를 받게 된다면 사업계획서를 작성해서 내가 만들고자 하는 서비스에 대해 설명해야할 필요도 있을 것이다.&lt;/p&gt;
&lt;p&gt;또한 글 쓰는 행위는 산발적인 생각들을 정리하기에 훌륭한 도구가 된다. 평소에 이런 저런 생각이 들다가도 조금만 지나면 그 생각이 뭐였는지 모를때가 많다. 글을 쓰면 이런 문제를 해결할 수 있다. 생각이 떠오를때마다 바로바로 메모하기는 어렵더라도 하루에 있었던 일과 나누었던 대화를 떠올리면서 정리하는 습관은 무슨 일을 하더라도 꼭 필요한 것 같다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[아파트 단지간 싸움은 칼로 물베기다?]]></title><description><![CDATA[…]]></description><link>https://blueshw.github.io/2018/06/30/apartment_dispute/</link><guid isPermaLink="false">https://blueshw.github.io/2018/06/30/apartment_dispute/</guid><pubDate>Sat, 30 Jun 2018 23:02:28 GMT</pubDate><content:encoded>&lt;p&gt;곧 있으면 내집으로 이사다. 한달 남짓 남았다. 한창 설레야 할 시기에 머리가 아프다. 살고 있는집이 안나갔거나, 이사에 문제가 있거나 자금 융통이 어려워서가 아니다. 이사갈 지역에 아파트 단지끼리 싸움이 나서다. 새로 개발되는 지역에서 싸움 나는 경우는 흔하다. 모든게 새로 만들어지기 때문이다. 뭔가가 만들어질때, 한 단지에서 호재로 느끼는 것이 옆 단지에게는 매우 불편한 것일 수 있다. 생활에 직접적으로 불편을 주는 경우(이것 또한 돈으로 귀결된다고 본다)도 있겠지만 대부분은 돈과 관련된 일이다.&lt;/p&gt;
&lt;p&gt;나는 건축을 전공했고, 우리나라의 아파트를 혐오했다. 집을 살기 위한 것이지 사기 위한 것(투자의 대상)이 아니라고 생각했기 때문이다. 그래서 당시의 나는 절대로 아파트에 들어가 살지 않으리라 다짐했다. 지금 생각하면 철이 없었던것 같지만, 한편으로 그 소신을 지키지 못함이 안타깝다. 우리나라에서 아파트는 투자의 대상이다. 특히 아파트를 구매하는 사람들은 대부분 그렇게 생각한다. 처음에는 아닐지 몰라도 주변 환경의 변화와 국제 금융시장의 변화에 따라 시세가 오르락내리락 하는걸 보면 마음이 흔들릴수 밖세 없다. 예를 들어보자. 한 지역에 지하철 역이 생긴다. 지하철 역은 부동산에서 가장 큰 호재 중의 하나다. 당연히 역이 생기면 그 지역의 시세가 급등할 가능성이 높다. 그런데, 지금껏 비슷한 가격을 유지하던 옆 단지는 이게 불편하다. 옆 지역은 지하철 역이 생겨 1 억이 넘는(요즘은 1 억도 우습다) 시세 차익을 바라보는데, 본인들 지역은 시세 변화가 없으니 말이다. 배가 아플만하다.&lt;/p&gt;
&lt;p&gt;이사가는 아파트 지역에는 왜 싸움이 났을까? 한 단지가 시행사 비용으로 소음 방지를 위한 방음터널을 만들기로 했다. 방음터널은 구조상 출입구쪽으로 먼지가 집중된다. 그래서 주로 주택가가 아닌쪽으로 먼지를 배출해야한다. 그런데 이게 힘들다면 방음터널 내 집진시설을 만들거나 반방음 터널로 만들어야 피해를 최소화 할 수 있다. 그런데 완방음터널로 계획한 것이다. 옆 단지 입장에서는 억울함을 호소할 수 있다. 방음터널이 없어도 도로에서 어느정도의 먼지가 발생 하겠지만, 방음터널이 만들어짐으로 인해 먼지가 더 심하게 발생할수 있다. 그래서 싸움이 났다. 한쪽은 원안대로 할것이다, 한쪽은 피해가 가니 차선책으로 변경하거나 연장해 달라한다. 양쪽 주장다 일리가 있다. 그런데 이 문제가 쉽게 해결될 기미가 보이지 않는다. 방음터널이라는 것이 비용이 많이 들기도 하지만, 그 돈을 누가 부담할지 확실치 않기 때문이다. 또 다른 문제는 두 단지간에 한치의 양보도 없다는 것이다. 아마도 돈이 걸려있기 때문이다. 아니라고 하는 사람도 있겠지만 나는 본질은 돈이라 생각한다. 조금이라도 자신의 단지가 주변 단지보다 살기 좋은 곳이라고 알려진다면 향후 시세는 옆 단지보다 더 높아질게 분명하기 때문이다. 돈 앞에서 양보는 없다.&lt;/p&gt;
&lt;p&gt;그럼, 어떻게 하면 두 단지의 싸움이 끝나게 할 수 있을까? 당장의 방법은 없어 보인다. 이미 방음터널 문제로 틀어질때로 틀어졌는데, 갑자기 만나서 방법을 찾아보자고 하면 더 싸울게 뻔한다. 격한 감정싸움은 불필요하게 에너지만 낭비한다. 각자 원하는게 있으면 요구해야할 기관에 요구하면 된다. 요구가 합당하면 들어줄 것이고 아니면 안들어줄 것이다. 난 이 싸움을 그다지 심각하게 생각하지 않는다. 왜냐면 본질이 돈이기 때문이다. 지금은 이해관계가 달라 서로 헐뜻으며 싸우고 있지만, 추후에는 이해관계가 같은 사안도 있을것이다. 아마 그 때는 언제 그랬냐는듯 서로 합심해서 요구할 것이 분명하기 때문이다.&lt;/p&gt;
&lt;p&gt;가만보면 우리나라 국회의원들의 생존방식과 비슷하다. 우리나라는 자유한국당, 민주당 양당체제로 오랜시간 유지되어 왔다. 두 당은 서로 추구하는 방향이 너무 다르다. 한쪽은 지키자는 입장이고, 한쪽은 개혁이 필요하다는 입장이다. 어떤 사안은 다행히(?) 협의가 가능한 경우도 있다. 하지만 이 두 아파트 단지처럼 절대 물러설수 없는 사안도 있다. 그게 과열되면 국회에서 난투극이 벌어지기도하고 날치기 통과가 되기도 한다. 하지만, 두 당 모두에게 이익이 되는 일(예를들면 국회의원 연금법 같은…)은 어떠한 싸움도 없이 하나된 마음으로 빠르게 처리한다. 아파트나 국회의원이나 똑같다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[에어컨을 설치할까? 한달을 참을까? 아니면??]]></title><description><![CDATA[지금 살고 있는 집에는 에어컨 설치가 안되있다. 에어컨이 없는건 아니다. 무려 2in…]]></description><link>https://blueshw.github.io/2018/06/28/need_air_conditioner/</link><guid isPermaLink="false">https://blueshw.github.io/2018/06/28/need_air_conditioner/</guid><pubDate>Thu, 28 Jun 2018 00:02:04 GMT</pubDate><content:encoded>&lt;p&gt;지금 살고 있는 집에는 에어컨 설치가 안되있다. 에어컨이 없는건 아니다. 무려 2in1 에어컨을 가지고 있다. 다만 설치를 하지 않은것 뿐이다. 이렇게 더운데 에어컨 설치를 안한 이유는 한달 후면 다른 집으로 이사가기 때문이다. 애초에 지금 사는 집은 9 개월만 계약했고 만기가 8 월이다(이사는 8 월 초다). 처음 계약할때는 7 월 정도까지 충분히 버틸줄 알았다.&lt;/p&gt;
&lt;p&gt;근데 몸이란게 내 생각대로 되는게 아닌가보다. 더위가 점점 기승을 부리면서 덩달아 내 생각도 바뀐다. 거실에 가만히 앉아 있어도 온몸이 끈적끈적하다. 찬물로 샤워를 해도 고작해야 30 분도 시원하지 않다. 참다참다 와이프한테 얘기했다.&lt;/p&gt;
&lt;p&gt;“에어컨 설치할까?”&lt;/p&gt;
&lt;p&gt;“그럴까?”&lt;/p&gt;
&lt;p&gt;와이프도 더웠나보다. 근데, 이사가 한달 남은 상황에서 20~30 만원을 주고 에어컨을 설치하자니 너무 아깝다. 이사하면 생각지도 못한 이곳저곳에서 지출이 발생할게 분명하다(내 집이라 그렇다. 전세면 덜 들겠지). 힘들더라도 지금 좀 아끼고 이사갈 집에 투자하는게 합리적인 선택으로 보인다. 머리는 이런데, 몸은 자꾸 에어컨 설치를 부추긴다. 또다른 문제가 있다. 딸아이가 너무 더워한다. 하필 나를 닮아서(안 좋은건 다 닮는다) 몸에 열이 많다. 자고 일어나면 머리맡이 축축하다. 땀 흘리고 선풍기 바람 쐬고를 반복하다보니 감기도 걸렸다. 아… 에어컨 설치하자.&lt;/p&gt;
&lt;p&gt;인터넷 카페를 뒤저 저렴하게 에어컨 설치를 전문적으로 하시는 분을 찾았다. 25 만원쯤 든다고 한다. 삼 X 에어컨이라 더 비싸단다. 왜?? 방식이 달라서 그렇단다. 왜 방식을 다르게 만들어 설치할때마다 돈을 더 들게 만드나 생각했다. 그런데, 이 회사 주식을 내가 왜 자꾸 사는거지? 그래도 반도체는 잘 만들겠지.&lt;/p&gt;
&lt;p&gt;우리보다는 딸아이를 위해(?) 에어컨 설치를 결정했다. 결정하고 나서 혹시나 소형 에어컨이 있나 검색해보았다. 왠걸, 실외기가 필요없는 이동식 에어컨이 있다. 가격은 만만치 않다. 대략 30~40 정도한다. 가격이 비싼만큼 시원하긴 하겠다는 믿음이 간다. 좀 생각해보자. 차라리 에어컨 설치는 취소하고 이걸 사는건 어떨까? 에어컨 설치는 한 달 후에 또 해야하지만, 이동식 에어컨은 한달 사용하고 중고로 처분하면 10 만원 정도의 감가상각이 발생한다. 새 제품을 안사고 중고나라를 뒤져 중고를 사볼까? 찾아봤다. 더워지기 시작하니깐 매물도 별로없고 금방 팔린다. 중고가임에도 가격이 만만치않다. 정품에 비해 80~90% 정도로 판매된다. 비싸다. 역시 수요가 많을때 구매하는건 바보짓인가보다.&lt;/p&gt;
&lt;p&gt;조금더 검색해보니 이동식 에어컨은 소음이 엄청나다고 한다. 얼마나 심하기에 ‘엄청’날까? 또 고민된다. 비싼 돈 들여 샀는데 소음때문에 고통받는다면, 이것 역시 최선은 아닌거 같다. 아무리 더워도 한달 꾹 참을까? 돈이 들고 회수가 불가하지만, 에어컨을 설치할까? 중고거래로 비용을 최소화 할 수 있지만 소음을 참으면서 이동식 에어컨을 쓸까? 딜레마다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[외모와 글쓰기는 반비례 하는가? <서민적 글쓰기>]]></title><description><![CDATA[…]]></description><link>https://blueshw.github.io/2018/06/27/look_and_writing/</link><guid isPermaLink="false">https://blueshw.github.io/2018/06/27/look_and_writing/</guid><pubDate>Wed, 27 Jun 2018 01:43:44 GMT</pubDate><content:encoded>&lt;p&gt;외모와 글쓰기가 반비례할리 없다. 외모가 출중한 사람이라고 글쓰기에 관심없다 말할 수 없고 외모가 뒤떨어진다 해서 반드시 글쓰기에 관심을 두진 않는다. 기생충학자로 유명한 서민 교수는 책에서 대놓고 얘기한다. 나는 못생겼다고… 표지에 나온 그의 얼굴이 특출나게 못생겼다고 생각하진 않는다. 외모가 절대적인 기준이 있는 것은 아니다. 내가 잘생겼다 혹은 못생겼다고 판단하는 기준의 오할 이상은 본인에게 달려있다고 생각한다. 얼굴이 작고 눈이 크고 입이 시원하고 콧날이 오똑한 사람이 잘생김(혹은 이쁨)의 척도라고 말할 수도 있다. 하지만 각각의 요소들이 훌륭하더라도 합쳐놓고 보면 영 어울리지 않는 사람도 많다.&lt;/p&gt;
&lt;p&gt;외모 콤플렉스가 심했던 서민 교수는 얼굴에 자신이 없으니 거의 말을 하지 않았고, 말을 하지 않게되니 자연스레 말도 못했다. 말을 잘 못하니 매사에 자신이 없었고, 자신이 없으니 뭐하나 특출나게 잘하는것도 없었다. 하지만, 자기가 처한 상황에 좌절하지 않았다. 스스로 방법을 찾아냈다. 바로 글쓰기다. 글쓰기는 그에게 무기였다. 대학교 신입생때 글을 너무 쓰고 싶어서 동아리 회지를 책임지는 편집부장이 되었다. 원래는 선배들에게 글을 받아 모아서 만드는 일을 해야하는 직책이었다. 하지만, 안그래도 글쓰기에 관심없는 의대생 선배들은 글을 내놓으라고 독촉하는 그를 피하기 일쑤였다. 그러다보니 정해진 개수의 글을 확보하지 못하는 빈도가 늘어났다. 회지에 빈 영역이 늘어났고, 결국 상당수의 글을 서민 본인이 작성하게되었다. 좋아하는 여자에게 마음을 얻기 위해서는 편지를 썼다. 말은 잘하지 못했지만, 그의 글은 여자들의 마음을 움직이기에 충분했다.&lt;/p&gt;
&lt;p&gt;나도 어렸을적 말 잘하는 아이는 아니었다. 심한 축농증을 앓았고, 숨쉬기가 답답해 곤란할때도 많았다. 항상 코가 막혀 있으니 말할때도 콧소리가 났다. 말하는 자신은 잘 몰랐지만, 친구들이 코맹맹이 소리한다고 놀려대면 주눅들곤했다. 그러다보니 말하는 횟수도 점점 줄었다. 사람들 앞에서 발표하는건 정말 끔찍하게 싫어했다. 선생님이 발표를 시켜도 최대한 안하려 했고, 꼭 필요한 말이 아니면 결코 하는 법이 없었다. 말을 많이 하던 아이가 아니다보니 성인이 되어서도 말을 잘하는 편에 속하지는 않는다. 예전에 비해 그럭저럭 나아지긴 했지만, 여전히 말하다보면 횡설수설 할 때가 많다. 글쓰기에 관심을 가지게 된 것(아직은 관심만..)이 결코 우연은 아닌듯 하다.&lt;/p&gt;
&lt;p&gt;서민교수의 외모 콤플렉스와 나의 축농증은 닮았다. 자신감을 떨어뜨렸고, 말을 안하게 만들었다. 말이 줄어들었고 이를 극복하기 위한 무기로 글쓰기를 선택했다(나는 이제 선택하려고 한다). 꼭 외모나 축농중이 아니어도 좋다. 소심한 성격탓에 남들 앞에서 제대로 말하기 힘든 사람도 마찬가지고 키가 작아서 주눅이 든 사람도 마찬가지다. 힘들고 어려운 일이 있을때 이를 극복하는 것이 가장 좋은 해결책이지만(불가능한 경우도 많다), 이를 정면으로 부딪혀 이겨내는 것이 쉬운 일은 아니다. 오히려 차선책을 찾아보는 것이 나을때도 있다. 그런면에서 글쓰기는 훌륭한 차선책이다. 다른 사람을 신경쓸 필요가 없다. 오로지 나와 종이, 펜 또는 노트북만 있으면 된다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[글, 소통을 위한 도구. 쉽게 쉽게 쓰자]]></title><description><![CDATA[…]]></description><link>https://blueshw.github.io/2018/06/26/write_easy/</link><guid isPermaLink="false">https://blueshw.github.io/2018/06/26/write_easy/</guid><pubDate>Tue, 26 Jun 2018 00:16:52 GMT</pubDate><content:encoded>&lt;p&gt;전에도 말했듯이 난 건축을 전공했다. 건축가로 이름을 날리고 싶었고, 그렇게 되기 위해 열심히 노력했다(만족스러울 만큼은 아니었다). 책도 많이 읽었다. 이미 성공한 건축가들의 철학을 이해하고 배우기 위해 많이 읽었다. 여러 책을 읽는 도중에 이해가 안되는 내용도 많았지만, 내 지식이 부족하기 때문이라 생각했다. 성공한 건축가가 되려면 글을 쓸때도 이정도로 어렵고 난해하게 써야 잘쓰는거라고 믿었다.&lt;/p&gt;
&lt;p&gt;얼마전, 곧 있을 이사를 위해 책을 정리하면서 건축책도 몇권 처분했다. 그동안 이루지 못한 꿈에 미련이 남아 쉽게 버리지 못하고 있었는데, 이사는 가야하고 짐은 줄여야 해서 과감히 몇권을 처분하기로 결정했다. 눈물을 머금고 중고로 판매할책과 남겨둘 책을 구분하던 중 책 한권이 눈에 들어왔다. &amp;#x3C;코다&gt;라는 이름의 책이었고, 어느 건축가의 에세이었다. 일반적인 말하는 에세이는 쉽다. 하지만 철학에세이나, 사회과학에세이 등 특정 주제에 관한 에세이는 결코 쉽지않다. 오히려 어렵다. 유독 한국에서만 블로그에나 쓸법한 일상적인 글을 엮어서 에세이라는 형식의 책을 만들어내는 경우가 많아서 그런지, 에세이를 쉬운 글이라 생각한다(나만 그렇게 생각하는건 아니겠지?). 그런면에서 &amp;#x3C;코다&gt;는 쉽지 않은 건축철학 에세이에 가깝다. 글의 내용조차 기억나지 않을정도로 난해한 책이었는데, 당시에 유행하던 들뢰즈(질 들뢰즈, 현대 철학자)의 공간에 대한 사유를 바탕으로 폴트(접힘) 건축에 대한 내용이 주를 이뤘던것 같다. 내가 말하고도 무슨 말인지 진짜 모르겠다(어려운 책이지 형편없는 책이란 말은 아니다).&lt;/p&gt;
&lt;p&gt;건축을 공부하다보면 글이 참 어렵다는 생각이 많이 든다. 위에서 말한것처럼 정말 내 지식이 부족해서일지도 모르겠다. 두 세번 읽는건 기본이고 다 읽고 나더라도 전혀 정리되지 않을때가 많았다. 정리가 안되니 이해하는것도 쉽지 않았다. 이해하지도 못하는 개념만 주워듣고 마치 다 아는것처럼 떠들어 댔으니 지금 생각하면 너무 부끄러웠다. 이 정도면 건축을 그만둔게 정말 잘한 일인지도 모르겠다. 건축가들이 글을 어렵게 쓰는 이유가 확실히 무엇인지는 모르겠다. 대중과의 소통을 원했다면 결코 어렵게 쓰지는 않았을 것이다(김진애의 책처럼 어렵지 않은 건축 책도 많다). 한 가지 추측하자면, 어려운 글을 쓰는 수많은 건축가들은 대중과 소통하는데 별로 관심이 없었던게 아닐까 생각한다. 난해한 글과 어려운 개념으로 무장한 글을 쓰면서 전문가라는 입지를 만들기 위한 그들의 생존적략이 아니었을까?&lt;/p&gt;
&lt;p&gt;글은 기본적으로 소통을 위한 도구라고 생각한다. 기본적으로 읽는 사람이 쉽게 이해할 수 있어야 한다. 문장을 이해하기 위해 여러번 읽어야한다면 도중에 흐름이 끊겨서 전체의 줄기를 놓치기 쉽다. 글은 지식을 뽐내고 남보다 더 많이 알고 있다는 것을 드러내기 위한 수단이 아니다. 나누고 공감하기 위한 수단이다. 정말 깊이 알고 있는 사람은 글을 어렵게 쓰지 않는다. 오히려 훨씬 쉽게 쓴다. 글로 사람들을 설득한다고 생각해보자. 우선 이해가 선행되어야한다. 어려운 표현은 배제하고, 한번에 쉽게 이해할 수 있도록 써야한다. 어쩌면 전문적인 표현과 어려운 개념으로 버무린 글이 대단해 보일 수는 있다. 하지만 대단해보인다고 해서 반드시 설득되는것은 아니다. 읽고 이해도 못하는 글에 설득되었다고 선뜻 말할 사람이 어디있겠는가? 또한 사람들을 설득하기 위해서는 이해하기 쉬울뿐 아니라 주장이 간결해야한다. 말하고자 하는 바를 확실히 표현할때 문장이 길어지면 주어와 서술어를 찾기 어려워 논점이 흐려질 가능성이 있다.&lt;/p&gt;
&lt;p&gt;쉽게 쉽게 쓰자. 어려운 개념이 반드시 필요하다면 가능한 간결하게 단문을 사용하자. 블로그는 내 생각을 정리하고 사람들과 공감하기 위한 도구다. 블로그를 쓰려는 목적이 글을 잘쓴다고 자랑하려는 것도 아니고(사실, 정말 글을 잘써서 자랑 좀 하고 싶다) 굳이 길고 어렵게 쓸 필요가 없다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[양서는 누가 판단하는가? <돈과 시간에서 자유로운 인생 1인 기업>]]></title><description><![CDATA[최근, <돈과 시간에서 자유로운 인생 1 인 기업>이란 책을 읽었다. yes24 평점으로 6 점 정도 되는 책이다. 결코 높은 점수는 아니다. 나는 보통 8 점 이상되면 읽어볼 만하다고 생각하고 책을 선택한다. 그런데 7 점도 아닌…]]></description><link>https://blueshw.github.io/2018/06/24/what_is_good_book/</link><guid isPermaLink="false">https://blueshw.github.io/2018/06/24/what_is_good_book/</guid><pubDate>Sun, 24 Jun 2018 23:03:45 GMT</pubDate><content:encoded>&lt;p&gt;최근, &amp;#x3C;돈과 시간에서 자유로운 인생 1 인 기업&gt;이란 책을 읽었다. yes24 평점으로 6 점 정도 되는 책이다. 결코 높은 점수는 아니다. 나는 보통 8 점 이상되면 읽어볼 만하다고 생각하고 책을 선택한다. 그런데 7 점도 아닌 6 점대라니… 종이책을 직접 구매한것은 아니고 전자책으로 구입했다. 구입 당시 평점은 전혀 몰랐다. 최근 내 관심사 중 하나가 1 인 기업이라 제목에 이끌려 선택한 것 뿐이다.&lt;/p&gt;
&lt;p&gt;처음 몇 챕터를 읽었다. 평이 낮은 이유가 뭔지 대충 느낌이 왔다. 우선 1 인 기업이 무엇이고 왜 1 인 기업을 해야하는지에 대한 반복적인 내용이 너무 많다. 1 인 기업 입문서를 표방하는 책이기에 1 인 기업의 정의와 해야하는 이유를 언급하는건 당연하다. 중복되는 내용이 있더라도 이해할 수 있다. 1 인 기업을 처음 접하는 사람들에게는 여러번 얘기해서라도 그 개념을 이해하도록 돕는것이 중요하기 때문이다. 하지만, 문제는 정의와 이유만 있고 구체적인 사례가 부족하다는 것이다. 간단하게나마 어떤 사람이 이렇게 성공했더라는 식의 내용은 있지만, 그 사람이 누구고 어떤 과정들을 거쳐서 성공을 거머쥐게 되었는지는 자세히 언급하지 않는다(몇 가지 전략이 등장하지만 결코 구체적이지는 않다). 저자가 1 인 기업을 부르짖기에는 근거가 부족하다 느끼는 사람이 많을수 밖에 없을것 같았다(그래서 저자가 ‘실전편’을 별도로 집필했는지도 모른다).&lt;/p&gt;
&lt;p&gt;저자(두명이다) 중 한명은 네이버카페와 같은 플랫폼을 만들어 1 인 기업으로 성공할 발판을 만들어야 한다고 주장한다. 특정 관심을 가진 사람들이 의견을 나누고 정보를 공유하는 공간을 만들자는 것이다. 충분한 회원을 모집하면 본인이 하려던 사업에 도움이 되는건 분명하다. 이미 검증된 사람들이 모여 있는 공간이기에 홍보하기에는 최적의 장소가 아니겠는가? 저자 본인 또한 네이버에 1 인 기업 관련 카페를 개설하고 수만명의 가입자를 보유하고 있다. 저자 자신이 책속에서 얘기한걸 직접 실천하고 있으니 말로만 끝나는 사람은 아니라고 생각할 수 있다. 하지만 반복해서 본인이 만든 카페를 언급하는것은 자칫 책 자체가 하나의 홍보 수단으로만 비춰질수도 있다.&lt;/p&gt;
&lt;p&gt;앞서 책에 대한 사람들의 평이 낮은 이유를 살펴봤는데 그럼 이 책은 읽을만 한가? 섣불리 대답하긴 힘들다. 최소한 나는 다른 사람들이 느끼는 것보다는 많은 도움되었다. 월급의 안락함에 빠져 더이상 자신을 단련하지 않는 인생은 살고싶진 않았다. 월급이란게 언제 끝날지도 모르고 그 끝을 내가 정할 수 있는것도 아니기 때문에 결코 리스크가 낮은것은 아니다. 그렇다고 거창하게 사람을 모으로 투자를 받아 사업을 하는것은 리스크가 너무 크다. 작게 시작할 수 있고, 투자금이 거의 들지 않으며(책에서도 자주 언급한다), 실패하더라도 본업으로 어렵지 않게 돌아올 수 있는 작은 형태의 사업을 하고 싶었다(지금도 하고 싶다). 저자가 말하는 1 인 기업이 이런 조건들에 가장 적합한 형태의 기업이다.&lt;/p&gt;
&lt;p&gt;이 책을 내 인생 책이라고 할 수는 없지만 읽어볼 가치는 있었다. 내가 1 인 기업가의 마인드를 다지고 삶의 방향을 정하는데 충분한 도움이 되었기 때문이다. 책이란 모두에게 양서일수는 없다. 누군가에게는 형편없을지 몰라도 다른 누군가에게는 희망과 힘을 주면 그들에게는 양서가 된다. 중요한 것은 내가 어떤 상태에서 어떤 마음가짐으로 읽느냐에 달렸다. 책이란 것이 하루아침에 뚝딱하고 만들어지는 것은 아니다. 저자의 오랜시간 축적된 경험을 바탕이 있어야 비로소 쓰여잔다(사실, 아닌 책도 많다). 그러니 사람들의 평이 안좋다 해서 애초에 읽기를 포기하는 우를 범하지는 않아야 한다. 만약 제목만 보고(혹은 누군가의 추천으로) 책에 관심이 생겼다면 최소한 목차와 한 챕터 이상은 읽어보고 스스로 판단하도록 하자.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[왜 사람들은 더이상 월드컵에 열광하지 않는가?]]></title><description><![CDATA[…]]></description><link>https://blueshw.github.io/2018/06/24/no_more_worldcup/</link><guid isPermaLink="false">https://blueshw.github.io/2018/06/24/no_more_worldcup/</guid><pubDate>Sun, 24 Jun 2018 03:16:16 GMT</pubDate><content:encoded>&lt;p&gt;오늘은 러시아 월드컵 본선, 대한민국과 맥시코의 경기가 있는 날이다(경기 시청 후 추가로 쓰는데, 졌다…). 스웨덴과의 첫번째 경기에서 이렇다할 공격을 보여주지 못했던 터라 큰 기대는 하지 않는다. 그래도 대한민국이라고 혹시나 하는 마음에 밤잠을 줄이고 시청할 생각이다. 16 강에 진출할 수 있을지 없을지는 모른다. 아마 안될꺼다. 운 좋게 멕시코를 이기더라도 다음 상대는 독일이다. 독일에게 최소한 비겨야 16 강을 생각할 수 있는데, 비기는 것 또한 만만치 않을 것 같다. 설령, 대한민국이 16 강에 오르지 못하더라도 결과와 상관없이 4 년간 열심히 준비해온 선수들에게 박수를 보내야 마땅하다고 생각한다.&lt;/p&gt;
&lt;p&gt;나는 소위 말하는 월드컵 학번이다. 2002 년에 대학생 새내기로 입학했다. 원래 축구를 좋아하는(엄밀히 즐겨했던) 편이라 1 학년 1 학기는 축제 같은 기간이었다. 한국과 일본에서 열리는 월드컵이었기 때문에 교수님들도 한국 경기가 있는 날은 강의를 쉬고 함께 응원하기도 했다. 만약, 내가 몇살만 더 많았더라면(특히 졸업반이었다면), 그때처럼 즐기지는 못했을게 분명하다. 학점 관리도 해야하고, 취업 준비도 해야하고, 영어점수 및 각종 자격증 공부에 마음이 편했을리 없다.&lt;/p&gt;
&lt;p&gt;그 이후로 여러번의 월드컵이 열렸다. 2006 년 독일 월드컵, 2010 년 남아공 월드컵, 2014 년 브라질 월드컵이 있었고 지금은 2018 년 러시아 월드컵이 한창 진행중이다. 나도 20 살이었던 2002 년을 지나 4 번의 월드컵을 거쳐 36 살의 청춘의 끝자락에 도달했다. 내가 나이를 먹어서인지 모르겠지만, 시간이 지날수록 월드컵에 대한 관심은 줄어들었다. 나만 그렇게 느끼는지 몰라도 사회 전반적으로 월드컵에 대한 관심이 많이 줄어든것 처럼 보인다. 예전에는 한국의 경기 뿐 아니라 축구 강국의 경기를 챙겨보고 친구끼리 누가 이길지 내기도 하는 등 주변 모두가 많은 관심을 보였다. 하지만, 지금은 한국의 경기 조차도 크게 관심이 없는 사람들이 더 많다.&lt;/p&gt;
&lt;p&gt;서형욱 축구해설위원(유튜브 링크)이 얘기했듯이 국가 단위의 스포츠가 점점 인기가 없어지는 것은 비단 우리나라 뿐만이 아니다. 20 세기는 수많은 전쟁과 분쟁으로 민족주의, 국가주의가 주류 이데올로기였다. 월드컵 같은 국가간 스포츠 경기는 애국심을 고취시키는데 아주 적절한 이벤트였다. 국가 대항전의 종합 이벤트인 월드컵이 인기가 있었던건 당연했다. 그러나 21 세기로 넘어오면서 전쟁이 많이 사라졌고 국가간의 왕래도 자연스럽고 빈번해졌다. 애국심으로 국가 대항전을 응원하기 보다는 자신이 좋아하는 선수가 뛰는 클럽에 더 관심을 가진다. 기업들마저 국가간 스포츠 보다는 선수 개인 또는 클럽에 더 관심이 많다.&lt;/p&gt;
&lt;p&gt;개인화도 이유가 될 수 있다. 요즘 사람들은 국가의 문제보다는 개인의 문제를 훨씬 중요시한다. 청년실업률이 높아 취직이 힘든 젊은이들은 스포츠 경기보다는 다음날 있을 시험이나 면접이 훨씬 중요하다. 어렵게 대기업에 취직 하더라도 생각과 다른 직장생활에 방황하는 친구들은 자신에게 맞는 삶의 방향을 찾기위해 고군분투 한다. 100 살 시대에 앞으로 50 년은 더 살아야할 50 대 가장에게 어쩌면 월드컵은 사치일지도 모른다. 조금이라도 더 나은 대학에 입학하기 위해 하루에도 몇개의 학원을 다녀야 하는 청소년들도 마찬가지다.&lt;/p&gt;
&lt;p&gt;월드컵을 위시한 국가 스포츠의 열기가 식어가는 것은 변화하는 세계처럼 당연한 수순이라 생각한다. 국가보다는 클럽이나 개인이 중요해지고, 자본의 흐름도 동일하게 흘러간다. 선수들마저 국가 대항전 보다는 클럽 대항전을 더 중요시 할지도 모른다. 국가 대항전에서 뛰다 부상이라도 당하면 자신의 몸값이 떨어지기 때문이다. 선수들이 예전만큼 열씸히 뛰지 않는것처럼 보인다고 해서(사실 다들 최선을 다해 열심히 뛴다) 그들을 욕할 수는 없다. 국가 대항전에서 부상당해 몸값이 떨어진다해도 국가가 그들에게 아무런 도움을 주지 못하기 때문이다.&lt;/p&gt;
&lt;p&gt;월드컵의 인기가 줄어들고 대회가 사라진다 해서 바뀌는건 없다. 다만 과거의 영광에 사로잡혀 현재를 보지 못하는 우를 범하지 말아야한다. 세상의 변화에 순응하고 받아들이는 태도를 가질 필요가 있다. 그럼 이제, 야구나 보자.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[아두이노(arduino)를 시작해보자]]></title><description><![CDATA[아두이노를 시작하기로 했다. 아두이노(arduino)는 초소형 컴퓨터 기판이다. 기판 자체에 별다른 기능은 없지만, 각종 센서나 기계 등을 연결하여 다양한 작품을 만들수 있다. 가격도 매우 저렴하다. 기본보드(R3) 호환버전이 인터넷에서 600…]]></description><link>https://blueshw.github.io/2018/06/23/start_arduino/</link><guid isPermaLink="false">https://blueshw.github.io/2018/06/23/start_arduino/</guid><pubDate>Sat, 23 Jun 2018 01:33:09 GMT</pubDate><content:encoded>&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/0-a34310960988f4db3d16c1bba87a02e5-3f0b4.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAABAACA//EABYBAQEBAAAAAAAAAAAAAAAAAAACA//aAAwDAQACEAMQAAAB4qOzG0W4/8QAGhABAAIDAQAAAAAAAAAAAAAAAQADAhITEf/aAAgBAQABBQJvBrNnlgTkSnI2T2f/xAAWEQEBAQAAAAAAAAAAAAAAAAABADH/2gAIAQMBAT8ByAv/xAAYEQADAQEAAAAAAAAAAAAAAAAAATECEf/aAAgBAgEBPwGwen0//8QAGxAAAQQDAAAAAAAAAAAAAAAAAAEQESECEjH/2gAIAQEABj8CpJE2aiOZN//EABsQAAMAAgMAAAAAAAAAAAAAAAABESFBMWGh/9oACAEBAAE/IZSQVmG94OIvRVqdwRdLsTKj/9oADAMBAAIAAwAAABCo/wD/xAAXEQADAQAAAAAAAAAAAAAAAAAAESEx/9oACAEDAQE/ELoSp//EABURAQEAAAAAAAAAAAAAAAAAAAEA/9oACAECAQE/EBHDIL//xAAdEAACAgIDAQAAAAAAAAAAAAABEQAhMUFRcZHR/9oACAEBAAE/EKggEFGqGue4DAyhZ4aWpjFdCfVE6ZBRqJ1MAmyCebFL5LkgNKf/2Q==&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;img0&quot;
        title=&quot;&quot;
        src=&quot;/static/0-a34310960988f4db3d16c1bba87a02e5-f8fb9.jpg&quot;
        srcset=&quot;/static/0-a34310960988f4db3d16c1bba87a02e5-e8976.jpg 148w,
/static/0-a34310960988f4db3d16c1bba87a02e5-63df2.jpg 295w,
/static/0-a34310960988f4db3d16c1bba87a02e5-f8fb9.jpg 590w,
/static/0-a34310960988f4db3d16c1bba87a02e5-3f0b4.jpg 820w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;아두이노를 시작하기로 했다. 아두이노(arduino)는 초소형 컴퓨터 기판이다. 기판 자체에 별다른 기능은 없지만, 각종 센서나 기계 등을 연결하여 다양한 작품을 만들수 있다. 가격도 매우 저렴하다. 기본보드(R3) 호환버전이 인터넷에서 6000~7000 원 정도에 판매된다. 정품은 조금 더 비싸지만(2 만원대), 성능상의 차이는 없기 때문에 호환보드로 시작하자.&lt;/p&gt;
&lt;p&gt;LED 불 밝히는 예제를 따라해봤는데 크게 어려운 개념은 없다. 인터넷에는 아두이노와 관련된 수많은 튜토리얼과 예제들이 있다. 마음만 있다면 충분히 독학으로 학습가능하다. 혹시라도 모르는 부분이 생기면 구글에 문의한다(검색하란 뜻이다). 그럼 다 알려준다. 간혹 뭘 모르는지 모를때가 문제긴 하지만…&lt;/p&gt;
&lt;p&gt;얼마전부터 생각해오던 아이디어가 하나 있다. 아직 자세히 말할 단계는 아니지만, 이를 실체화할 도구가 바로 아두이노다. 아두이노와 스마트폰 앱을 연동해서 하나의 상품(또는 서비스)을 만들 계획이다. 상품화 할 수 있을지는 모르겠지만 일단 시작하고 보는거다. 될지 안될지 고민하다보면 안될 이유만 잔뜩 생긴다. ‘누가 먼저 만들었다더라’, ‘아무도 사지 않을거다’, ‘돈벌이가 안될것 같다’ 등 안될 이유는 수없이 많이 찾을 수 있다. 처음부터 완벽할 필요는 없다. 완성도가 형편없더라도 내가 처음 생각했던 아이디어를 구현해보는게 중요하다. 완성도는 초기작에서 드러나는 문제를 고치다보면 자연스레 높아진다.&lt;/p&gt;
&lt;p&gt;개인프로젝트를 진행할때는 시간관리가 정말 중요하다. 특히 나처럼 처자식이 있으면 시간관리는 필수다. 주먹구구식으로 진행하다보면, 시간이 갈수록 열정은 식어간다. 하루 중 특정 시간을 정해두는것이 좋다. 아침이든 밤늦게든 항상 같은 시간에 진행하면 좋다. Trello 같은 TODO 도구를 사용하는 것도 좋은 방법이다. 전체를 한번에 완성하기는 힘들기 때문에 프로젝트를 여러개 일로 나눠서 각각에 데드라인을 부여한다. 한번에 완성하는게 어려운 이유는 해야할 일이 너무 많고 얼마나 오래 걸릴지 알 수 없어 막연하게 느껴지기 때문이다. 반면에, 일을 쪼개면 해야할 일과 끝내는데 필요한 시간이 어느정도인지 가늠하기 쉽다. 당연히 후자가 성공 확률이 높다.&lt;/p&gt;
&lt;p&gt;누구나 현실이 만족스럽지 않거나 어떤 변화가 필요하다 느낄때가 있다. 여러 이유(돈, 가족, 명예 등등)가 있겠지만, 대부분은 현실의 벽에 부딪혀 타협하고 현실을 받아들인다. 문제는 이런식의 해결책은 임시방편에 불과하다는 것이다. 언제든지 재발(?)하여 우울함과 허무함이 다시 나를 지배할지 모른다. 자신의 삶은 진정으로 바꾸고 싶다면 지금껏 해온 일이 아닌 새로운 것에 도전해볼 필요가 있다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[나의 루틴(Routine)]]></title><description><![CDATA[지난밤에 늦게 잠든 탓일까? 온 몸이 찌뿌둥하다. 언제나 최후의 1 분까지 잠을 청하는 습관 때문에 출근시간 4…]]></description><link>https://blueshw.github.io/2018/06/22/my_routine/</link><guid isPermaLink="false">https://blueshw.github.io/2018/06/22/my_routine/</guid><pubDate>Fri, 22 Jun 2018 02:03:54 GMT</pubDate><content:encoded>&lt;p&gt;지난밤에 늦게 잠든 탓일까? 온 몸이 찌뿌둥하다. 언제나 최후의 1 분까지 잠을 청하는 습관 때문에 출근시간 40 분 전에야 겨우 눈을 뜬다. 새벽동안 분비된 내 체취로 꿉꿉해진 이불에서 퀘퀘한 냄새가 은근히 전해진다. 방문에 설치한 철재 안전문 넘어로 고양이의 신경질적인 울음소리가 들려온다. 밥이 없거나 물이 없거나 화장실은 안치워준 탓이겠지. 10 년 넘게 함께 살아온 녀석이지만 어렸을적의 귀여움은 사라진지 오래다. 오래된 연인같다.&lt;/p&gt;
&lt;p&gt;십수년간 거의 매일 아침은 씨리얼로 해결한다. 밥을 먹기 귀찮아서라기 보다는 우유와 과자를 좋아하기 때문에 먹는것 같다. 어느순간부터 지금껏 먹던 유전자 변형 옥수수로 만들어진 씨리얼을 그만 먹어야겠다는 생각이 들었다. 30 대 중반을 넘어서면서 하나둘 찾아오는 건강 이상 신호를 무시할 용기가 부족해서인가보다. 최근에는 독일에서 수입한 귀리 베이스의 씨리얼을 먹기 시작했다. 맛도 나쁘지 않다. 그리고 튀긴 유전자 옥수수 보다는 훨씬 건강에 좋을것 같다. 정말인지는 잘 모른다.&lt;/p&gt;
&lt;p&gt;와이프와 아이는 아직도 자고 있다. 둘 다 아침잠이 많다. 나도 아침잠이 많지만 출근을 해야하는 입장이다 보니 먼저 일어날 수 밖에 없다. 기계적으로 수염을 깎고 샤워를 한다. 대충 옷을 입고 머리를 매만진다. 예전에는 옷차림에 나름 신경을 썼지만, 이 마저도 30 대 중반에게는 사치로 느껴진다. 마지막으로 옷을 샀던게 언제였더라…&lt;/p&gt;
&lt;p&gt;불어가는 몸뚱아리에 죄의식이 느껴져 일부로 좀 걷는다. 집에서 지하철역까지 10 분, 지하철에서 내려서 회사까지 10 분, 하루에 2 번하면 총 40 분을 걷는다. 10 분에 1km 를 걷고 보폭은 90cm 정도 되니까 대충 1100 걸음이다. 40 분을 꼬박 걸으면 4400 걸음은 걷는다. 정말 건강에 도움이 되는지는 모르겠다. 아마 이정도로는 한참 부족할 것이다. 하루 평균 40Km 를 걸어서 여행했을때 한달동안 5kg 정도 살이 빠졌었는데… 어림도 없다.&lt;/p&gt;
&lt;p&gt;지금은 웹 프로그래머로 일하고 있다. 만족스러운 편이다. 무엇보다도 사람이 주는 스트레스가 거의 없다. 야근도 거의 없다. 점수로 매기면 10 점 만점에 8 점은 줄 수 있다. 대한민국 직장인의 만족도가 얼만지는 잘 모르겠지만, 아마도 8 점에 한참 못미칠거라 생각한다(3~4 점이 아닐까 추측해본다). 원래부터 프로그래머는 아니었다. 건축을 공부했고 건축에 뜻이 있었다. 현실의 벽을 넘지 못해서 그만두었다는건 핑계고 진짜 문제는 (지난 글에서 말한것 처럼) 끈기 부족이 확실하다. 서른이 되기 직전, 설계사무소를 그만두고 잠시 방황하다 컴퓨터 프로그래밍을 배우기 시작했다. 프로그래머로 자리잡는데는 꽤나 많은 난관이 있었고, 보통 이상의 노력이 필요했다. 몇번이나 그만두고 싶은 욕구가 있었지만, 잘 참아냈다. 그 결과 평범한 수준보다 약간 떨어지는 정도의 프로그래머로 잘 살아가는 중이다.&lt;/p&gt;
&lt;p&gt;끈기 부족 병이 도진건지 프로그래머로 성공하고싶은 마음이 없는건지 모르겠지만, 자꾸 딴 생각을 하게된다. 1 인 기업가로 독립해볼까? 부동산 서비스를 개발해볼까? 아니면 꾸준한 글쓰기로 작가로 데뷔해볼까? 모두 순탄하지 않은 길이다. 장담하건데 적당히 실력있는 프로그래머 되기보다는 분명 어려울 것이다. 하루에도 몇번씩 그 생각을 하면서 퇴근하는 지하철에서 책을 읽는다. 책을 읽는 중간에 간간히 프로야구 경기 결과를 확인한다. 광적인 팬은 아니지만, 어렸을때부터 좋아하던 구단이 경기에서 이기면 기분이 좋다.&lt;/p&gt;
&lt;p&gt;출근시간이 늦다보니, 퇴근시간도 늦다. 저녁 8 시는 되야 집에 도착한다. 맞다. 집도 멀다. 판교 난민의 대표적인 케이스가 바로 나다. 판교나 분당에 살기에는 돈이 없다. 적당한 가격의 집을 찾아서 아래로 아래로 내려오다 보니 여기(용인 or 수원)까지 왔다. 살아보니 여기도 나쁘지 않다.&lt;/p&gt;
&lt;p&gt;저녁은 다 같이 먹는다. 딸 아이와 사이가 좋아 식사후에는 같이 시간을 보낸다(TV 보여줄때가 더 많을지도..). 딸이 커가는 모습을 보고 있으면, 정말 행복하다고 느낀다. 몇 년 지나고 훌쩍 커버리면 나와 놀아주지도 않을거 뻔히 알지만, 그래도 너무 사랑스럽다. 11 시쯤 되야 딸 아이가 잠에 빠져든다.&lt;/p&gt;
&lt;p&gt;스스로에게 투자할 수 있는 유일한 시간이 왔다. 게임을 하거나 TV 를 시청하는걸로 시간을 보내기에는 너무 아깝다. 프로그래밍 공부를 하기도 하고, 책을 읽기도 한다. 또는 와이프와 대화하면서 맥주한잔 마실때도 있다. 좀 더 생산적인 일로 루틴을 만들고 싶지만, 체력이 발목을 잡는다. 운동을 해야하는걸까… 에라이, 모르겠다. 그냥 자야겠다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[형편없는 나의 끈기에 대하여]]></title><description><![CDATA[며칠전, 잠깐이나마 회사동료였던 분이 암에 걸렸다는 소식을 들었다. 4 기란다. 누구나 암에 걸릴 수 있다. 30 대라고 해서 예외없다. 태어난지 얼마 안된 갓난쟁이도 소아암에 걸리는 일이 다반사인데 3…]]></description><link>https://blueshw.github.io/2018/06/21/about_my_poor_patience/</link><guid isPermaLink="false">https://blueshw.github.io/2018/06/21/about_my_poor_patience/</guid><pubDate>Thu, 21 Jun 2018 01:39:42 GMT</pubDate><content:encoded>&lt;p&gt;며칠전, 잠깐이나마 회사동료였던 분이 암에 걸렸다는 소식을 들었다. 4 기란다. 누구나 암에 걸릴 수 있다. 30 대라고 해서 예외없다. 태어난지 얼마 안된 갓난쟁이도 소아암에 걸리는 일이 다반사인데 30 대 후반정도면 암에 걸리는게 흔해빠진 일일지도 모른다(요즘 세상이 그렇다). 그럼에도 이 사실은 내 마음속에 큰 울림을 가져왔다. 한번이라도 얼굴을 보고 인사를 해본 사람이기 때문일까? 모르겠다.&lt;/p&gt;
&lt;p&gt;지금까지 나는 만족할 만큼 나 자신을 혹독하게 단련한적이 없다. 한마디로 끈기가 없었다. 작심삼일은 기본이고 뭐 하나에 빠져본적도 없다. 그럴듯한 취미가 없는것도 이 때문일 것이다. 게임을 해도 금방 지루해지고, 운동을 해도 재미가 없다. 사회생활한지 10 년이 채 안됐지만 벌써 직종도 한번 바꼈다. 그나마 유일하게 꾸준하다고 할만한 것은 한달에 서너권 정도 책을 읽는 정도다. 만족스러운 수준은 아니다. 손정의는 간염으로 3 년간 병상에 누워 지내면서 3,000 여권의 책을 읽었다고 한다. 하루에 3 권 정도 읽으면 3,000 권쯤 된다. 나처럼 한달에 서너권 읽어서 총 3,000 권을 읽으려면 70 년쯤 걸린다. 지금 내 나이부터 시작해도 100 살이 넘는 나이가 되야 3000 권을 읽을 수 있다. 100 살이라니.&lt;/p&gt;
&lt;p&gt;글쓰기에 대한 책을 몇권 읽고 있다. 유시민의 &amp;#x3C;글쓰기 특강&gt;, 김민식 PD 의 &amp;#x3C;매일 아침 써봤니?&gt;, 김애리의 &amp;#x3C;글쓰기가 필요하지 않은 인생은 없다&gt;를 읽었고, 지금은 서민 교수의 &amp;#x3C;서민적 글쓰기&gt;를 읽는 중이다. 모두가 좋은 책이다. 조금씩은 다른 관점을 가진 책이지만 좋은 글을 쓰는 방법은 모두 비슷하게 말한다. 다독(多讀), 다작(多作), 다상량(多商量), 많이 읽고 많이 쓰고 많이 생각하는 것이다.&lt;/p&gt;
&lt;p&gt;나는 지금껏 남과 비교하고 남을 따라가려는 삶을 살아온것 같다. 대학교에서 건축을 공부할때는 과에서 가장 뛰어나다는 사람처럼 공부해서 멋진 집을 짓는 건축가가 되고 싶었다. 강연을 듣고 책을 볼때면 이 사람처럼 되고 싶다는 생각에 빠져들었다. 프로그래밍을 배우는 지금은 뛰어난 개발자들이 해온 방식을 모방해왔다. 하지만, 남의 삶을 모방하고 남이 성공한 방법만을 차용하려는 태도가 오히려 내 끈기를 갉아먹었다. 방식이 잘못된 것은 아니다. 이미 성공한 사람들의 검증된 방법이기 때문에 성공확률이 높다. 하지만, 자기다움이 없는 상태로 아무리 남의것을 따라한들 잘될리가 없다. 자기다움을 찾는 일이 먼저다.&lt;/p&gt;
&lt;p&gt;내 삶을 개선하기 위해서 매일 글을 쓰기로 다짐했지만(주 5 일이면 좋겠다), 이것 역시 위에서 소개한 글쓰기 책에서 소개한 방법이다. 그럼에도 이를 선택하기로 한것은 ‘쓰기’라는 행위에 대한 믿음 때문이다. 쓰기, 특히 나에대한 쓰기는 반드시 자아성찰을 동반한다. 나의 과거, 현재, 미래, 내가 좋아하는것, 내가 싫어하는것, 나의 신념, 이런 주제들로 글을 쓰다보면 자연스럽게 내 자신에게 되물을수 밖에 없다. 처음에는 작가들의 에세이 처럼 잘 쓸 필요도 없다. 일기를 쓰듯 자연스럽고 부담없이 쓰면된다.&lt;/p&gt;
&lt;p&gt;꾸준한 글쓰기를 시도하는게 처음은 아니다. 이전에도 블로그를 통해 몇번이고 시도했지만 번번히 실패하고 말았다. how(방법)가 잘못된것은 아니었다. what(무엇)이 잘못되어서 실패한것이라 생각한다. 블로그를 시작할때 언제나 어떤 분야의 전문적인 글을 쓰기를 원했다. 그리고 이미 성공한 사람들처럼 되고 싶었고, 그들의 수준만큼 쓰고 싶었다. 하나의 글을 쓰기위해 여러 책을 읽고 자료를 찾고 분석하는 작업에
몇시간을 투자했다. 하나의 글이 완성되기까지 많은 시간이 소요 되었고, 글쓰는 습관이 들기는 커녕 점점 지쳐서 포기하기 일수였다.&lt;/p&gt;
&lt;p&gt;조금 내려놓고 생각하기로 했다. 글을 잘쓰고 싶은 욕구는 더 커졌지만, 급하게 생각하지 않기로 했다. 3 년간만 써볼 생각이다. 우선은 자신에대한 글을 쓰면서 자기다움을 찾는게 먼저다. 남들이 이뤄논 멋있어 보이는 삶이 아니라 내가 정말 좋아하는 일로 가득한 삶이면 좋겠다. 지금의 쓰기가 그런 삶으로 이끌어주길 바란다. 나도 언제든 지독한 병에 걸려 시한부 선고를 받을 수 있다. 내 인생에서 남은 시간이 얼마나 될지는 아무도 모른다. 그래서 더더욱 남을 모방하는 삶을 살고 싶지는 않다. 오롯이 나를 위한 삶을 살고 싶다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[리액트(react)에서 이벤트 버블링(bubbling)과 캡쳐링(capturing) 사용하기]]></title><description><![CDATA[이벤트 버블링 / 캡쳐링 특정 DOM 노드에서 발생한 이벤트는 부모 또는 자식으로 전파됩니다. 자기자신(currentTarget)에서 부모로 전파되면 이벤트 버블링(event bubbling…]]></description><link>https://blueshw.github.io/2018/04/23/event-bubbling-capturing/</link><guid isPermaLink="false">https://blueshw.github.io/2018/04/23/event-bubbling-capturing/</guid><pubDate>Mon, 23 Apr 2018 01:38:51 GMT</pubDate><content:encoded>&lt;h3&gt;이벤트 버블링 / 캡쳐링&lt;/h3&gt;
&lt;p&gt;특정 DOM 노드에서 발생한 이벤트는 부모 또는 자식으로 전파됩니다. 자기자신(currentTarget)에서 부모로 전파되면 이벤트 버블링(event bubbling)이라 하고, 부모에서 자기 자신으로 전파되면 이벤트 캡쳐링(event capturing)이라 합니다. 이벤트가 발생하면 우선 window 부터 target node 까지 이벤트 캡쳐링합니다&lt;code class=&quot;language-text&quot;&gt;(capture phase(1))&lt;/code&gt;. 그 다음 타켓 노드에 이벤트가 발생&lt;code class=&quot;language-text&quot;&gt;(target phase(2))&lt;/code&gt;하고 마지막으로 이벤트를 한단계씩 상위로 버블링&lt;code class=&quot;language-text&quot;&gt;(bubbling phase(3))&lt;/code&gt;합니다. (이미지 출처: www.w3.org)&lt;/p&gt;
&lt;p&gt;
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 87.59455370650531%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsSAAALEgHS3X78AAADEklEQVQ4y42US28aVxiG+SeVuu6i60pdVIq66L79Fe0urpJFq3oRqVJSyVUT1e0mvaRqayWOLzjYAdsxDhhjmMExN5uBgGEwDIO5jLkMHvz0MMSOL1jpkc6cb2a+88z7fueccTCinZyc2F1c0IpFYrEYiUSClKKgVctnOaOa41rgIGjUUZNJ1n0+lpeX2dmJIishOlb7WqjjHOWCOvuuXqfs97Gy9gL34iLrL72UmgeYlvlu4JnNQdzvD/mGQTOXY1PaxuvfYjseJVmKXsm/1vJA1xl0cGkd0dndY2JVYdyVYioU5aD2+v8Bz6vrh4L0w2GoVullMsy+jPBwaRNJyVE9Kr0ty3lXb8aRlvtSGOv5c2G5Saegcn8pwp1ZmalAiPyhMnIRR1s+98KOeiamWOU5KcujQJZAeh+tUaDda9MyWxx1jXcofLPa9qKc1jBf4OFKhIm5IM6QjG4ciDrm+d03iXfXfXFniH61hmLsn8IF2BSbetIV4s6TAO7tXdRaxs57radpdJpXyuW4DBu2Pr22QUds7IqS5mkgwb8bKRbDEqnSnrCtYzQ0TLMu9mTLFnA633EZph31mH+l8jScRT00oN2CZl3Yb4gu4kyOSjzFQlLnyVYWOT9QevgWeFnyvm7ww7MI95xh0qpmP7OE9eOOyXGlKqBVqlqJB2tx7s7JzEte9Nb+VYWDSXuqzrocR9MqlMoa61IcpVjFsnPEcdtX8AYKTM9EiEYyKKooQyDIrlrBPLaGNTwF1ltdJrw5bs9G8adKBLI1bol4Yi1NQUBfyeD5S+HDD3y8/16G219HiFTKfONMcteTIlfSLwJ74gsu/w6/Tq9SrNQoaDV+fryCezOGZVl4POAPgleKMjnlIS8AlZph5z/z7dA1e0PgwOqgrcoKn43PcOM7JzcfzPHlTwt8Or7Ax2N/C+jwhyDv5fj8eydf3HPz1Y+zjP2yyCffzvPR2D9Mr8oXFbY6XVwbMX5b2CAhTkQqX+YPV5CZFxL1hmHndLomnq0kf7o2kRMZssUKj5a2eLwcQj+s2zn/AWGpM+DiZmccAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;event&quot;
        title=&quot;&quot;
        src=&quot;/static/event-137b0f890dd0d1d21a6c40b0aeafe49a-fb8a0.png&quot;
        srcset=&quot;/static/event-137b0f890dd0d1d21a6c40b0aeafe49a-1a291.png 148w,
/static/event-137b0f890dd0d1d21a6c40b0aeafe49a-2bc4a.png 295w,
/static/event-137b0f890dd0d1d21a6c40b0aeafe49a-fb8a0.png 590w,
/static/event-137b0f890dd0d1d21a6c40b0aeafe49a-3ecf6.png 661w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  &lt;/p&gt;
&lt;p&gt;이벤트 발생 시점이 다르기 때문에 이벤트 핸들러를 &lt;code class=&quot;language-text&quot;&gt;binding&lt;/code&gt;할때 주의가 필요합니다. 보통은 아래처럼 작성합니다. 세번째 인자가 없거나 &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt;면 버블링, &lt;code class=&quot;language-text&quot;&gt;true&lt;/code&gt;면 캡쳐링시에 이벤트가 발생합니다. target 노드는 바인딩 방식과는 상관없이 캡쳐링이 끝나면 이벤트가 발생합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// event bubbling
element.addEventListener(&amp;#39;click&amp;#39;, handler);

// event capturing
element.addEventListener(&amp;#39;click&amp;#39;, handler, true);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;모바일에서 가운데 영역을 터치하면 메뉴가 나타나거나 사라지고 좌우를 클릭하면 페이지가 좌우로 이동하는 기능이 있다고 가정합니다. 메뉴가 켜져 있으면 상단에 세개 버튼이 노출됩니다.&lt;/p&gt;
&lt;p&gt;
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 65.84415584415585%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsSAAALEgHS3X78AAABY0lEQVQ4y6WSPU7EMBCF9zhcgTtQUdEi0VFTQYmQOAcSHSVCS0OHWIkD0G2JtLtkk82PEyfjh9+wBu9fkMDSk8fO+PPMcwbOObRtC2utzuvivoioKisovGwnMLZD04rK+L2260DWAH4URYG6rjGfz1FVlUIYG2NQlhXE1ngvgeNhhdNhgsMHh/07h4N7p/HercPVq3iSYEAqD3LkeY7O3xRird6v28bgw6dcjhpcj3JcjICTJ+DsGTh/AY4egZu3CMiqOBaLhbYZYsK5Nr56T8fPcGuCwmjLBjBUGANph/g8CstZfChR3MkWINukf9xjrPf6JFrCvS9hM17mKTA8ymw203k6nWI8HitwMpkgSZLvl3bLtl3UfohXgKyQ7RFSlqVWlGWZgpqm0ZZDVb8C+zxkAtd/BrLCba/8L2D8H/ZVGGvDQ/rGg/SNnvFDmqY7Pdw2VoA8xIcIIiBe87JQbZ944SdyGPK79qdVDwAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;mobile&quot;
        title=&quot;&quot;
        src=&quot;/static/mobile-df1f9994100d0a8207c624d44049ed75-fb8a0.png&quot;
        srcset=&quot;/static/mobile-df1f9994100d0a8207c624d44049ed75-1a291.png 148w,
/static/mobile-df1f9994100d0a8207c624d44049ed75-2bc4a.png 295w,
/static/mobile-df1f9994100d0a8207c624d44049ed75-fb8a0.png 590w,
/static/mobile-df1f9994100d0a8207c624d44049ed75-24603.png 770w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  &lt;/p&gt;
&lt;p&gt;가운데 영역을 터치해서 메뉴가 오픈된 상태에서 왼쪽 버튼을 터치합니다. 이 영역은 페이지를 좌측으로 이동하는 영역과 겹쳐있습니다. 터치이벤트가 발생하면 좌측 페이지로 이동하는 이벤트와 &lt;code class=&quot;language-text&quot;&gt;홈&lt;/code&gt; 버튼의 터치 이벤트가 발생합니다. 일반적으로 전체 영역(window or document)은 홈버튼의 부모 노드입니다. 이 때 전체영역과 홈버튼의 이벤트를 어떻게 바인딩(캡쳐링 or 버블링)했냐에 따라 이벤트 발생 순서는 완전히 바뀝니다. 일반적으로 세번째 인자를 쓰지 않고(or false) 바인딩하면, &lt;code class=&quot;language-text&quot;&gt;bubbling&lt;/code&gt; 시점에 이벤트가 발생합니다. target 노드인 leftButton 의 이벤트가 먼저 발생합니다. 그 후에 이벤트가 부모로 버블링되면서 window 의 click 이벤트가 발생합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;window.addEventListener(&amp;#39;click&amp;#39;, clickHandler);
leftButton.addEventListener(&amp;#39;click&amp;#39;, clickBtnHandler);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;반대로 아래처럼 &lt;code class=&quot;language-text&quot;&gt;capturing&lt;/code&gt; 방식으로 바인딩했다면 최상위 노드가 가장먼저 실행됩니다. 즉, window 의 이벤트가 가장 먼저 발생합니다. 이 후 이벤트가 캡쳐링되면서 target 노드인 leftButton 의 &lt;code class=&quot;language-text&quot;&gt;click&lt;/code&gt; 이벤트가 발생합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;window.addEventListener(&amp;#39;click&amp;#39;, clickHandler, true);
leftButton.addEventListener(&amp;#39;click&amp;#39;, clickBtnHandler, true);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;react 에서 이벤트 버블링 / 캡쳐링 사용하기&lt;/h3&gt;
&lt;p&gt;리액트에서 이벤트 버블링과 캡쳐링 사용은 어렵지 않습니다. click 이벤트의 경우에는 &lt;code class=&quot;language-text&quot;&gt;onClick&lt;/code&gt;은 버블링, &lt;code class=&quot;language-text&quot;&gt;onClickCapture&lt;/code&gt;는 캡쳐링을 사용합니다.&lt;/p&gt;
&lt;p&gt;위에서 보았던 예제를 바탕으로 이벤트 캡쳐링/버블링 테스트를 위해 아래처럼 코드를 입력합니다. 코드에서 사용한 &lt;code class=&quot;language-text&quot;&gt;onClick&lt;/code&gt; 속성은 버블링 방식으로 이벤트를 바인딩하기 때문에 자기자신의 이벤트가 먼저 발생하고 부모로 이벤트를 전파합니다. 우선 가운데 영역을 클릭해 상단 메뉴를 열어줍니다. 그리고 왼쪽의 &lt;code class=&quot;language-text&quot;&gt;HOME&lt;/code&gt; 버튼을 클릭합니다. 각 노드의 이벤트가 bubbling 방식으로 동작하기 때문에 &lt;code class=&quot;language-text&quot;&gt;home&lt;/code&gt;이 먼저 출력되고 &lt;code class=&quot;language-text&quot;&gt;left&lt;/code&gt;가 출력됩니다.&lt;/p&gt;
&lt;h4&gt;이벤트 bubbling&lt;/h4&gt;
&lt;p data-height=&quot;450&quot; data-theme-id=&quot;0&quot; data-slug-hash=&quot;QrjmBG&quot; data-default-tab=&quot;js,result&quot; data-user=&quot;blueshw&quot; data-embed-version=&quot;2&quot; data-pen-title=&quot;event bubbling  in react&quot; class=&quot;codepen&quot;&gt;See the Pen &lt;a href=&quot;https://codepen.io/blueshw/pen/QrjmBG/&quot;&gt;event bubbling  in react&lt;/a&gt; by Hyunwoo Seo (&lt;a href=&quot;https://codepen.io/blueshw&quot;&gt;@blueshw&lt;/a&gt;) on &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;.&lt;/p&gt;
&lt;script async src=&quot;https://static.codepen.io/assets/embed/ei.js&quot;&gt;&lt;/script&gt;
&lt;h4&gt;이벤트 capturing&lt;/h4&gt;
&lt;p&gt;이번에는 캡쳐링을 살펴보겠습니다. 이벤트 캡쳐링과 버블링을 비교하기 위해 &lt;code class=&quot;language-text&quot;&gt;menuBox&lt;/code&gt;에 이벤트를 추가합니다. background 와 home 버튼은 &lt;code class=&quot;language-text&quot;&gt;onClickCapture&lt;/code&gt;로 바인딩(캡쳐링)하고, menuBox 에는 &lt;code class=&quot;language-text&quot;&gt;onClick&lt;/code&gt;으로 바인딩(버블링)합니다. 위에서 이벤트가 발생하는 순서는 &lt;code class=&quot;language-text&quot;&gt;캡쳐링 -&amp;gt; 타겟노드 -&amp;gt; 버블링&lt;/code&gt;이므로 가장먼저 &lt;code class=&quot;language-text&quot;&gt;left&lt;/code&gt;가 출력됩니다. 그 다음은 타켓노드의 이벤트가 발생해서 &lt;code class=&quot;language-text&quot;&gt;home&lt;/code&gt;이 출력됩니다. 타켓노드 이후에 이벤트가 버블링 되고 menuBox 에 &lt;code class=&quot;language-text&quot;&gt;click menu&lt;/code&gt;가 출력됩니다.&lt;/p&gt;
&lt;p data-height=&quot;450&quot; data-theme-id=&quot;0&quot; data-slug-hash=&quot;pVjLmW&quot; data-default-tab=&quot;js,result&quot; data-user=&quot;blueshw&quot; data-embed-version=&quot;2&quot; data-pen-title=&quot;event capturing in react&quot; class=&quot;codepen&quot;&gt;See the Pen &lt;a href=&quot;https://codepen.io/blueshw/pen/pVjLmW/&quot;&gt;event capturing in react&lt;/a&gt; by Hyunwoo Seo (&lt;a href=&quot;https://codepen.io/blueshw&quot;&gt;@blueshw&lt;/a&gt;) on &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;.&lt;/p&gt;
&lt;script async src=&quot;https://static.codepen.io/assets/embed/ei.js&quot;&gt;&lt;/script&gt;
&lt;h4&gt;정리&lt;/h4&gt;
&lt;p&gt;이벤트는 &lt;code class=&quot;language-text&quot;&gt;캡처링 -&amp;gt; 타겟노드 -&amp;gt; 버블링&lt;/code&gt;의 순서로 발생합니다. 캡처링은 가장 상위(window)에서 먼저 이벤트가 발생하고 자식으로 한단계씩 전파합니다. 타켓노드까지 이벤트가 전파된 후에는 반대로 한단계씩 부모로 전파됩니다. 각 노드에서 바인딩(binding)된 이벤트 핸들러가 capture 방식이라면 이벤트 캡쳐링시에 실행되고, 반대로 bubbling 방식이라면 이벤트 버블링시에 실행됩니다. target 노드에 바인딩된 핸들러는 capture 의 사용 유무와 상관없이 이벤트 캡쳐가 끝나면 실행됩니다.&lt;/p&gt;
&lt;h3&gt;참고자료&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.w3.org/TR/DOM-Level-3-Events/#dom-event-architecture&quot;&gt;https://www.w3.org/TR/DOM-Level-3-Events/#dom-event-architecture&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[[nextjs] nextjs는 어떻게 동작하는가?]]></title><description><![CDATA[nextjs 로 프로젝트를 진행한지도 반년 가까이 흘렀습니다.  nextjs 는 서버사이드렌더링(SSR)과 code splitting 등을 지원하는 reactjs 전용 프레임워크입니다. 2 년도 채 안되는 시간에 벌써 5.x(곧 버전…]]></description><link>https://blueshw.github.io/2018/04/15/why-nextjs/</link><guid isPermaLink="false">https://blueshw.github.io/2018/04/15/why-nextjs/</guid><pubDate>Sun, 15 Apr 2018 16:33:24 GMT</pubDate><content:encoded>&lt;p&gt;nextjs 로 프로젝트를 진행한지도 반년 가까이 흘렀습니다. &lt;a href=&quot;https://github.com/zeit/next.js/&quot;&gt;nextjs&lt;/a&gt;는 서버사이드렌더링(SSR)과 code splitting 등을 지원하는 reactjs 전용 프레임워크입니다. 2 년도 채 안되는 시간에 벌써 5.x(곧 버전 6 도 나올것 같네요) 버전까지 등장했습니다. 그만큼 많은 사람들의 관심속에 발전하고 있다는 뜻이겠죠. 사용법은 충분히 익숙해졌지만, 시간에 쫓기고 일정에 쫓기다보니 nextjs 가 동작하는 방식에대한 이해는 부족하다 느껴집니다. nextjs 가 reactjs 코드를 어떻게 빌드하고, SSR 은 어떤 과정을 거치며 브라우저에서 어떻게 동작하는지 살펴보도록 하겠습니다.&lt;/p&gt;
&lt;p&gt;우선 프로젝트를 생성합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;mkdir why-next
cd why-next
npm init
npm install --save next react react-dom&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그리고 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt;파일에 다음의 스크립트를 추가합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;{
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;dev&amp;quot;: &amp;quot;next&amp;quot;,
    &amp;quot;build&amp;quot;: &amp;quot;next build&amp;quot;,
    &amp;quot;start&amp;quot;: &amp;quot;next start&amp;quot;
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;프로젝트 생성은 여기서 끝입니다. 이 후에는 페이지(pages 폴더에)를 만들어 실행하면 됩니다.&lt;/p&gt;
&lt;h3&gt;nextjs 의 빌드과정&lt;/h3&gt;
&lt;p&gt;nextjs 를 사용하기 위해서 반드시 따라야 할 규칙이 있습니다. pages 폴더(없다면 만들어야함)에 라우팅 url 과 동일한 이름의 컴포넌트를 생성해야 합니다. pages 컴포넌트가 next 라우팅과 동일하게 mapping 되기 때문에 이 규칙은 반드시 지켜야합니다. 예를들어 url 이 &lt;code class=&quot;language-text&quot;&gt;/first&lt;/code&gt;이라면 &lt;code class=&quot;language-text&quot;&gt;pages/first.jsx&lt;/code&gt; 파일을 만들어야합니다. 테스트를 위해 pages/index.jsx 와 pages/second.jsx 파일을 생성합니다.&lt;/p&gt;
&lt;h4&gt;pages/index.jsx&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import Link from &amp;quot;next/link&amp;quot;;

export default () =&amp;gt; (
  &amp;lt;div&amp;gt;
    &amp;lt;h1&amp;gt;Index Page&amp;lt;/h1&amp;gt;
    &amp;lt;Link href=&amp;quot;/second&amp;quot;&amp;gt;
      &amp;lt;a&amp;gt;second2&amp;lt;/a&amp;gt;
    &amp;lt;/Link&amp;gt;
  &amp;lt;/div&amp;gt;
);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;pages/second.jsx&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;export default () =&amp;gt; &amp;lt;h1&amp;gt;Second Page&amp;lt;/h1&amp;gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그 다음 실행합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;npm run dev (dev 환경)
npm run build &amp;amp;&amp;amp; npm start (production 환경)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 명령은 package.json 에 &lt;code class=&quot;language-text&quot;&gt;next&lt;/code&gt;라는 명령어를 실행하는 npm 커맨드입니다. 빌드가 진행되고 서버를 실행합니다. 빌드는 아래의 항목을 포함합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;자동 코드 트래스파일(babel) 및 번들링(webpack)&lt;/li&gt;
&lt;li&gt;hot code reloading&lt;/li&gt;
&lt;li&gt;서버렌더링 및 pages 폴더의 indexing&lt;/li&gt;
&lt;li&gt;./static/ 폴더의 리소스의 /static path 접근&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;빌드가 완료되면, 프로젝트에 &lt;code class=&quot;language-text&quot;&gt;.next&lt;/code&gt; 폴더가 생성됩니다. &lt;code class=&quot;language-text&quot;&gt;.next&lt;/code&gt; 폴더 구조는 다음과 같습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# .map 파일 제외
.next/                    # 빌드 root 디렉토리
  bundles/
    pages/
      _error.js
      (index.js)          # production 환경에서 생성
      (second.js)         # production 환경에서 생성
  dist/                   # 실제 렌더링 되는 파일들이 담긴 폴더
    bundles/
      pages/
        _document.js
        _error.js
        (index.js)          # production 환경에서 생성
        (second.js)         # production 환경에서 생성
  main.js                 # 번들된 javascript 파일
  manifest.js&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;아직 서버에서 실행할 page 자바스크립트가 만들어지지 않았습니다. 이 경우에 모든 렌더링 관련 코드는 main.js 에 포함됩니다. 이는 dev 환경일때만 해당되는 것으로 라우팅 될 때마다 필요한 페이지를 생성합니다. production 환경에서는 page 코드를 미리 준비합니다. 더 빠른 초기 렌더링이 가능하기 때문입니다. dev 환경에서는 빠른 빌드가 주 목적이기 때문에 미리 page 를 생성하지 않습니다. 반면에 production 환경에서는 초기 렌더링을 빠르게 하는것이 주 목적이기 때문에 page 코드를 미리 생성합니다.&lt;/p&gt;
&lt;p&gt;브라우저를 열고 &lt;code class=&quot;language-text&quot;&gt;localhost:3000/&lt;/code&gt;를 입력합니다. 다음과 같은 화면이 출력됩니다.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/index-faa3f167219e54017debe5dac62c1eb6-b5303.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 264px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 40.53030303030303%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAAA80lEQVQoz62QX0vCcBSG901Tr73oYsMrvbavkJ+hbUIX0kUQFaRFkJlRUMKUVabt92Puj7rtyQ0SgmkgvfDenMN5z3OOwg5KkmRjT/l4f+P65pbp5JPOVZuHXh/btvE8n4vzM46MJlLKrDYaDhFCrkPzgpXnp0dqtSr1gzoVtcJ+uYyqqui6iWkaHDYaaJpGca9AoVjCaB5ng3Ec5wfOwxDHcVb+wrKsjCS1EIIgCLLBwevLaoFO976H67rbCf/9h8vFEm/mE/ghM+kRzhfr7T9OKaMo+nXmRsLxaMpl647OaZ/2SZfJ2P2TYpuUvDN2DUv1DeX1X/VmrBMAAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;index&quot;
        title=&quot;&quot;
        src=&quot;/static/index-faa3f167219e54017debe5dac62c1eb6-b5303.png&quot;
        srcset=&quot;/static/index-faa3f167219e54017debe5dac62c1eb6-e716a.png 148w,
/static/index-faa3f167219e54017debe5dac62c1eb6-b5303.png 264w&quot;
        sizes=&quot;(max-width: 264px) 100vw, 264px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;폴더 구조를 다시 보면, .next 폴더 안에 bundles/page/index.js 와 dist/bundles/page/index.js 가 만들어진것을 확인할 수 있습니다.
그리고 url 을 입력할때마다 &lt;code class=&quot;language-text&quot;&gt;.next&lt;/code&gt; 폴더에 &lt;code class=&quot;language-text&quot;&gt;0.[hash].hot-update.js&lt;/code&gt;와 같은 파일이 생성됩니다. 이는 page 코드를 만들때(서버든 클라이언트든) 동적으로 생성되는 js 파일입니다. dev 에만 해당되는 내용으로 production 환경에서는 생성되지 않습니다.&lt;/p&gt;
&lt;h3&gt;SSR 은 어떤 과정을 거치나?&lt;/h3&gt;
&lt;p&gt;SSR 은 말그대로 서버에서 렌더링을 한다는 것입니다. 10 여년전에 많이 유행했던 PHP 나 JSP 가 대표적인 서버렌더링 프레임워크입니다. 유저가 어떤 url 로 데이터를 요청하면 서버는 미리 html 파일을 만들어 클라이언트(브라우저)에게 전달하는 방식입니다. next 에서 SSR 도 크게 다르지 않습니다. 서버(node)를 띄우고 유저가 요청하면 html 을 생성하여 브라우저에 전달합니다. 구조는 동일합니다. 다른점이 있다면, 모든 요청에 대해 서버에서 렌더링을 진행하지는 않고 초기 렌더링만 서버가 담당합니다. 그 이후에는 &lt;code class=&quot;language-text&quot;&gt;next/router&lt;/code&gt;를 이용하여 클라이언트에서 렌더링합니다. next 가 해주는 일은 이게 전부입니다. 간단하지만, 이 방식으로 SPA 의 단점으로 꼽히는 긴 초기 렌더링 시간을 대폭 줄일 수 있습니다.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/ssr-cd5af43df60eb4c52cbab1e9cf87d71a-945ba.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 570px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 115.43859649122807%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAYAAAALHW+jAAAACXBIWXMAAAsSAAALEgHS3X78AAADLElEQVQ4y5WVXWgUVxTH96VFKEKflFLQBw1KKNS3UqH6ok/FhyB+INgiFUFKS0VfVFQEoQ/65oOiLkbwKylSKNTSqlgENW1ikpq4cfZrsrObrPnYbDb7NTN35v68M7ub7Ca7xp7lv/funTP/87/nnnM34EgIzUj+m0ZB0j8p/dH77a07jgApkG4dpItnUkosy5qfexYo2NB2S7LiMnzSKdnULfn0Bnx4SbLhNmQr71Jxr59LhBCkUqlGQtOBc31w7KnkRA+c+Vdyskdy9Jla/2eO3OhVRPIyVvIadvIqduIiItePF8e0S0sJabCajqosKwb3lcvvCo/Xwp8fwK9qHjs/75YeSzcSeqPTAJU3t0I4W05y/UU7wb71BF9s5Hp/O5196wiG99I5cYFLxkkG9d4Kt8qrR+oTLoZbTfqEPc6+yFZ2hzcrfMk30e0ciH3NrpHP2RtqZ8fgGv4O3/d9HdepELLIvMWafNs10YtD6KUFxIsvGS2HSNoRooVhxiaTDe8vIaylUjac6yJTG5idyqENhYmEI+h6nFKp1FphbcxmsyRTBrawFYf6SMcPVCjmicVj6KM6CSOBYRik02lclftAZYuODxS8/Lne4aivceU0MvIa27aXpKOVBZoVDU22W09UI26GgNdGshjDzYdAJTmTz6DNQjgL8azAMsu+cum13zxcP2RzQpHHevQxxcfr4MlH/Nx9nNU34bMuyfpgntRUqb7Umypu2LJ0yohXh7BCR9Rt8C2/9XRx8AkcfQ4//jWFMRSE6XvY412IN7/gpO8gC1pL0hY5dCqqZqNM3VYufyg8XAUPVmLdCyAip6qEoonCJqcsqq03kUlw5UEb3QNt3Olr565qw8nwMcgNVnPovlvhfN1WHceyBrt6NvN9YieHYx3s0b5As/Sqj1i+bGp5WSBM8N3zrzgc3cIP2jZ6cw+V+pLf8K1q8t0KZwx+6u3gdHI/Z/UDzIlsw/PlC3tR5EKxgDETZ1qkmbEnEXL5jmnZy95/RTQaZXoiQy4zt3Bp/K/Wq4tslk3y+Tym6hTTMhGOeK9+DrS6aTx1AwMDaJrG8PCwf/O8D+Fb8Vi28wAVTqsAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;ssr&quot;
        title=&quot;&quot;
        src=&quot;/static/ssr-cd5af43df60eb4c52cbab1e9cf87d71a-945ba.png&quot;
        srcset=&quot;/static/ssr-cd5af43df60eb4c52cbab1e9cf87d71a-98b2c.png 148w,
/static/ssr-cd5af43df60eb4c52cbab1e9cf87d71a-5f8e6.png 295w,
/static/ssr-cd5af43df60eb4c52cbab1e9cf87d71a-945ba.png 570w&quot;
        sizes=&quot;(max-width: 570px) 100vw, 570px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;h3&gt;어떤 과정으로 실행되는가?&lt;/h3&gt;
&lt;p&gt;위 코드를 바탕으로 실행과정을 단계별로 나눠보겠습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;유저가 브라우저에 &lt;code class=&quot;language-text&quot;&gt;/index&lt;/code&gt;를 입력합니다.&lt;/li&gt;
&lt;li&gt;미리 실행되고 있는 node 서버가 요청을 받고 서버렌더링을 합니다.&lt;/li&gt;
&lt;li&gt;만들어진 html 을 브라우저에게 보냅니다.&lt;/li&gt;
&lt;li&gt;브라우저가 응답받은 html 을 그립니다.&lt;/li&gt;
&lt;li&gt;html 에 기능을 부여할 &lt;code class=&quot;language-text&quot;&gt;main.js&lt;/code&gt;파일을 다운로드 받습니다. (라우팅 될 페이지 코드도 함께 번들링되어 있습니다.)&lt;/li&gt;
&lt;li&gt;다운로드가 완료되고 &lt;code class=&quot;language-text&quot;&gt;go to second&lt;/code&gt; 링크를 클릭합니다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;/second&lt;/code&gt;로 라우팅하고 second 페이지 코드를 생성합니다. (production 에서는 미리 만들어진 코드를 사용합니다.)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;dev 환경에서는 2 번과 7 번에서 서버렌더링 코드가 만들어져 있지 않기 때문에 렌더링하는데 어느정도 시간이 소요됩니다. 하지만 production 환경에서는 미리 모든 페이지의 코드를 만들어두기 때문에 초기 렌더링 시간이 절약됩니다.&lt;/p&gt;
&lt;h3&gt;결론&lt;/h3&gt;
&lt;p&gt;SSR 이 간단한 개념이지만, 이해하기는 쉽지 않습니다. 개념은 간단하지만 효율적으로 구현하기 위한 기반기술이 많기 때문이라 생각합니다. 사용법만 익혀도 nextjs 프로젝트를 진행하는데 큰 어려움은 없습니다. 하지만 SSR 관련해서 다양한 이슈가 발생했을때 대처하기 위해서는 next 의 동작배경을 잘 알고 있어야 합니다. 초반에 글을 쓸 때는 next 내부 코드를 살펴보며 세밀한 동작 원리를 설명하고 싶었습니다. 코드를 살펴볼수록 이해하는 시간이 길어지고 담을 내용이 많아지는 것 같아 이정도로 마무리하려고 합니다. 잠깐씩 언급했던 세부적인 next 기반 기술은 앞으로 주제를 정해 하나씩 다룰 생각입니다. 잘못 알고 있는 내용이 있다면 지적 부탁드립니다.&lt;/p&gt;
&lt;h3&gt;참고자료&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/zeit/next.js/issues/1217&quot;&gt;https://github.com/zeit/next.js/issues/1217&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.codementor.io/tgreco/5-of-the-many-things-to-love-about-zeit-s-next-js-bpszu99g1&quot;&gt;https://www.codementor.io/tgreco/5-of-the-many-things-to-love-about-zeit-s-next-js-bpszu99g1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.slideshare.net/dotPKG/nextjs-a-javascript-framework-for-building-next-generation-spa&quot;&gt;https://www.slideshare.net/dotPKG/nextjs-a-javascript-framework-for-building-next-generation-spa&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[[react] v16.3.0, 무엇이 바뀌었나?]]></title><description><![CDATA[react v16.3.0 이 릴리즈 되었습니다. 개인적인 생각으로는 가장 큰 변화는 두가지 정도입니다. 첫번째는 몇몇 lifecycle method 가 deprecated 되었습니다. 그리고 새로운 Context API…]]></description><link>https://blueshw.github.io/2018/04/05/react-v16-3-0/</link><guid isPermaLink="false">https://blueshw.github.io/2018/04/05/react-v16-3-0/</guid><pubDate>Thu, 05 Apr 2018 01:22:35 GMT</pubDate><content:encoded>&lt;p&gt;react v16.3.0 이 릴리즈 되었습니다. 개인적인 생각으로는 가장 큰 변화는 두가지 정도입니다. 첫번째는 몇몇 lifecycle method 가 deprecated 되었습니다. 그리고 새로운 Context API 가 추가되었습니다. 그 외에 몇가지 변화를 요약해보면 아래와 같습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;새로운 Context API&lt;/li&gt;
&lt;li&gt;새로운 Refs API&lt;/li&gt;
&lt;li&gt;lifecycle 메서드 변경&lt;/li&gt;
&lt;li&gt;새로운 Strict mode&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;자세한 사항은 &lt;a href=&quot;https://reactjs.org/blog/2018/03/29/react-v-16-3.html&quot;&gt;공식사이트 포스트&lt;/a&gt;를 참조하세요.&lt;/p&gt;
&lt;h2&gt;Context API&lt;/h2&gt;
&lt;p&gt;간단히 말해서 Context 는 앱 전체에 공통으로 사용할 데이터를 담는 역할을 합니다. 저는 개발하면서 한번도 사용해본적은 없습니다만, react-redux, react-router 등의 react 관련 핵심 라이브러리에서 Context 가 사용되고 있습니다. 리덕스를 사용하고 있다면 아래와 같은 코드 조각을 본적이 있을 것입니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;Provider store={store}&amp;gt;
  &amp;lt;App /&amp;gt;
&amp;lt;/Provider&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;react-router 의 경우에는 브라우저 history 관리등을 위해 Context 를 사용하고 있습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;this.props.history.push(&amp;#39;/list&amp;#39;);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;props 로 하위 컴포넌트에 데이터를 넘기는 전통적인 방식은 간단한 어플리케이션 개발에는 아무런 문제가 없습니다. 하지만 어플리케이션이 복잡해지고 하위 컴포넌트의 단계가 많아질수록 이런식의 상태 관리는 개발난이도가 높아질뿐 아니라 유지보수 측면에서도 문제를 야기할 수 있습니다. 이럴때 Context 는 하나의 대안이 될 수 있습니다.&lt;/p&gt;
&lt;p&gt;이전 버전의 react 에도 Context API 가 있었습니다. 다만, 공식적인 API 라기보다는 실험적인 수준이었기 때문에 사용을 권장하지 않았습니다. 이번 v16.3.0 버전에서 공식적으로 &lt;code class=&quot;language-text&quot;&gt;Context API&lt;/code&gt;가 발표되었기 때문에 지금까지 Context 가 어떻게 쓰였고 앞으로 어떤 방식으로 사용 가능할지 알아볼 필요가 있겠습니다.&lt;/p&gt;
&lt;h3&gt;기존 Context API&lt;/h3&gt;
&lt;p&gt;실험적인 방법이라고하지만, 주요한 라이브러리에는 이미 context 를 사용하고 있습니다.&lt;/p&gt;
&lt;h4&gt;App.jsx&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;export default class App extends Component {
  render() {
    return (
      &amp;lt;OldProvider userId=&amp;quot;bono&amp;quot; nickName=&amp;quot;보노&amp;quot;&amp;gt;
        &amp;lt;OldConsumer /&amp;gt;
      &amp;lt;/OldProvider&amp;gt;
    );
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;OldProvider.jsx&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;OldProvider&lt;/code&gt;에서 context 데이터를 미리 만들어줍니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;export default class OldProvider extends Component {
  static childContextTypes = {
    userId: PropTypes.string,
    nickName: PropTypes.string
  };
  getChildContext = () =&amp;gt; {
    return {
      userId: this.props.userId,
      nickName: this.props.nickName
    };
  };
  render() {
    return &amp;lt;div&amp;gt;{this.props.children}&amp;lt;/div&amp;gt;;
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;OldConsumer.jsx&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Provider&lt;/code&gt;로 감싸진 컴포넌트 어디에서든 &lt;code class=&quot;language-text&quot;&gt;this.context&lt;/code&gt;로 context 데이터에 접근이 가능합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;export default class OldConsumer extends Component {
  render() {
    const { userId, nickName } = this.context;
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;h1&amp;gt;{userId}&amp;lt;/h1&amp;gt;
        &amp;lt;h2&amp;gt;{nickName}&amp;lt;/h2&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;new Context API&lt;/h3&gt;
&lt;p&gt;위의 기능을 새로 발표된 Context API 를 사용하여 구현합니다. 파일 개수가 하나더 증가했습니다. 하지만 생성, 공급, 소비와 같이 관심사가 확실하게 분리되기 때문에 훨씬더 구조적인 모습입니다.&lt;/p&gt;
&lt;h4&gt;App.jsx&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;export default class App extends Component {
  render() {
    return (
      &amp;lt;Provider userId=&amp;quot;bono&amp;quot; nickName=&amp;quot;보노&amp;quot;&amp;gt;
        &amp;lt;Consumer /&amp;gt;
      &amp;lt;/Provider&amp;gt;
    );
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Context.jsx&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Provider&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;Consumer&lt;/code&gt;에서 공통으로 Context 객체를 사용하기 위해 Context.tsx 를 별도로 생성합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;export default React.createContext();&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Provider.jsx&lt;/h4&gt;
&lt;p&gt;Context 객체에 데이터를 넣어주는 역할을 합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;export default class Provider extends Component {
  render() {
    return (
      &amp;lt;Context.Provider value={this.props}&amp;gt;
        {this.props.children}
      &amp;lt;/Context.Provider&amp;gt;
    );
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Consumer.jsx&lt;/h4&gt;
&lt;p&gt;Context 의 데이터를 사용하는 부분입니다. 좀 특이한 것은 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;Context.Consumer&amp;gt;&lt;/code&gt; 컴포넌트 바로 아래가 React Element 를 리턴하는 함수 형태로 되어 있다는 것입니다. 이는 &lt;a href=&quot;https://reactjs.org/docs/render-props.html&quot;&gt;Render Props&lt;/a&gt;라는 패턴입니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;export default class Consumer extends Component {
  render() {
    return (
      &amp;lt;Context.Consumer&amp;gt;
        {value =&amp;gt; (
          &amp;lt;div&amp;gt;
            &amp;lt;h1&amp;gt;{value.userId}&amp;lt;/h1&amp;gt;
            &amp;lt;h2&amp;gt;{value.nickName}&amp;lt;/h2&amp;gt;
          &amp;lt;/div&amp;gt;
        )}
      &amp;lt;/Context.Consumer&amp;gt;
    );
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Consumer 에서 context 를 사용할때마다 Render Props 패턴으로 context 의 데이터를 가져와야하는 부분이 거슬리는데, 이는 &lt;code class=&quot;language-text&quot;&gt;HOC&lt;/code&gt;를 이용해 context 의 value 를 prop 으로 가져오도록 구현하면 됩니다(자세한 구현은 생략).&lt;/p&gt;
&lt;p&gt;Context API 를 사용한 위 두가지 방법은 각각 아래와 같은 형태로 출력됩니다.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/context-916e1dc1af2887386c004b096a5ee574-67fb6.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 307px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 33.22475570032573%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsSAAALEgHS3X78AAAAfElEQVQoz6WROwqAMBBEc37tREREvYwi+IP0qZNOtE0wGY1fsFyn2p3iMTvLsEtrDWMMrLV+hXMOVLE0yxGGAYqiRBQnOFGODGX9MIJzDiEE2rbDFZEO/BoeRD94B07zcgy+v3V9OyQnTNIcVd080D8POYBKSkilfie7tQEr5CPC6zxGogAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;context&quot;
        title=&quot;&quot;
        src=&quot;/static/context-916e1dc1af2887386c004b096a5ee574-67fb6.png&quot;
        srcset=&quot;/static/context-916e1dc1af2887386c004b096a5ee574-ee8a1.png 148w,
/static/context-916e1dc1af2887386c004b096a5ee574-b8043.png 295w,
/static/context-916e1dc1af2887386c004b096a5ee574-67fb6.png 307w&quot;
        sizes=&quot;(max-width: 307px) 100vw, 307px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;h2&gt;Refs API&lt;/h2&gt;
&lt;p&gt;ref 는 reference 의 줄임말로, 특정 컴포넌트를 참조합니다. 컴포넌트를 참조하기 때문에 컴포넌트 내의 변수나 상태, 메서드를 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;그 동안 Ref 사용시 &lt;a href=&quot;https://github.com/facebook/react/issues/1373&quot;&gt;몇가지 문제점&lt;/a&gt;이 있었는데, 이를 해결하기위해 새로운 Ref API 가 나왔습니다. 역시 이전의 ref 사용법과 비교해 보겠습니다.&lt;/p&gt;
&lt;h3&gt;old Ref&lt;/h3&gt;
&lt;p&gt;기존의 ref 는 string 형태로 정의합니다(아마 string 형태로 정의하는게 여러 문제를 야기하지 않았을까 추측해봅니다). ref 의 대상이 되는 컴포넌트에 ref 속성을 만들고 텍스트로 이름을 만들어줍니다. 그리고 &lt;code class=&quot;language-text&quot;&gt;this.refs.xxx&lt;/code&gt;와 같이 사용하면 됩니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;export default class OldRef extends Component {
  componentDidMount() {
    this.refs.oldRef.focus();
  }
  render() {
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;span&amp;gt;oldRef: &amp;lt;/span&amp;gt;
        &amp;lt;input type=&amp;quot;text&amp;quot; ref=&amp;quot;oldRef&amp;quot; /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;new Ref&lt;/h3&gt;
&lt;p&gt;공식문서의 예제와 동일한 형태입니다. 위의 OldRef 와 비교해보면, 우선 ref 가 string 에서 &lt;code class=&quot;language-text&quot;&gt;객체형태&lt;/code&gt;로 바꼈습니다. 그리고 &lt;code class=&quot;language-text&quot;&gt;createRef()&lt;/code&gt; 함수로 ref 를 만든 다음 실제 타겟 컴포넌트의 ref 속성에 해당 객체를 할당합니다. ref 를 사용할때는 생성자함수에서 만들어둔 &lt;code class=&quot;language-text&quot;&gt;this.inputRef&lt;/code&gt;를 그대로 이용합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;export default class NewRef extends Component {
  constructor(props) {
    super(props);
    this.inputRef = React.createRef();
  }
  componentDidMount() {
    this.inputRef.current.focus();
  }

  render() {
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;span&amp;gt;newRef: &amp;lt;/span&amp;gt;
        &amp;lt;input type=&amp;quot;text&amp;quot; ref={this.inputRef} /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;새로 만들어진 ref API 에 한가지 한계가 있는데 HOC 로 만들어진 컴포넌트의 속성에 &lt;code class=&quot;language-text&quot;&gt;ref&lt;/code&gt;가 있으면 리턴되는 컴포넌트에서 이 ref 를 가져오지 못합니다. 이 문제를 해결하기 위해서는 HOC 내부에서 &lt;code class=&quot;language-text&quot;&gt;forwardRedRef&lt;/code&gt;를 이용하면 리턴되는 컴포넌트에 무사히 전달할 수 있습니다. 자주 사용할 것 같지 않은 API 이므로(나만 그런가..) 코드설명 없이 넘어가겠습니다.&lt;/p&gt;
&lt;h2&gt;lifecycle 메서드&lt;/h2&gt;
&lt;p&gt;그 동안 &lt;code class=&quot;language-text&quot;&gt;will&lt;/code&gt; 관련 메서드가 deprecated 될것이라는 말이 비공식적으로 여러번 나왔습니다. 새로운 버전에서 드디어 이 말이 현실이 됐습니다. &lt;code class=&quot;language-text&quot;&gt;componentWillUnMount&lt;/code&gt;를 제외한 나머지 will 메서드들이 공식적으로 deprecated 되었으며, 기존 메서드를 사용하기 위해서는 &lt;code class=&quot;language-text&quot;&gt;UNSAFE_&lt;/code&gt; prefix 를 붙여줘야합니다. (ex. UNSAFE_componentWillMount, ㅎㄷㄷ) 쓰지 말라는 얘기죠.&lt;/p&gt;
&lt;p&gt;그리고 두가지 새로운 메서드가 나왔습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://reactjs.org/docs/react-component.html#static-getderivedstatefromprops&quot;&gt;getDerivedStateFromProps&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://reactjs.org/docs/react-component.html#getsnapshotbeforeupdate&quot;&gt;getSnapshotBeforeUpdate&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;getDerivedStateFromProps&lt;/code&gt;는 componentWillReceiveProps 의 대안으로 사용할 수 있는 메서드입니다. 다만 차이가 있다면, 첫째로는 메서드 이름에서 알 수 있듯이 &lt;code class=&quot;language-text&quot;&gt;return&lt;/code&gt; 값이 존재(해야만)한다는 것이고, 또 static 메서드라는 점입니다. 이 메서드를 사용할때는 반드시(should) update 된 state 를 리턴해주어야합니다. 그리고 static 이기 때문에 &lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt; 키워드를 사용할 수 없습니다. 그래서 componentWillReceiveProps 의 완전한 대체제라고 말하기 어렵습니다. 만약 기존에 사용하던 componentWillReceiveProps 메서드에 &lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;가 사용되고 있다면, getDerivedStateFromProps 가 아닌 &lt;code class=&quot;language-text&quot;&gt;componentDidUpdate&lt;/code&gt;를 대신 사용해야할 것입니다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;getSnapshotBeforeUpdate&lt;/code&gt;는 가장 최근에 렌더링된 결과의 상태를 가져옵니다. 공식사이트에서 예를 든것처럼 새로 렌더링 되기전 scroll 상태를 기억하고 있다가 렌더링 된 후에 다시 이전 scroll 위치로 돌아올때 유용하게 사용될 수 있을것 같습니다.&lt;/p&gt;
&lt;h2&gt;정리&lt;/h2&gt;
&lt;p&gt;이번 v16.3.0 에서 가장 큰 부분은 Context API 와 lifecycle 메서드의 변화입니다. Context API 는 react 주요 라이브러리에서 많이 사용되고 있었던 만큼 각 라이브러리에 새로운 Context API 가 적용될 것입니다. 그리고 공식적으로 나온 API 이기 때문에 컴포넌트 depth 가 큰 곳에는 적절히 사용할 수도 있을것 같습니다. lifecycle 메서드는 리액트의 앞으로의 방향인 &lt;a href=&quot;https://www.youtube.com/watch?v=v6iR3Zk4oDY&quot;&gt;Async Mode&lt;/a&gt;에 맞게 재조정된것이라 생각합니다. 여담이지만, react 의 인기가 높은 만큼 변화도 빨라서 지속적인 관심이 없으면 따라가기 벅찰지도 모르겠습니다. 앞으로도 꾸준한 관심이 필요할 것 같습니다.&lt;/p&gt;
&lt;h2&gt;참고자료&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://reactjs.org/blog/2018/03/29/react-v-16-3.html&quot;&gt;https://reactjs.org/blog/2018/03/29/react-v-16-3.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=WhWqy-vxKS8&amp;#x26;t=204s&quot;&gt;https://www.youtube.com/watch?v=WhWqy-vxKS8&amp;#x26;t=204s&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://velopert.com/3606&quot;&gt;https://velopert.com/3606&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=v6iR3Zk4oDY&quot;&gt;https://www.youtube.com/watch?v=v6iR3Zk4oDY&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[[CSS] styled-jsx 버그 보고 경험기 (사실은 stylis js 버그)]]></title><description><![CDATA[CSS 는 일련의 가중치에 따라서 어떤 속성을 우선적으로 적용할 것인지 결정합니다. 우선순위에 대한 정보는 조금만 검색해보면 나오므로 간단히  링크 로 대체합니다. 현재 회사에서는  nextjs (( https://github.com/zeit/next…]]></description><link>https://blueshw.github.io/2018/03/25/priority-css-selector/</link><guid isPermaLink="false">https://blueshw.github.io/2018/03/25/priority-css-selector/</guid><pubDate>Sun, 25 Mar 2018 12:09:41 GMT</pubDate><content:encoded>&lt;p&gt;CSS 는 일련의 가중치에 따라서 어떤 속성을 우선적으로 적용할 것인지 결정합니다. 우선순위에 대한 정보는 조금만 검색해보면 나오므로 간단히 &lt;a href=&quot;https://gist.github.com/mjj2000/5873872&quot;&gt;링크&lt;/a&gt;로 대체합니다.&lt;/p&gt;
&lt;p&gt;현재 회사에서는 [nextjs]((&lt;a href=&quot;https://github.com/zeit/next.js/&quot;&gt;https://github.com/zeit/next.js/&lt;/a&gt;)를 사용한 프로젝트를 진행하고 있습니다. nextjs 는 서버사이드렌더링(SSR)을 지원하는 리액트 전용 프레임워크입니다. &lt;a href=&quot;https://github.com/facebook/create-react-app&quot;&gt;create-react-app&lt;/a&gt;처럼 &lt;code class=&quot;language-text&quot;&gt;non-configuration&lt;/code&gt;을 지향하며 create-react-app 과는 다르게 일부 설정을 수정할 수 있습니다. nextjs 는 내부적으로 다양한 라이브러리들이 사용되고 있는데, react 컴포넌트(jsx)에서 CSS 코드를 작성하기 위해서 &lt;a href=&quot;https://github.com/zeit/styled-jsx&quot;&gt;styled-jsx&lt;/a&gt;를 사용합니다.&lt;/p&gt;
&lt;p&gt;styled-jsx 는 서버와 클라이언트에서 모두 사용가능하고, 컴포넌트별 scope 를 지원합니다. 컴포넌트 scope 를 지원하기 위한 방법으로 &lt;code class=&quot;language-text&quot;&gt;.jsx-xxxxxxxx&lt;/code&gt;과 같은 클래스를 css 정의 요소에 붙여주는데요. 덕분에 대체로 아주 편리하게 사용하고 있었지만, 최근 한 가지 문제점을 발견했습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;div&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;span className=&amp;quot;title&amp;quot;&amp;gt;빨간색으로 나와야 할텐데..&amp;lt;/span&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;style jsx&amp;gt;{`
  div &amp;gt; div &amp;gt; span {
    color: blue;
  }
  .title {
    color: red;
  }
`}&amp;lt;/style&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;span&amp;gt;&lt;/code&gt;의 텍스트에 색상을 입히는 스타일이 두가지가 있습니다. 위쪽은 &lt;code class=&quot;language-text&quot;&gt;div &amp;gt; div &amp;gt; span&lt;/code&gt;처럼 element 의 cascade 형태로 정의하고, 아래쪽은 class 이름으로 정의합니다. class 가 10 점이라고 하면 element 는 개당 1 점이므로 &lt;code class=&quot;language-text&quot;&gt;.title&lt;/code&gt;의 가중치가 높아 &lt;code class=&quot;language-text&quot;&gt;red&lt;/code&gt; 색상의 텍스트가 출력되어야 합니다. 하지만, 결과는 아래와 같았습니다.&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color:blue&quot;&gt;빨간색으로 나와야 할텐데..&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;우리가 익히 알고 있는 css 선택자는 &lt;code class=&quot;language-text&quot;&gt;class&lt;/code&gt;가 &lt;code class=&quot;language-text&quot;&gt;element&lt;/code&gt; 보다 명시도(가중치 또는 우선순위)가 높습니다. 위에서 언급한것처럼 element 가 1 점이라면 class 는 10 점으로 평가되기 때문입니다. 위의 CSS 코드에 점수를 매겨보면, 첫번째 스타일은 3 점이고 두번째 스타일은 10 점이 됩니다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;css&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;specificity(명시도)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;div&gt;div&gt;span&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;0 0 0 3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;.title&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;0 0 1 0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;그런데 styled-jsx(&lt;code class=&quot;language-text&quot;&gt;v2.2.x&lt;/code&gt; 사용)를 통해서 컴파일이 완료되면 실제 명시도는 아래처럼 변경됩니다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;css&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;specificity(명시도)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;div.jsx-1234&gt;div.jsx-1234&gt;span.jsx-1234&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;0 0 3 3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;.title.jsx-1234&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;0 0 2 0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;첫번째 스타일이 두번째 스타일보다 명시도가 높게 변했습니다. 원래 기대했던 것과는 전혀 다른 결과가 나왔네요. 사용법에 문제가 있었던 것인지, 아니면 이미 보고된 버그인지 확인하기 위해 styled-jsx github 페이지의 이슈를 검색해보았지만, 마땅한 버그를 찾을 수 없었습니다. 그래서 제가 &lt;a href=&quot;https://github.com/zeit/styled-jsx/issues/424&quot;&gt;버그&lt;/a&gt; 보고했습니다.&lt;/p&gt;
&lt;p&gt;하루가 지나니 짜잔!!
&lt;code class=&quot;language-text&quot;&gt;bug&lt;/code&gt;로 등록되었습니다!!!&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/bug-d4e3eac6221aaeadf7e575630b53c238-4e9af.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 371px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 15.09433962264151%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAAsSAAALEgHS3X78AAAAmUlEQVQI142OvQ6CMACEeV8HX83BwTgjz4AChfKjaMJSoKVF+CzuJl5yl0u+Gy5Y15XJOv7VOhkfv3mgjUVUL8q6JopC0iQjvqbE8Y0sEwiRk6WCput4XkKm/Y7ueCCpGtp7iywkpe+5KFCqJ1iWxT98o3qFlAXDMDKO+guVUhhjMNpgt93jjj2fsGWBdg7nvXHt3fcD8zzzAe9T46pjT7TZAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;bug&quot;
        title=&quot;&quot;
        src=&quot;/static/bug-d4e3eac6221aaeadf7e575630b53c238-4e9af.png&quot;
        srcset=&quot;/static/bug-d4e3eac6221aaeadf7e575630b53c238-a902c.png 148w,
/static/bug-d4e3eac6221aaeadf7e575630b53c238-e87e8.png 295w,
/static/bug-d4e3eac6221aaeadf7e575630b53c238-4e9af.png 371w&quot;
        sizes=&quot;(max-width: 371px) 100vw, 371px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;쓰레드에 달린 글을 보니 styled-jsx 에서 사용하는 &lt;code class=&quot;language-text&quot;&gt;stylis&lt;/code&gt;가 문제였습니다. stylis 는 컴포넌트별 scope 를 만들기 위해 id, class, element 에 특정 해시(styled-jsx 의 경우 &lt;code class=&quot;language-text&quot;&gt;jsx-1234&lt;/code&gt;)class 를 붙여주는데, 가중치에 상관없이 모든 요소(id, class, element)에 class 를 붙여주다보니 결과적으로 원하지 않는 결과가 나온 것입니다. 이 문제에 대해서 곰곰히 생각해보았더니, 지금처럼 모든 요소에 해시 class 를 붙여줄것이 아니라 각 CSS 선택자마다 하나의 class 만 붙여주면 해결될것 같은 느낌이 들었습니다.&lt;/p&gt;
&lt;p&gt;첫 element 에만 class 를 붙이거나,&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;css&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;specificity(명시도)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;div.jsx-1234&gt;div&gt;span&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;0 0 1 3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;.title.jsx-1234&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;0 0 2 0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;마지막 element 에 class 를 붙이는식으로 처리하는 것입니다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;css&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;specificity(명시도)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;div&gt;div&gt;span.jsx-1234&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;0 0 1 3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;.title.jsx-1234&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;0 0 2 0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;모든 케이스를 고려해 보지 않았지만, 이런 방식으로 처리하면 문제가 해결될 것이라고 생각되어, 제가 보고했던 버그 스레드에 &lt;a href=&quot;https://github.com/zeit/styled-jsx/issues/424#issuecomment-375518440&quot;&gt;댓글&lt;/a&gt;을 달았습니다. 그랬더니, 와!!&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/answer-740aab954b6686ffd971cc5e8e72ce9d-833fe.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 25.39912917271408%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsSAAALEgHS3X78AAAAxElEQVQY05WQyXLEIAxE+f+PTHKIDRKbnRomHrN0JGY7h6qufkKCgjbLsuLj8wt2XfEtbJ0DMSOEgJSyKCHGCCKedc4Z3nvpx9lT+ckZvQ+Ybdtl4H5YOYqXckUfA611Geri7c2zfviTtS+sZ0y5HrAU4DhgsYzVMWLecZH98nv7l46zwpy1IcnLpvKGn0vBWTtqG6L+YPH29qdqH6+541ahd5lt38HMrzzI0cyEiGZuGgezh3P3WrNVjjHBWjtZ+/ptXX9auYA6zlDylQAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;answer&quot;
        title=&quot;&quot;
        src=&quot;/static/answer-740aab954b6686ffd971cc5e8e72ce9d-fb8a0.png&quot;
        srcset=&quot;/static/answer-740aab954b6686ffd971cc5e8e72ce9d-1a291.png 148w,
/static/answer-740aab954b6686ffd971cc5e8e72ce9d-2bc4a.png 295w,
/static/answer-740aab954b6686ffd971cc5e8e72ce9d-fb8a0.png 590w,
/static/answer-740aab954b6686ffd971cc5e8e72ce9d-833fe.png 689w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;이후로 &lt;code class=&quot;language-text&quot;&gt;stylis&lt;/code&gt; &lt;a href=&quot;https://github.com/thysultan/stylis.js/issues/101&quot;&gt;이슈&lt;/a&gt; 에서 해결방안이 활발히 논의되고 있습니다(맨 앞 요소와 맨 뒤 요소에 `jsx-1234 를 붙여주는걸로 가닥을 잡은 것 같습니다). 제가 직접 코드를 기여하지 않았습니다만, 제 의견이 반영되니 묘한 기분이 들더군요. 지금껏 오픈소스에 기여한적이 없었기 때문에 그랬는지도 모르겠습니다. 다들 이 맛에 오픈소스 하는구나라는 생각이 드는 경험이었습니다.&lt;/p&gt;
&lt;h4&gt;참고자료&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://gist.github.com/mjj2000/5873872&quot;&gt;https://gist.github.com/mjj2000/5873872&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/CSS/Specificity&quot;&gt;https://developer.mozilla.org/ko/docs/Web/CSS/Specificity&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[[Jest] mock 함수를 이용하여 함수 호출 테스트 하기]]></title><description><![CDATA[React 프로젝트에서 가장 많이 사용되는 테스트 모듈로  Jest 가 있습니다. react 와 Jest…]]></description><link>https://blueshw.github.io/2018/03/21/function-test-with-jest/</link><guid isPermaLink="false">https://blueshw.github.io/2018/03/21/function-test-with-jest/</guid><pubDate>Wed, 21 Mar 2018 01:19:29 GMT</pubDate><content:encoded>&lt;p&gt;React 프로젝트에서 가장 많이 사용되는 테스트 모듈로 &lt;a href=&quot;https://facebook.github.io/jest/&quot;&gt;Jest&lt;/a&gt;가 있습니다. react 와 Jest 둘 다 페이스북이 만든 오픈소스 프로젝트입니다. 같은 회사에서 만든 오픈소스기 때문에 서로 호환이 잘 될거라는 믿음으로 사용하고 있습니다. 호환성과 무관하게 Jest 를 이용하면 모듈, React DOM 등의 테스트는 무리없이 진행할 수 있습니다. 무설정으로 React 앱을 만들수 있는 일종의 프레임웍인 &lt;a href=&quot;https://github.com/facebook/create-react-app&quot;&gt;create-react-app&lt;/a&gt;(이것 역시 페이스북)에서도 기본적으로 Jest 가 내장되어 있습니다.&lt;/p&gt;
&lt;p&gt;테스트 환경을 위해 create-react-app 으로 app 을 생성합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ create-react-app jest-fn&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;만들어진 react app 의 src 폴더에 아래의 javascript 파일들을 생성합니다.
분기도 필요없고 모듈도 나눌 필요없는 함수지만, 테스트 목적으로 아래와 같이 작성합니다.&lt;/p&gt;
&lt;h4&gt;/src/number.js&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import { justReturn } from &amp;quot;./util&amp;quot;;

export function getFirstNumber(num) {
  if (num &amp;gt;= 10) {
    return returnFirstNum(num);
  } else {
    return justReturn(num);;
  }
}
export function returnFirstNum(num) {
  return num % 10;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;/src/util.js&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;export function justReturn(num) {
  return num;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;테스트 코드를 만듭니다.&lt;/p&gt;
&lt;h4&gt;/src/number.test.js&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import * as util from &amp;#39;./util&amp;#39;;
import * as number from &amp;#39;./number&amp;#39;;

describe(&amp;#39;getFirstNumber&amp;#39;, () =&amp;gt; {
  it (&amp;#39;number === 8&amp;#39;, () =&amp;gt; {
    util.justReturn = jest.fn();
    number.getFirstNumber(8);
    expect(util.justReturn).toBeCalled()
  })
  it (&amp;#39;number === 15&amp;#39;, () =&amp;gt; {
    number.returnFirstNum = jest.fn();
    number.getFirstNumber(15);
    expect(number.returnFirstNum).toBeCalled()
  })
})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;테스트를 실행해봅니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ npm test&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;console 에 아래와 같은 메세지가 출력됩니다. 1 개의 테스트에서 에러가 발생했네요.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt; FAIL  src/number.test.js
  ● getFirstNumber › number === 15
    expect(jest.fn()).toBeCalled()
    Expected mock function to have been called.
    ...

    Test Suites: 1 failed, 1 total
    Tests:       1 failed, 1 passed, 2 total&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;함수의 인자가 &lt;code class=&quot;language-text&quot;&gt;number === 15&lt;/code&gt;일때 발생한 에러입니다. 얼핏 보면 이상할 것 없는 코드인데, &lt;code class=&quot;language-text&quot;&gt;number === 8&lt;/code&gt;일때는 성공했고, &lt;code class=&quot;language-text&quot;&gt;number === 15&lt;/code&gt;일때는 실패했습니다. &lt;code class=&quot;language-text&quot;&gt;getFirstNumber&lt;/code&gt; 함수는 10 이상이냐 10 미만이냐에 따라 분기되고 각 조건절에서 별도의 함수를 호출하고 있습니다. 코드상에서 특별한 문제는 없어 보이는데, 조건절 내부에서 호출되는 함수들이 같은 모듈 내에 있는지 아니면 다른 모듈에서 가져온 함수인지의 차이는 있습니다. 이게 문제일까요? 조금더 깊게 들어가봐야겠습니다.&lt;/p&gt;
&lt;p&gt;babel 사이트를 통해서 위의 코드를 트랜스파일링 해보면 아래와 같습니다.&lt;/p&gt;
&lt;h4&gt;/src/number.js&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;quot;use strict&amp;quot;;

Object.defineProperty(exports, &amp;quot;__esModule&amp;quot;, {
  value: true
});
exports.getFirstNumber = getFirstNumber;
exports.returnFirstNum = returnFirstNum;

var _util = require(&amp;quot;./util&amp;quot;);

function getFirstNumber(num) {
  if (num &amp;gt; 10) {
    return returnFirstNum(num);
  } else {
    return (0, _util.justReturn)(num);
  }
}
function returnFirstNum(num) {
  return num % 10;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;number.js 를 다른 모듈에서 import(require)하면 function 자체를 가져오는 것이 아니라 모듈의 exports 객체를 가져옵니다. 각 모듈은 모두 독립적으로 존재하고 모듈끼리 서로 참조하기 위해서 import, export 키워드(ES6)를 사용합니다. 그렇기 때문에 하나의 모듈에 있는 함수를 다른 모듈에서 가져다 쓸수는 있지만 함수 그 자체를 변형할 수는 없습니다.&lt;/p&gt;
&lt;p&gt;이제 test 코드를 다시 살펴보겠습니다. util 모듈의 &lt;code class=&quot;language-text&quot;&gt;justReturn&lt;/code&gt;에 Jest mock function 을 할당하고 있습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import * as number from &amp;#39;./number&amp;#39;;
...
it (&amp;#39;number === 8&amp;#39;, () =&amp;gt; {
  util.justReturn = jest.fn();  // util.js의 exports.justReturn에 mock 함수 할당
  ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이는 util 모듈의 &lt;code class=&quot;language-text&quot;&gt;justReturn&lt;/code&gt;이라는 함수를 실제로 mock function 으로 변경한게 아닙니다. 단지 util 모듈의 exports 객체의 justReturn 에 &lt;code class=&quot;language-text&quot;&gt;jest.fn()&lt;/code&gt;을 할당한 것입니다. 즉, 이렇게 된 것입니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;exports.justReturn = jest.fn();&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 사실을 바탕으로 잘 생각해보면, 두번째 테스트가 왜 실패했는지 짐작해볼 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import * as number from &amp;#39;./number&amp;#39;;
...
it (&amp;#39;number === 15&amp;#39;, () =&amp;gt; {
  number.returnFirstNum = jest.fn(); // number.js의 exports.returenFirstnum에 mock 함수 할당
  number.getFirstNumber(15); // number.js의 getFirstNumber 호출
  expect(number.returnFirstNum).toBeCalled()
})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;우선 number 모듈의 exports 객체의 returnFirstNum 속성에 mock 함수를 할당합니다. 그리고 &lt;code class=&quot;language-text&quot;&gt;getFirstNumber(15)&lt;/code&gt; 함수를 호출합니다. 이때 getFirstNumber 함수의 인자는 15 보다 크기 때문에 내부적으로 returnFirstNum() 함수가 호출됩니다. 그런데 &lt;code class=&quot;language-text&quot;&gt;returnFirstNum&lt;/code&gt; 함수는 &lt;code class=&quot;language-text&quot;&gt;getFirstNumber&lt;/code&gt; 함수와 동일한 모듈에 존재하기 때문에 실제로 호출되는 부분은 number.js 모듈의 실제 &lt;code class=&quot;language-text&quot;&gt;returnFirstNum&lt;/code&gt; 함수입니다(exports.returnFirstNum 이 아니라..).&lt;/p&gt;
&lt;p&gt;이는 &lt;code class=&quot;language-text&quot;&gt;number.returnFirstNum&lt;/code&gt;함수가 &lt;code class=&quot;language-text&quot;&gt;getFirstNumber&lt;/code&gt; 내에서 호출되는 &lt;code class=&quot;language-text&quot;&gt;returnFirstNum&lt;/code&gt;과는 전혀 다른 녀석이라는 것입니다. mock 함수를 할당한 변수와 실제 호출되는 함수가 전혀 다르기 때문에 이 테스트는 실패하는게 맞습니다. 그렇다면 같은 모듈에서 호출하는 함수를 테스트하기 위한 방법이 없을까요?&lt;/p&gt;
&lt;h3&gt;방법이 있긴 합니다만..&lt;/h3&gt;
&lt;p&gt;테스트를 성공시킬수 있는 아주 간단한 방법이 하나 있습니다. 하지만 그다지 추천하고 싶지는 않습니다. &lt;code class=&quot;language-text&quot;&gt;number.js&lt;/code&gt; 파일을 다음과 같이 수정합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import { justReturn } from &amp;quot;./util&amp;quot;;

export function getFirstNumber(num) {
  if (num &amp;gt;= 10) {
    return exports.returnFirstNum(num);
  } else {
    return justReturn(num);;
  }
}
export function returnFirstNum(num) {
  return num % 10;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;바뀐곳은 딱 한군데입니다. &lt;code class=&quot;language-text&quot;&gt;getFirstNumber&lt;/code&gt;내에서 &lt;code class=&quot;language-text&quot;&gt;returnFirstNum&lt;/code&gt;을 호출할때 앞에 &lt;code class=&quot;language-text&quot;&gt;exports.&lt;/code&gt;을 붙여주었습니다. 이는 returnFirstNum 을 모듈내에서 직접호출하는 것이 아니라 exports 객체의 property 에 할당된 함수를 호출하는 방법입니다. 동작은 이상없이 잘 됩니다만, 문제는 테스트 코드를 위해서 원래 소스를 고쳐야 한다는 것입니다. 그래서 그다지 추천하고 싶지 않습니다.&lt;/p&gt;
&lt;h3&gt;결론&lt;/h3&gt;
&lt;p&gt;같은 모듈에 있는 함수를 호출할때는 실제 함수를 사용하지만, 다른 모듈의 함수를 호출할때는 실제 그 함수가 호출되는 것이 아니라 모듈의 exports 객체의 property 가 호출됩니다. 그래서같은 모듈의 함수를 호출하는 함수를 테스트할 때는 호출 테스트를 할 수 없습니다. 방법이 있긴 하지만 테스트를 위해 원래 소스를 고쳐야 하므로 그다지 추천하지 않습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;혹시 좋은 방법 알고 계신분은 알려주시기 바랍니다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;참고자료&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://facebook.github.io/jest/docs/en/mock-functions.html&quot;&gt;https://facebook.github.io/jest/docs/en/mock-functions.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/@deanslamajr/jest-fn-all-the-things-d26f3b929986&quot;&gt;https://medium.com/@deanslamajr/jest-fn-all-the-things-d26f3b929986&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[[javascript] this는 어렵지 않습니다.]]></title><description><![CDATA[this 는 어렵지 않습니다. this 를 어렴풋이 알고는 있지만, 누가 물어봤을때 제대로 대답해 줄수 있도록 정리해보겠습니다. 많은 개발자들이 javascript 의 this…]]></description><link>https://blueshw.github.io/2018/03/12/this/</link><guid isPermaLink="false">https://blueshw.github.io/2018/03/12/this/</guid><pubDate>Mon, 12 Mar 2018 01:42:51 GMT</pubDate><content:encoded>&lt;p&gt;this 는 어렵지 않습니다.&lt;/p&gt;
&lt;p&gt;this 를 어렴풋이 알고는 있지만, 누가 물어봤을때 제대로 대답해 줄수 있도록 정리해보겠습니다. 많은 개발자들이 javascript 의 this 를 혼란스러워합니다. 사실 개념 자체가 어렵진 않습니다. 다만, 다른 프로그래밍 언어들과 사용법에 차이가 있을 뿐이죠. 언어마다 조금은 차이가 있겠지만 대표적으로 JAVA 같은 객체지향 언어에서의 this 는 클래스 인스턴스의 레퍼런스 변수입니다. 하지만 javascript 에서 this 는 전혀 다른 의미를 가집니다. 개발을 시작하고 처음으로 javascript 를 접한 개발자라면 조금 덜 혼란스러울지도 모르겠지만, 많은 개발자들이 C, C++, Java, python 등의 언어를 먼저 배운 뒤 javascript 를 접하는 케이스가 많습니다. 또한, Jquery 등의 라이브러리에 의존하는 경향 때문에 언어 자체의 문법이나 특성의 이해보다는 사용법만 습득하기도 하죠. 이런 경우, javascript 의 this 가 충분히 혼란스러울수 있을것 같습니다.&lt;/p&gt;
&lt;h3&gt;this 는 현재 실행 문맥이다&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;실행문맥&lt;/code&gt;이란 말은 호출자가 누구냐는 것과 같습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;alert(this === window); // true, 호출자는 window

const caller = {
  f: function() {
    alert(this === window);
  }
}
caller.f(); // false, 호출자는 caller 객체&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;첫번째는 함수 호출, 두번째는 메소드 호출이라고 말하는데 이런 구분이 괜한 혼란을 야기합니다. 첫번째 alert 도 따지고보면 &lt;code class=&quot;language-text&quot;&gt;window.alert()&lt;/code&gt;과 동일하기 때문에 window 객체의 메소드 호출이라봐도 무방합니다. 다만, &lt;code class=&quot;language-text&quot;&gt;strict-mode&lt;/code&gt;에서는 전역 객체냐 일반 객체냐에 따라 함수내부에 this 의 결과가 다르다는 차이는 있죠. 그러나 이 문제 또한 window 를 함수 호출 앞에 붙여주면 해결됩니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function nonStrictMode() {
  return this;
}

function strictMode() {
  &amp;#39;use strict&amp;#39;
  return this;
}

console.log(nonStrictMode()); // window
console.log(strictMode()); // undefined
console.log(window.stricMode()); // window&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;생성자 함수 / 객체에서는 어떻게 쓰이나?&lt;/h3&gt;
&lt;p&gt;생성자는 new 로 객체를 만들어 사용하는 방식입니다. 객체지향 언어에서 일반적으로 객체를 만들 때 쓰이는 문법과 동일하죠. 가리키는 대상 또한 객체지향 언어의 &lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;와 같기 때문에 이해하기가 한결 수월합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function NewObject(name, color) {
  this.name = name;
  this.color = color;
  this.isWindow = function() {
    return this === window;
  }
}

const newObj = new NewObject(&amp;#39;nana&amp;#39;, &amp;#39;yellow&amp;#39;);
console.log(newObj.name); // nana
console.log(newObj.color); // yellow
console.log(newObj.isWindow()); // false

const newObj2 = new NewObject(&amp;#39;didi&amp;#39;, &amp;#39;red&amp;#39;);
console.log(newObj2.name); // didi
console.log(newObj2.color); // red
console.log(newObj2.isWindow()); // false&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;new 키워드로 새로운 객체를 생성했을 경우 생성자 함수 내의 this 는 new 를 통해 만들어진 새로운 변수가 됩니다. &lt;code class=&quot;language-text&quot;&gt;newObj&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;newObj2&lt;/code&gt;는 같은 생성자 함수로 만들어진 객체이지만 완전히 별도의 객체이기 때문에 각 객체의 속성들은 서로 관련이 없습니다. 만약 new 키워드를 빼먹으면 어떻게 될까요?&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const withoutNew = NewObject(&amp;#39;nana&amp;#39;, &amp;#39;yellow&amp;#39;);
console.log(withoutNew.name); // error
console.log(withoutNew.color); // error
console.log(withoutNew.isWindow()); // error&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;new 키워드가 없으면 일반적인 함수 실행과 동일하게 동작하므로, &lt;code class=&quot;language-text&quot;&gt;NewObject&lt;/code&gt; 함수내의 this 는 &lt;code class=&quot;language-text&quot;&gt;window&lt;/code&gt; 객체가 됩니다. 하지만 &lt;code class=&quot;language-text&quot;&gt;withoutNew&lt;/code&gt;가 함수 실행의 결과값이 할당되므로 각 property 를 가져올 수 없습니다.
그렇다면, 생성자 함수가 아닌 일반 객체에서는 어떨까요?&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const person = {
  name: &amp;#39;john&amp;#39;,
  age: 15000,
  nickname: &amp;#39;man from earth&amp;#39;,
  getName: function () {
    return this.name;
  }
}
console.log(person.getName()); // john

const otherPerson = person;
otherPerson.name = &amp;#39;chris&amp;#39;;
console.log(person.getName()); // chris
console.log(otherPerson.getName()); // chris&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;생성자 함수와 크게 다르지 않습니다. 한가지 눈여겨 볼 점은 &lt;code class=&quot;language-text&quot;&gt;otherPerson.name&lt;/code&gt;을 &lt;code class=&quot;language-text&quot;&gt;chris&lt;/code&gt;로 설정한 뒤 person.getName() 호출하면 그 결과는 &lt;code class=&quot;language-text&quot;&gt;chris&lt;/code&gt;입니다. 그 이유는 otherPerson 은 person 의 레퍼런스 변수이므로 하나(otherPerson)를 변경하면 다른 하나(person)도 변경됩니다. 이를 피하기 위해서는 &lt;code class=&quot;language-text&quot;&gt;Object.assign()&lt;/code&gt;메서드(ES6 지원)를 이용하여 완전히 별도의 객체로 만들어야 합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const person = {
  name: &amp;#39;john&amp;#39;,
  age: 15000,
  nickname: &amp;#39;man from earth&amp;#39;,
  getName: function () {
    return this.name;
  }
}
const newPerson = Object.assign({}, person);
newPerson.name = &amp;#39;chris&amp;#39;;
console.log(person.getName()); // john
console.log(newPerson.getName()); // chris&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;bind, arrow function&lt;/h3&gt;
&lt;p&gt;이번에는 생성자 함수 안에서 또 다른 함수가 있는 경우를 살펴보겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function Family(firstName) {
  this.firstName = firstName;
  const names = [&amp;#39;bill&amp;#39;, &amp;#39;mark&amp;#39;, &amp;#39;steve&amp;#39;];
  names.map(function(lastName, index) {
    console.log(lastName + &amp;#39; &amp;#39; + this.firstName);
	console.log(this);
  });
}
const kims = new Family(&amp;#39;kim&amp;#39;);
// bill undefined
// window
// mark undefined
// window
// steve undefined
// window&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Family&lt;/code&gt;라는 생성자 함수 안에서 &lt;code class=&quot;language-text&quot;&gt;map&lt;/code&gt; 메서드를 호출합니다. map 메서드의 인자는 value 와 index 를 인자로 가지는 새로운 함수입니다. 이를 &lt;code class=&quot;language-text&quot;&gt;서브루틴&lt;/code&gt;이라 부르겠습니다. 서브루틴이 특별히 다른 개념은 아닙니다. 자바스크립트에서 함수의 의미가 다양하기 때문에 단지 메서드가 아닌 함수와 구분하기 위한 용도로 서브루틴이라는 단어를 사용합니다.&lt;/p&gt;
&lt;p&gt;이 서브루틴에서는 lastName 들을 담은 &lt;code class=&quot;language-text&quot;&gt;names&lt;/code&gt; 배열의 map 메서드를 이용하여 lastName 과 this 의 firstName 을 같이 출력하고자 합니다. 하지만 막상 실행을 해보면 예상과 다르게 출력됩니다. kim 이 출력될 위치에 &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt;가 출력되었습나다. 이는 map 의 서브루틴에서 this 를 사용하는 것이 문제였습니다. this 가 실행 문맥이라고 했던것을 상기해보면 undefined 가 출력되는 이유를 짐작해볼 수 있습니다. map 메서드의 서브루틴은 호출될때 map 의 context(this)로 바인드 되지 않습니다. 바인드 되지 않았다는 것은 실행문맥이 전역이라는 것이고 실행문맥이 전역이란 말은 (비엄격모드에서) 서브루틴 내 this 가 &lt;code class=&quot;language-text&quot;&gt;window&lt;/code&gt;라는 것입니다.&lt;/p&gt;
&lt;p&gt;비슷한 현상을 다른 예제에서 살펴보겠습니다. 아래 함수를 실행시키면 innerFunc 안의 this 는 window 가 출력됩니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const testObj = {
  outerFunc:  function() {
    function innerFunc() {
        console.log(this); // window
    }
    innerFunc();
  }
}
testObj.outerFunc();&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;outherFunc 가 외부에서 실행(testObj.outerFunc())되면 this 는 testObj 입니다. 그리고 outerFunc 내부에서 innerFunc 가 호출할때는 그 어떤 문맥도 지정하지(바인드되지) 않았습니다. 전역 context(window)에서 실행되었다는 것이죠. 이게 바로 (비엄격모드에서) innerFunc 의 this 가 window 가 되는 이유 입니다.&lt;/p&gt;
&lt;p&gt;다시 이전의 생성자 함수(Family)로 돌아갑니다. map 메서드의 서브루틴에서 this 가 window 가 된다는 것은 위에서 이미 설명했습니다. 하지만, 생성자 함수 내의 특정 변수를 서브루틴 내에서 사용할 수도 있습니다. 이 때, 실행문맥(this)을 Family 로 지정하려면 간단하게는 별도의 상수(const)를 지정하면 됩니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function Family(firstName) {
    this.firstName = firstName;
    const names = [&amp;#39;bill&amp;#39;, &amp;#39;mark&amp;#39;, &amp;#39;steve&amp;#39;];
    const that = this;
    names.map(function(value, index) {
        console.log(value + &amp;#39; &amp;#39; + that.firstName);
    })
}
const kims = new Family(&amp;#39;kim&amp;#39;);
// bill kim
// mark kim
// steve kim&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;문제 없이 이름들이 출력됩니다. 하지만, 항상 &lt;code class=&quot;language-text&quot;&gt;that&lt;/code&gt;이라는 상수를 만들어주면 귀찮습니다. 또한, 만에 하나 실수로 빼먹기라도 하면 어마어마한 문제가 발생할지도 모릅니다. 혹은 서브루틴 안에서 또다른 서브루틴을 사용할 수도 있습니다. 그 때는 &lt;code class=&quot;language-text&quot;&gt;anotherThat&lt;/code&gt;을 만들어야 할까요? 이 문제를 해결하기 위해서 &lt;code class=&quot;language-text&quot;&gt;bind&lt;/code&gt;라는 메서드를 사용합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function Family(firstName) {
    this.firstName = firstName;
    const names = [&amp;#39;bill&amp;#39;, &amp;#39;mark&amp;#39;, &amp;#39;steve&amp;#39;];
    names.map(function(value, index) {
        console.log(value + &amp;#39; &amp;#39; + this.firstName);
    }.bind(this));
}
const kims = new Family(&amp;#39;kim&amp;#39;);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;that 을 쓸때보다는 깔끔해졌습니다. 하지만 &lt;code class=&quot;language-text&quot;&gt;.bind(this)&lt;/code&gt;도 항상 붙여줘야한다는 문제는 여전히 남아 있습니다. 이제 &lt;code class=&quot;language-text&quot;&gt;arrow function&lt;/code&gt;이 나올때가 된것 같네요.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function Family(firstName) {
    this.firstName = firstName;
    const names = [&amp;#39;bill&amp;#39;, &amp;#39;mark&amp;#39;, &amp;#39;steve&amp;#39;];

    names.map((value, index) =&amp;gt; {
        console.log(value + &amp;#39; &amp;#39; + this.firstName);
    });
}
const kims = new Family(&amp;#39;kim&amp;#39;);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이제 that 도 없고, bind 도 없습니다. 함수의 형태만 바꿔주면 모든게 해결됩니다. 그럼 일반 함수형태에서 arrow 함수를 사용했을때 어떤 차이가 있을까요? arrow 함수 또한 ES6 에서만 지원하기 때문에 babel 사이트에서 변환해보겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;quot;use strict&amp;quot;;

function Family(firstName) {
  var _this = this;

  this.firstName = firstName;
  var names = [&amp;quot;bill&amp;quot;, &amp;quot;mark&amp;quot;, &amp;quot;steve&amp;quot;];
  names.map(function(value, index) {
    console.log(value + &amp;quot; &amp;quot; + _this.firstName);
  });
}
var kims = new Family(&amp;quot;kim&amp;quot;);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;that 을 사용했을 때와 동일한 방법으로 트랜스파일 되네요. 미리 내부에서만 사용할 변수 &lt;code class=&quot;language-text&quot;&gt;_this&lt;/code&gt;를 만들어 두고, this 를 할당합니다. 그리고 &lt;code class=&quot;language-text&quot;&gt;_this&lt;/code&gt;를 사용하여 firstName 을 가져옵니다. arrow 함수는 호출 대상에 따라 실행문맥이 결정되는 것이 아닙니다.&lt;/p&gt;
&lt;h3&gt;결론&lt;/h3&gt;
&lt;p&gt;this 는 어렵지 않습니다. 하지만, 타 언어와 다른 방식으로 사용되기에 주의해서 사용할 필요가 있습니다. 한가지만 기억하자면, this 는 누가 호출했느냐에 따라 결정된다는 것입니다. ES6 문법을 사용하면 this 를 사용할때 문제점을 완화할 수 있습니다. 예를들어, 서브루틴 내에서 바깥의 this 를 사용하려고 할때는 arrow function 을 이용하면 간단하게 해결할 수 있습니다.&lt;/p&gt;
&lt;p&gt;참고 자료&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/this&quot;&gt;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/this&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript&quot;&gt;https://developer.mozilla.org/ko/docs/Web/JavaScript/Introduction&lt;em&gt;to&lt;/em&gt;Object-Oriented_JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://webframeworks.kr/tutorials/translate/explanation-of-this-in-javascript-1/&quot;&gt;http://webframeworks.kr/tutorials/translate/explanation-of-this-in-javascript-1/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://gomugom.github.io/is-class-only-a-syntactic-sugar/&quot;&gt;https://gomugom.github.io/is-class-only-a-syntactic-sugar/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://webframeworks.kr/tutorials/translate/arrow-function/&quot;&gt;http://webframeworks.kr/tutorials/translate/arrow-function/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[[javascript] async, await를 사용하여 비동기 javascript를 동기식으로 만들자]]></title><description><![CDATA[async, await 는 ES8(ECMAScript201…]]></description><link>https://blueshw.github.io/2018/02/27/async-await/</link><guid isPermaLink="false">https://blueshw.github.io/2018/02/27/async-await/</guid><pubDate>Tue, 27 Feb 2018 21:56:31 GMT</pubDate><content:encoded>&lt;p&gt;async, await 는 ES8(ECMAScript2017)의 공식 스펙(&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;링크&lt;/a&gt;)으로 비교적 최근에 정의된 문법입니다. &lt;code class=&quot;language-text&quot;&gt;async, await&lt;/code&gt;를 사용하면 비동기 코드를 작성할 때 비교적 쉽고 명확하게 코드를 작성할 수 있습니다. 자바스크립트는 싱글 스레드 프로그래밍언어기 때문에 비동기처리가 필수적입니다. 비동기 처리는 그 결과가 언제 반환될지 알수 없기 때문에 동기식으로 처리하는 기법들이 사용되어야 합니다. 대표적으로 &lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;이 있고 &lt;code class=&quot;language-text&quot;&gt;callback&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;promise&lt;/code&gt;가 있습니다. 세 가지 모두 비동기 코드를 동기식으로 작성하는데 훌륭한 기법들이지만, 모두 약간의 문제점을 가지고 있습니다. async 와 await 는 이런 문제들을 해결함과 동시에 그 사용법에 있어서도 훨씬 단순해졌습니다. 각각의 방식들을 살펴본 뒤 async, await 를 어떻게 사용하고 어떤 방식으로 구현되어 있는지 알아보도록 하겠습니다.&lt;/p&gt;
&lt;h3&gt;setTimeout&lt;/h3&gt;
&lt;p&gt;setTimeout 은 특정 시간 동안 기다렸다가 이후 첫번째 파라미터의 함수를 실행하는 방식을 사용합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;let first = 10;
let second = 20;
let result = 0;

function add(x, y) {
  return x + y;
}

setTimeout(function() {
  result = add(first, second);
  console.log(result); // 30
}, 1000)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 코드는 1 초 후에 10 과 20 을 더해서 result 에 30 을 할당하는 간단한 setTimeout 예제입니다. setTimeout 함수의 첫번째 파라미터는 실행될 함수이고, 두번째 파라미터는 첫번째 파라미터가 얼마후(ms)에 실행될지를 결정합니다. 여기에 별 문제는 없어 보이지만 비동기에 대한 이해가 부족한 상황에서 더 복잡한 코드를 작성하다가는 큰 문제에 부딪칠수도 있습니다. 조금 수정된 코드입니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;let first = 10;
let second = 20;
let result = 0;

function add(x, y) {
  return x + y;
}

setTimeout(function() {
  result = add(first, second);
  console.log(result); // 40
}, 1000)

first = 20;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 코드가 동기식으로 처리된다면 result 가 30 이겠지만, 실제로 console 에 찍히는 값은 40 입니다. 어디가 잘못 되었을까요?&lt;/p&gt;
&lt;p&gt;자바스크립트는 각각의 &lt;code class=&quot;language-text&quot;&gt;task&lt;/code&gt;를 큐에 적재해두고 순서대로 처리합니다. 이 때 어떤 코드가 새로운 태스크로 적재되지에 대한 이해가 부족하면 위와 같은 실수를 저지를 수 있습니다. 최초의 task 는 스크립트 파일 자체입니다. 이 첫번째 task 내에 &lt;code class=&quot;language-text&quot;&gt;setTimeout은 별도의 task를 생성&lt;/code&gt;하고 첫번째 task 가 종료되길 기다립니다. 첫번째 task 인 스크립트의 실행이 끝나면 비로소 setTimeout 의 함수를 실행할 준비를 합니다. 즉 first 의 값은 초기에 10 이였지만 첫번째 스크립트가 종료되면 20 이 되기때문에 결과적으로 result 는 40 이 됩니다. task 에 대한 이해가 부족하다면 지난번에 번역했던 &lt;a href=&quot;https://blueshw.github.io/2018/01/28/tasks-microtasks-queues-and-schedules/&quot;&gt;Tasks, microtasks, queues and schedules&lt;/a&gt;&lt;a href=&quot;https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/&quot;&gt;(원본)&lt;/a&gt;를 참고하세요.&lt;/p&gt;
&lt;p&gt;그럼 이 코드를 동기식으로 처리하려면 어떻게 해야할까요?&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;let first = 10;
let second = 20;
let result = 0;

function add(x, y) {
  return x + y;
}
function getResult(callback) {
  setTimeout(function() {
    result = add(first, second);
    console.log(result); // 30
    callback();
  }, 1000)
}

getResult(function() {
  first = 20;
});&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위와 같이 callback 함수를 사용하면 비동기 코드를 동기식으로 작성할 수 있습니다. 그렇다면 이제 비동기 코드를 동기식으로 바꾸기 위해 사용하는 callback 이 무엇이고 어떻게 사용하는지 알아보도록 하겠습니다.&lt;/p&gt;
&lt;h3&gt;callback&lt;/h3&gt;
&lt;p&gt;callback 함수란 호출하는 함수(calling function)가 호출되는 함수(called 함수)로 전달하는 함수를 말하며 이때 callback 함수의 제어권은 호출되는 함수에게 있습니다. callback 함수는 setTimeout 함수와 같은 비동기 코드를 동기식으로 처리하기 위해 사용합니다. production 에 사용되는 코드에서는 보통 네트워크 요청 등의 비동기 코드에 많이 사용됩니다.&lt;/p&gt;
&lt;p&gt;callback 이 직관적(하나만 사용했을 때)이고 이해가 어렵지는 않지만, 여러개의 callback 을 연달아 사용하게 되면 에러가 발생할 가능성이 높고, 코드의 가독성도 크게 떨어지게 됩니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// 각 함수는 비동기로 처리되는 로직이라 가정합니다
function goWork(time1, timeStartWork) {
  wakeUp(time1, function (time2) {
    takeSubway(time2, function(time3) {
      takeOffSubway(time3, function(time4) {
        arriveWork(time4, function(arrivalTime) {
          if (arrivalTime &amp;gt; timeStartWork) {
            fire();
          }
        }
      }
    }
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;callback 은 비동기 코드를 동기적 만드는데 확실한 방법이긴 하지만 남발하게 되면 가독성이 크게 떨어지고 코드의 복잡성도 크게 증가하게 됩니다. 또한 callback 의 호출에 대한 제어권이 다른 함수들에게 넘어가 버리기 때문에 각 콜백함수가 언제 어떻게 몇번 실행되는지 확신을 할 수 없습니다. 이렇게 코드를 작성하면(물론 잘 하면 상관없지만), 특히 여러명이서 코드를 공유하는 경우라면 결과를 예측하기 어려울 뿐 아니라 코드내에서 에러가 발생할 확률도 높아집니다.&lt;/p&gt;
&lt;h3&gt;promise&lt;/h3&gt;
&lt;p&gt;promise 는 약속입니다. 어떤 작업이 성공했을 때(resolve), promise 객체의 then() 함수에 넘겨진 파라미터(함수)를 단 한번만 호출하겠다는 약속입니다. callback 의 경우 제어권이 호출되는 함수로 넘어가 버리기 때문에 신뢰성이 다소 떨어지지만 promise 는 함수 실행이 성공했을때 then() 함수의 파라미터(함수)가 단 한번만 호출되기 때문에 함수를 호출하는 입장에서 확신을 가지고 코드를 작성할 수 있습니다. 또한 실패했을 경우(reject)에도 catch()함수를 통해서 실패 이후의 작업을 처리할 수 있습니다. 위의 함수(goWork)를 promise 로 바꾸어보겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function goWork(time1, timeStartWork) {
  return wakeUp(time1).then(function(time2) {
      return tackSubway(time2);
    }).then(function(time3) {
      return takeOffSubway(time3);
    }).then(function(time4) {
      return arriveWork(time4) {
    }).then(function(arrivalTime) {
      if (arrivalTime &amp;gt; timeStartWork) {
        fire();
      }
    });
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;callback 보다는 훨씬 덜 복잡해 보입니다. 여기에다 ES6 의 arrow function 문법을 적용하면 훨씬 더 간단해집니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function goWork(time1, timeStartWork) {
  return wakeUp(time1)
    .then(time2 =&amp;gt; tackSubway(time2))
    .then(time3 =&amp;gt; takeOffSubway(time3))
    .then(time4 =&amp;gt; arriveWork(time4))
    .then(arrivalTime =&amp;gt; {
      if (arrivalTime &amp;gt; timeStartWork) {
        fire();
      }
    });
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;promise 는 충분히 깔끔하고 완성되어 보이지만, 사실 완전히 만족스럽지 않습니다. C 나 Java 와 같은 절차적 언어에서 사용하듯이 단순하고 직관적이면 더 좋겠다는 생각이 드네요.
그럼 이제 async 와 await 가 등장해야할 시간입니다.&lt;/p&gt;
&lt;h3&gt;async &amp;#x26; await&lt;/h3&gt;
&lt;p&gt;async 와 await 는 절차적 언어에서 작성하는 코드와 같이 사용법도 간단하고 이해하기도 쉽습니다. function 키워드 앞에 &lt;code class=&quot;language-text&quot;&gt;async&lt;/code&gt;만 붙여주면 되고 비동기로 처리되는 부분 앞에 &lt;code class=&quot;language-text&quot;&gt;await&lt;/code&gt;만 붙여주면 됩니다. 다만, 몇 가지 주의할 점이 있다면 await 뒷부분이 반드시 promise 를 반환해야 한다는 것과 async function 자체도 promise 를 반환한다는 것입니다. 그럼 사용법을 먼저 살펴보겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;async function goWork(time1, timeStartWork) {
  const time2 = await wakeUp(time1);
  const time3 = await takeSubway(time2);
  const time4 = await takeOffSubway(time3);
  const arrivalTime = await arriveWork(time4);
  if (arrivalTime &amp;gt; timeStartWork) {
    fire();
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;우와, promise 에 비해 훨씬 직관적입니다. 사용법도 그다지 어렵지 않고 코드 이해도 훨씬 좋아졌습니다. 그렇다면 간단하게 function 앞에 async 를 붙여주고 호출하는 함수앞에 await 를 붙여준 것만으로 어떻게 비동기 함수들의 동기처리가 가능해진걸까요? async 와 await 가 어떻게 동작하는지 알아보기 위해 babel 의 도움을 좀 받아야겠습니다. async, await 는 ES8 스펙이라 몇몇 브라우저에서는 호환되지 않게 때문에(최신 크롬은 됩니다) 기존 브라우저에서 동작하도록 자바스크립트 코드를 변환해 주어야 합니다. &lt;a href=&quot;https://babeljs.io/repl/#?babili=false&amp;#x26;browsers=&amp;#x26;build=&amp;#x26;builtIns=false&amp;#x26;code_lz=IYZwngdgxgBAZgV2gFwJYHsIwOboOroBOA1gBRoC2ApgIwA0MlVAyssIcgSQJQwDeAKBgwomEMkapqAJhgBeGMADuwVBJXEqAVQAO5KbW4BuISLESmAZnmKVaxsE3MEAIxVh9M46dERxk6gAWG2VVC0cqAHk4OGc3YA8rb2Fff3ZCVAA3YAAbABUDELsJdKyqLjImQOSYVDgYUlLs_MKAPgCWNg4K3kFhYThUQipSGoBfATGgA&amp;#x26;debug=false&amp;#x26;forceAllTransforms=false&amp;#x26;shippedProposals=false&amp;#x26;circleciRepo=&amp;#x26;evaluate=false&amp;#x26;fileSize=false&amp;#x26;lineWrap=true&amp;#x26;presets=es2015%2Creact%2Cstage-2&amp;#x26;prettier=true&amp;#x26;targets=&amp;#x26;version=6.26.0&amp;#x26;envVersion=&quot;&gt;babel 변환 코드&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;두 부분으로 나누어 간단히 살펴보겠습니다.
(아래 설명들은 정리가 잘 안되있어 이해하기 어렵습니다. 설명을 잘 못하는거 보니 아직 저도 잘 이해 못하고 있는 부분이 있는것 같네요ㅠㅠ)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var goWork = (function() {
  var _ref = _asyncToGenerator(
    regeneratorRuntime.mark(function _callee(
      time1,
      timeStartWork
    ) {
      var time2, time3, time4, arrivalTime;
      return regeneratorRuntime.wrap(
        function _callee$(_context) {
          while (1) {
            switch ((_context.prev = _context.next)) {
              case 0:
                _context.next = 2;
                return wakeUp(time1);
              case 2:
                time2 = _context.sent;
                _context.next = 5;
                return takeSubway(time2);
              ...
              case 13:
              case &amp;quot;end&amp;quot;:
                return _context.stop();
            }
          }
        },
        _callee,
        this
      );
    })
  );

  return function goWork(_x, _x2) {
    return _ref.apply(this, arguments);
  };
})();&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;첫번째로 위쪽의 코드는 goWork 를 즉시 실행하는 함수입니다. 즉시실해함수기 때문에 선언과 동시에 함수가 실행됩니다. 이 함수의 결과값은(&lt;code class=&quot;language-text&quot;&gt;var goWork&lt;/code&gt;에 할당되는 값) 맨 아래의 &lt;code class=&quot;language-text&quot;&gt;goWork(_x, _x2)&lt;/code&gt; 함수입니다. 즉, 외부에서 &lt;code class=&quot;language-text&quot;&gt;goWork(...)&lt;/code&gt;를 호출하면 맨 아래의 goWork 함수가 호출되는것입니다.&lt;/p&gt;
&lt;p&gt;외부에서 goWork 를 호출하면 &lt;code class=&quot;language-text&quot;&gt;_ref&lt;/code&gt;가 실행되는데 _ref 는 &lt;code class=&quot;language-text&quot;&gt;_asyncToGenerator&lt;/code&gt; 함수가 실행된 결과(이 또한 함수)가 할당됩니다. &lt;code class=&quot;language-text&quot;&gt;_asyncToGenerator&lt;/code&gt; 함수는 하나의 인자(함수)를 가지는데, 이 인자는 실행되면서 내부적으로 제너레이터가 생성합니다. 이 제너레이터를 생성하고 동작을 처리하기 위해서 babel 의 &lt;a href=&quot;https://babeljs.io/docs/plugins/transform-regenerator/&quot;&gt;regeneratorRuntime&lt;/a&gt; 플러그인이 이용됩니다.&lt;/p&gt;
&lt;p&gt;제너레이터가 생성되어 실행되면 이터레이터가 만들어지고 이터레이터의 next 함수로 yield 구문의 코드를 차례차례 실행하는게 보통의 제너레이터 구조입니다. 여기에서는 만들어진 이터레이터의 next 함수(step(‘next’))가 호출될 때 마다 context 의 위치를 변경하고(context.next), 해당 위치의 함수를 실행합니다. (실제 await 부분).&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function _asyncToGenerator(fn) {
  return function() {
    var gen = fn.apply(this, arguments);
    return new Promise(function(resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }
        if (info.done) {
          resolve(value);
        } else {
          return Promise.resolve(value).then(
            function(value) {
              step(&amp;quot;next&amp;quot;, value);
            },
            function(err) {
              step(&amp;quot;throw&amp;quot;, err);
            }
          );
        }
      }
      return step(&amp;quot;next&amp;quot;);
    });
  };
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;두번째 부분입니다. 여기서는 우선 위에서 보았던 제너레이터 처리 함수인 &lt;code class=&quot;language-text&quot;&gt;fn&lt;/code&gt;을 실행시켜서 이터레이터(변수명은 gen 이지만 이터레이터가 맞는듯)를 만들어 두고 그 아래에서 &lt;code class=&quot;language-text&quot;&gt;프로미스&lt;/code&gt;를 리턴합니다. &lt;code class=&quot;language-text&quot;&gt;프로미스&lt;/code&gt;가 리턴된다는 것은 goWork() 함수의 리턴 타입이 Promise 가 된다는 것입니다(코드를 잘 따라가보면 goWork()의 결과값이 Promise 를 리턴하는 부분임을 알 수 있습니다). 프로미스 내부에는 &lt;code class=&quot;language-text&quot;&gt;step&lt;/code&gt;이라는 함수를 만들고 이 함수를 &lt;code class=&quot;language-text&quot;&gt;next&lt;/code&gt; 인자와 함께 호출합니다. step 에서는 인자로 받은 &lt;code class=&quot;language-text&quot;&gt;key&lt;/code&gt;를 이용하여 &lt;code class=&quot;language-text&quot;&gt;gen[key](arg)&lt;/code&gt; 형태로 함수를 호출합니다. 이때 key 가 &lt;code class=&quot;language-text&quot;&gt;next&lt;/code&gt;라면 이터레이터의 next()와 동일한 함수가 호출될것이고 반환값(info)은 당연히 &lt;code class=&quot;language-text&quot;&gt;{value: xxx, done: false}&lt;/code&gt;가 될 것입니다. info.done 이 &lt;code class=&quot;language-text&quot;&gt;true&lt;/code&gt;일때는 제너레이터가 종료된것이므로 resolve()를 호출합니다. 그리고 &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt;인 경우에는 새로운 프로미스를 생성하고 next 함수를 실행합니다.&lt;/p&gt;
&lt;p&gt;위의 부분과 연관지어 설명하자면, step()함수가 한 번 실행될때 마다 하나의 프로미스가 생성되고, 제너레이터의 context 위치가 변경되고 해당부분의 함수를 호출합니다.&lt;/p&gt;
&lt;p&gt;async 와 await 는 제너레이터 구조와 거의 동일합니다. 제너레이터에서 함수옆에 붙이는 ’*’ 대신 async 를 붙이고, yield 대신 await 를 사용합니다. 다만 await 함수에서는 이터레이터의 next() 호출을 프로미스의 resolve()함수가 담당합니다. 그렇기 때문에 await 함수(프로미스)가 성공(resolve)해야지만 함수의 결과값을 리턴해줄 수 있게됩니다. 이를 간단히 요약해보면 &lt;code class=&quot;language-text&quot;&gt;async,await =&amp;gt; 제너레이터,이터레이터 + 프로미스&lt;/code&gt;라 할 수 있겠습니다.&lt;/p&gt;
&lt;p&gt;이상 자바스크립트의 비동기 함수들과 동기식 처리의 발전과정에 대해 알아봤습니다. 개인의 공부 및 정리를 목적으로 작성한 글이라 전문성이 결여되어 있으며 다소 이해하기 어려운 설명들이 다수 포함되어 있습니다.&lt;/p&gt;
&lt;h3&gt;참고자료&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/@_bengarrison/javascript-es8-introducing-async-await-functions-7a471ec7de8a&quot;&gt;https://medium.com/@_bengarrison/javascript-es8-introducing-async-await-functions-7a471ec7de8a&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://hyunseob.github.io/2015/08/09/async-javascript/&quot;&gt;https://hyunseob.github.io/2015/08/09/async-javascript/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://meetup.toast.com/posts/73&quot;&gt;http://meetup.toast.com/posts/73&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jicjjang.github.io/2017/02/05/promise-and-async-await/&quot;&gt;https://jicjjang.github.io/2017/02/05/promise-and-async-await/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/@jooyunghan/babel%EC%9D%80-generator%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%B0%94%EA%BE%B8%EB%82%98-c78523645cd7&quot;&gt;https://medium.com/@jooyunghan/babel%EC%9D%80-generator%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%B0%94%EA%BE%B8%EB%82%98-c78523645cd7&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[[번역] Tasks, microtasks, queues and schedules]]></title><description><![CDATA[원본:  https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules…]]></description><link>https://blueshw.github.io/2018/01/28/tasks-microtasks-queues-and-schedules/</link><guid isPermaLink="false">https://blueshw.github.io/2018/01/28/tasks-microtasks-queues-and-schedules/</guid><pubDate>Sun, 28 Jan 2018 21:31:39 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;원본: &lt;a href=&quot;https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/&quot;&gt;https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/&lt;/a&gt;
의역, 오역이 가득합니다. 개인적으로 정확한 개념을 잡기 위한 번역입니다. 불필요하다 생각한 내용은 과감히 제거했습니다.
테스트는 원본 페이지에서 확인 가능합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;아래 자바스크립트 코드를 살펴보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;console.log(&amp;#39;script start&amp;#39;);

setTimeout(function() {
  console.log(&amp;#39;setTimeout&amp;#39;);
}, 0);

Promise.resolve().then(function() {
  console.log(&amp;#39;promise1&amp;#39;);
}).then(function() {
  console.log(&amp;#39;promise2&amp;#39;);
});

console.log(&amp;#39;script end&amp;#39;);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 코드를 실행하면 아래와 같은 순서로 출력된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;script start
script end
promise1
promise2
setTimeout&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;브라우저에 따라서 조금 다른데 Microsoft Edge, Firefox 40, iOS Safari, desktop Safari 8.0.8 에서는 예외적으로 &lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;이 &lt;code class=&quot;language-text&quot;&gt;promise1&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;promise2&lt;/code&gt;보다 먼저 출력된다. 진짜 이상한점은 Firefox 39, Safari 8.0.7 에서는 정상적으로 출력된다는 것이다.&lt;/p&gt;
&lt;h3&gt;왜 이렇게 출력되는 것일까?&lt;/h3&gt;
&lt;p&gt;이를 이해하기 위해서는 우선 이벤트 루프가 &lt;code class=&quot;language-text&quot;&gt;task&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;microtask&lt;/code&gt;를 어떻게 다루는지에 대해 알 필요가 있다.&lt;/p&gt;
&lt;p&gt;스레드는 그 자신의 이벤트 루프를 가지고 있고 각각의 web worker 는 자신의 이벤트 루프를 수행하기 때문에 서로 독립적으로 실행된다. 그러나 같은 도메인(origin)의 모든 브라우저 창들은 동기적으로 통신할 수 있기 때문에 이벤트 루프를 서로 공유한다. 이벤트 루프는 지속적으로 돌아가면서, 대기열에 들어가있는 task 들을 실행시킨다. 한 이벤트 루프는 실행 순서를 보장하는 여러개의 task 를 가지고 있지만 각 이벤트 루프의 실행단계에서 어떤 task 를 실행시킬지는 브라우저가 선택한다. 이를 통해 브라우저는 유저 input 과 같은 성능에 민감한 task 에 우선권을 부여할 수 있다.&lt;/p&gt;
&lt;p&gt;task 는 브라우저 내부에서 javascript/DOM 으로 들어가 순차적으로 발생하도록 예약된다. task 사이에서 브라우저는 렌더링을 새로한다. 마우스 클릭으로 이벤트 콜백을 발생시키려면 HTML 파싱 처럼 task 예약이 필요하다. 위에서 보았던 &lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;이 좋은 사례이다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;은 주어진 delay 를 기다린 다음 콜백을 위한 새로운 task 를 예약한다. 이것이 &lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;로그가 &lt;code class=&quot;language-text&quot;&gt;script end&lt;/code&gt;로그 이후에 출력되는 이유이다. &lt;code class=&quot;language-text&quot;&gt;script end&lt;/code&gt;로그는 첫번째 task 의 일부이고 &lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;은 별도의 task 에서 발생한 로그이다.&lt;/p&gt;
&lt;p&gt;일반적으로 microtask 는 현재 실행되고 있는 script 바로 다음에 발생해야하는 작업으로 예약된다. 예를들어 일괄처리에 대한 반응(?)이나 새로운 task 를 만들때의 단점 없이 비동기로 어떤 작업을 처리하기 위해 사용된다. microtask 의 대기열은 다른 자바스크립트가 실행중이 아니거나 task 가 끝난 후에 처리된다. 대기중인 microtask 는 대기열의 끝에 더해지고 실행된다. &lt;code class=&quot;language-text&quot;&gt;observer callback&lt;/code&gt;이나 &lt;code class=&quot;language-text&quot;&gt;promise callback&lt;/code&gt;이 대표적인 microtask 다.&lt;/p&gt;
&lt;p&gt;promise 가 처리될 때 혹은 이미 처리된 promise 는 callback 을 처리하기 위해 microtask 의 대기열에 들어간다. 이눈 promise 가 처리 여부와 상관없이 그 callbak 이 비동기로 실행됨을 보장한다. 즉, 처리된 promise 에 대해서 &lt;code class=&quot;language-text&quot;&gt;then(resolve, reject)&lt;/code&gt;이 호출되면 그 즉시 microtask 가 대기열에 들어간다. 이것이 바로 &lt;code class=&quot;language-text&quot;&gt;promise1&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;promise2&lt;/code&gt;가 &lt;code class=&quot;language-text&quot;&gt;script end&lt;/code&gt; 다음에 출력되는 이유이다. 현재 실행되는 script(task)가 끝난 다음에 반드시 microtask 가 처리되어야 한다. &lt;code class=&quot;language-text&quot;&gt;promise1&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;promise2&lt;/code&gt;가 &lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt; 이전에 출력되는 이유는 microtask 가 다음에 실행될 task 이전에 처리되기 때문이다.&lt;/p&gt;
&lt;p&gt;위 코드를 다시 살펴보면 아래와 같은 순서로 처리됨을 알 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;원문에서 확인함을 추천, 원문에는 animation 으로 코드의 실행과정과 task queue 및 js 실행 스택을 확인할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// 1 - task1 실행: script, script start 출력
console.log(&amp;#39;script start&amp;#39;);

// 2 - task2 등록: timer task 대기열에 들어감
setTimeout(function() {
  // 8 - task2 실행
  console.log(&amp;#39;setTimeout&amp;#39;);
}, 0);

// 3 - microtask1 등록: promise가 microtask 대기열에 들어감
Promise.resolve().then(function() {
  // 5 - microtask1 실행: promise1 출력
  console.log(&amp;#39;promise1&amp;#39;);
// 6 - microtask2 등록:
}).then(function() {
  // 7 - microtask2 실행: promise2 출력
  console.log(&amp;#39;promise2&amp;#39;);
});

// 4 - task1 종료: script end 출력
console.log(&amp;#39;script end&amp;#39;);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;그럼 어떤 브라우저에서는 왜 다르게 동작할까?&lt;/h3&gt;
&lt;p&gt;위에서 언급한 특정 브라우저에서는 &lt;code class=&quot;language-text&quot;&gt;promise1&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;promise2&lt;/code&gt;가 두번째 task 인 &lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt; 이후에 출력된다. 이때는 promise 가 microtask 가 아닌 새로운 task 로 인식되어 &lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt; task 이후에 출력되는 것이 아닐까 생각된다.&lt;/p&gt;
&lt;p&gt;promise 가 HTML 이 아니라 ECMAScript 에서 나왔기 때문에 변명의 여지가 있어보입니다. ECMAScript 는 microtask 와 비슷한 job 의 개념을 가지고 있다. 그러나 그 관계가 명확한 것은 아니지만(&lt;a href=&quot;https://esdiscuss.org/topic/the-initialization-steps-for-web-browsers#content-16&quot;&gt;vague mailing list discussions&lt;/a&gt;), 일반적으로 promise 는 microtask 대기열의 일부로 받아들여지고 있다.&lt;/p&gt;
&lt;p&gt;promise 를 task 로써 다룰 때는 성능상 문제가 발생할 수 있는데, promise callback 이 렌더링과 같은 task 관련 작업들에 의해 불필요하게 연기될수도 있기 때문이다. 또한 이는 다른 자바스크립트 소스와의 상호작용으로 인해서 무결성이 훼손될수도 있고 그로인해 다른 API 와의 상호작용이 깨질수도 있다.&lt;/p&gt;
&lt;p&gt;해당 이슈는 Edge 브라우저에서 이미 완결되었다(&lt;a href=&quot;https://connect.microsoft.com/IE/feedback/details/1658365&quot;&gt;Edge ticket&lt;/a&gt;).&lt;/p&gt;
&lt;h3&gt;task 인지 microtask 인지는 어떻게 알수 있을까?&lt;/h3&gt;
&lt;p&gt;테스트 방법은 하나다. 비록 올바르게 구현됐다는 가정이 필요하지만, promise 와 &lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;과 관련된 로그의 출력을 보면 알 수 있다.&lt;/p&gt;
&lt;p&gt;더 확실한 방법은 스펙을 찾아보면 된다. 예를들어 task 가 대기열에 들어가는 과정을 나타낸 &lt;a href=&quot;https://html.spec.whatwg.org/multipage/webappapis.html#timer-initialisation-steps&quot;&gt;step 14 of setTimeout&lt;/a&gt;을 살펴볼 수 있고, microtask 가 큐에 들어가는 과정을 나타낸 &lt;a href=&quot;https://dom.spec.whatwg.org/#queue-a-mutation-record&quot;&gt;step 5 of queueing a mutation record&lt;/a&gt;를 보면 좀 더 자세하게 알 수 있다.&lt;/p&gt;
&lt;p&gt;이미 얘기한것 처럼 ECMAScript 에서는 microtask 는 job 으로 불린다. &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-performpromisethen&quot;&gt;step 8 .a PerformPromiseThen&lt;/a&gt;을 보면, EnqueueJob 은 microtask 대기열에서 호출됨을 알 수 있다.&lt;/p&gt;
&lt;p&gt;다음에는 좀더 복잡한 예제를 살펴보자.&lt;/p&gt;
&lt;h3&gt;Level 1 bossfight&lt;/h3&gt;
&lt;p&gt;아래에 간단한 html 이 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;div class=&amp;quot;outer&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;inner&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그리고 아래 자바스크립트 코드 일부가 있다. 이때 &lt;code class=&quot;language-text&quot;&gt;div .inner&lt;/code&gt;를 클릭하면 로그가 어떻게 출력될까?&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// outer 클래스 element와 inner 클래스 element를 가져온다.
var outer = document.querySelector(&amp;#39;.outer&amp;#39;);
var inner = document.querySelector(&amp;#39;.inner&amp;#39;);

// outer element의 상태(attribute) 변화를 감시한다.
new MutationObserver(function() {
  console.log(&amp;#39;mutate&amp;#39;);
}).observe(outer, {
  attributes: true
});

// click 리스너
function onClick() {
  console.log(&amp;#39;click&amp;#39;);

  setTimeout(function() {
    console.log(&amp;#39;timeout&amp;#39;);
  }, 0);

  Promise.resolve().then(function() {
    console.log(&amp;#39;promise&amp;#39;);
  });

  outer.setAttribute(&amp;#39;data-random&amp;#39;, Math.random());
}

// inner, outer element에 클릭 이벤트를 붙인다.
inner.addEventListener(&amp;#39;click&amp;#39;, onClick);
outer.addEventListener(&amp;#39;click&amp;#39;, onClick);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;div.inner&lt;/code&gt;를 클릭했을 때와, &lt;code class=&quot;language-text&quot;&gt;div .outer&lt;/code&gt;를 클릭했을때 어떻게 다른지 알겠는가? 당신이 여전히 맞을수도 있겠지만 불행하게도 브라우저마다 동일한 결과를 보여주지는 않는다(버전 명시가 안되있어서 현재 최신 버전에서도 동일할지는 테스트가 필요하겠다).&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Chrome :
click - promise - mutate - click - promise - mutate - timeout - timeout

Firefox :
click - mutate - click - mutate - timeout - promise - promise - timeout

Safari :
click - mutate - click - mutate - promise - promise - timeout - timeout

Edge
click - click - mutate - timeout - promise - timeout - promise&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;어떤 브라우저가 맞을까?&lt;/h3&gt;
&lt;p&gt;클릭 이벤트를 전달하는것은 하나의 task 다(즉, &lt;code class=&quot;language-text&quot;&gt;div .inner&lt;/code&gt;에서 클릭이 발생해서 &lt;code class=&quot;language-text&quot;&gt;div .outer&lt;/code&gt;로 버블링되더라도 두개의 동작이 별도의 task 가 아니라 하나의 task 라는 의미). Mutation observer 나 promise callback 은 microtask 로 대기열에 들어가고 &lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt; 콜백은 task 로 대기열에 들어간다. 즉 아래와 같은 방식으로 처리된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// 1 - task1 실행: script 실행
var outer = document.querySelector(&amp;#39;.outer&amp;#39;);
var inner = document.querySelector(&amp;#39;.inner&amp;#39;);

new MutationObserver(function() {
  // 8 - microtask2 실행: mutation observer 콜백 실행
  // 13 - microtask4 실행: mutation observer 콜백 실행
  console.log(&amp;#39;mutate&amp;#39;);
}).observe(outer, {
  attributes: true
});

// 3 - task2 등록 및 실행: inner 영역 click 이벤트 발생
// 9 - task2 계속 실행 : inner에서 outer로 click 이벤트 버블링
function onClick() {
  console.log(&amp;#39;click&amp;#39;);

  // 4 - task3 등록: inner 영역 타이머 task 생성, setTimeout
  // 10 - task4 등록: outer 영역 타이머 task 생성, setTimeout
  setTimeout(function() {
    // 14 - task3 실행: inner 영역 타이머 콜백 실행
    // 15 - task4 실행: outer 영역 타이머 콜백 실행
    console.log(&amp;#39;timeout&amp;#39;);
  }, 0);

  // 5 - microtask1 등록: inner 영역 promise
  // 11 - microtask3 등록: outer 영역 promise
  Promise.resolve().then(function() {
    // 7 - microtask1 실행 : inner 영역의 promise 콜백 실행
    console.log(&amp;#39;promise&amp;#39;);
  });

  // 6 - microtask2 등록: inner 영역 Mutation observer
  // 12 - microtask4 등록: outer 영역 Mutation observer 등록
  outer.setAttribute(&amp;#39;data-random&amp;#39;, Math.random());
}

// 2 - task1 종료 : inner 및 outer element에 click 이벤트 리스너 등록
inner.addEventListener(&amp;#39;click&amp;#39;, onClick);
outer.addEventListener(&amp;#39;click&amp;#39;, onClick);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;역시 크롬이 맞다(글 작성자가 구글 직원이다). 다른 자바스크립트가 실행되고 있지 않다고 가정하고 microtask 가 task 의 끝에서 처리된다기 보다는 콜백들이 모두 처리된 이후에 처리된다고 보는게 맞다. 이 규칙은 콜백을 호출하는 HTML 스펙에 잘 정의되어 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;만약 &lt;a href=&quot;https://html.spec.whatwg.org/multipage/webappapis.html#stack-of-script-settings-objects&quot;&gt;자바스크립트 스택&lt;/a&gt;이 비어있다면 &lt;a href=&quot;https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint&quot;&gt;microtask 가 실행될지를 체크&lt;/a&gt;하다.
- &lt;a href=&quot;https://html.spec.whatwg.org/multipage/webappapis.html#clean-up-after-running-a-callback&quot;&gt;HTML: Cleaning up after a callback&lt;/a&gt; step 3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;microtask 대기열이 처리중이 아니라면 microtask 수행 체크는 microtask 대기열을 지나가버린다. 비슷하게 ECMAScript 는 jobs 에 대해 이렇게 말한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;job 의 실행은 단지 실행 컨택스트가 동작하지 않을때만 초기화된다.
&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues&quot;&gt;ECMAScript: Jobs and Job Queues&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;다른 브라우저들은 뭐가 잘못됐을까?&lt;/h3&gt;
&lt;p&gt;Firefox 와 Safari 에서는 mutation 콜백에서 보여줬듯이 클릭 리스너 사이에 microtask 대기열을 제대로 소진시킨다. 그러나 promise 는 좀 더 다른 방식으로 큐에 삽입된다. job 과 microtask 의 연관성이 모호하다는 것을 감안하더라도 여전히 콜백 사이에서 실행될것이라 기대된다. Firefox 이슈를 확인해보자(&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1193394&quot;&gt;Firefox ticket&lt;/a&gt;, &lt;a href=&quot;https://bugs.webkit.org/show_bug.cgi?id=147933&quot;&gt;Safari ticket&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;이전에 살펴보았듯이 Edge 에서는 promise 가 제대로 동작하지 않는다(task 로 인식). 그리고 또다른 문제는 microtask 대기열이 클릭 리스너 사이에서 소진되는 것이 아니라 모든 리스너가 호출된 다음에 호출된다. 이것이 두 클릭 로그 이후에 하나의 mutate 가 찍힌 이유다.(&lt;a href=&quot;https://connect.microsoft.com/IE/feedbackdetail/view/1658386/microtasks-queues-should-be-processed-following-event-listeners&quot;&gt;Bug ticket&lt;/a&gt;)&lt;/p&gt;
&lt;h3&gt;Level 1 boss’s angry older brother (왜 이런 표현을 쓸까..?)&lt;/h3&gt;
&lt;p&gt;그렇다면 아래처럼 자바스크립트에서 직접 click 함수를 호출하는 경우에는 어떨까?&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// 위 코드와 동일, 직접 리스너를 호출하는 아래 코드만 추가
inner.click();&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;조금 다른 결과가 나왔다. 브라우저 별로 어떻게 다른지도 살펴보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Chrome :
click - click - promise - mutate - promise - timeout - timeout

Firefox :
click - click - mutate - timeout - promise - promise - timeout

Safari :
click - click - mutate - promise - promise - timeout - timeout

Edge
click - click - mutate - timeout - promise - timeout - promise&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;다른 브라우저는 제쳐두고서라도 크롬에서도 다른 결과가 발생했다(이와중에 Edge 는 동일하다). 여러번 테스트 해보아도 동일한 결과가 나온다.&lt;/p&gt;
&lt;h3&gt;왜 다른것일까?&lt;/h3&gt;
&lt;p&gt;그 이유는 자바스크립트 코드 마지막에서 &lt;code class=&quot;language-text&quot;&gt;inner.click()&lt;/code&gt;이 실행되면 script 가 아직 종료되기 전이므로 자바스크립트 스택이 비어있지 않은 상태가 된다(자바 스크립트 스택이 비어 있지 않으므로 microtask 를 처리할 수 없다). 그렇기 때문에 microtask 가 실행되지 않고 바로 outer 로 버블링되어 클릭 리스너가 실행되는 것이다.
(mutate 가 한번만 출력되는 이유는 하나의 mutation microtask 가 등록되어 있으면 다른 mutation task 를 등록할 수 없기 때문)&lt;/p&gt;
&lt;p&gt;결론은 역시(?) 크롬이 제대로된 결과를 출력한다는 것.&lt;/p&gt;
&lt;p&gt;위에서 언급했던것 처럼 리스너 콜백이 호출된 후 자바스크립트 실행 스택이 비어있는 경우에만 microtask 체크를 수행하기 때문에 &lt;code class=&quot;language-text&quot;&gt;inner.click()&lt;/code&gt;으로 메서드가 호출중인 상태에서는 microtask 체크가 진행되지 않는다.&lt;/p&gt;
&lt;p&gt;이전에 보았던 예제에서는 microtask 가 리스너 콜백 사이에서 실행되었지만(사용자에 의해 클릭 동작이 처리되었으므로) &lt;code class=&quot;language-text&quot;&gt;.click()&lt;/code&gt;은 동기적으로 이벤트가 전달되므로 &lt;code class=&quot;language-text&quot;&gt;.click()&lt;/code&gt;을 호출하는 스크립트는 여전히 콜백 사이의 스택에 남아있게 된다. 이 규칙은 자바스크립트가 실행중일 때는 microtask 가 끼어들지 못한다는 것을 보장한다. 이는 우리가 리스너 콜백 사이에서 microtask 를 처리하지 못하고 모든 리스너가 실행된 후에 처리된다는 것을 의미한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[[ES6, react] 리액트에서 화살표 함수(arrow function)는 선택이 아닌 필수]]></title><description><![CDATA[리액트를 개발하다보면 이런 코드를 본적 있을것입니다. this(아마도 react 클래스 객체)에 속한 어떤 메서드를 다시 this 에 bind…]]></description><link>https://blueshw.github.io/2017/07/01/arrow-function/</link><guid isPermaLink="false">https://blueshw.github.io/2017/07/01/arrow-function/</guid><pubDate>Sat, 01 Jul 2017 13:00:01 GMT</pubDate><content:encoded>&lt;p&gt;리액트를 개발하다보면 이런 코드를 본적 있을것입니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;this.someFunction.bind(this);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;this(아마도 react 클래스 객체)에 속한 어떤 메서드를 다시 this 에 bind 한다라?? 굳이 왜 이런짓을 해야하는지 의문이 들만합니다.&lt;/p&gt;
&lt;p&gt;리액트에서 이러한 코드가 빈번하게 작성되는 이유를 알기 위해서 우선 &lt;code class=&quot;language-text&quot;&gt;bind()&lt;/code&gt;가 무슨 역할을 하는지부터 알아보겠습니다.&lt;/p&gt;
&lt;h4&gt;bind()&lt;/h4&gt;
&lt;p&gt;bind 함수는 바인드하는 함수에서 사용하는 &lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;의 대상을 지정해주는 역할을 합니다. 잘 사용하지 않아서 그렇지 그다지 어려운 개념은 아닙니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const objA = {
    name: &amp;quot;a&amp;quot;,
    aFunc: function() {
        console.log(this.name);
    }
}

const objB = {
    name: &amp;quot;b&amp;quot;
}

objA.aFunc(); // (1)
// a
objA.aFunc.bind(objB); // (2)
const foo = objA.aFunc.bind(objB); // (3)
foo(); (4)
// b&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;objA&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;objB&lt;/code&gt;라는 객체가 있습니다. objA 객체는 &lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt;이라는 값과 &lt;code class=&quot;language-text&quot;&gt;aFunc&lt;/code&gt;라는 함수를 속성으로 가지고 있습니다. 반면 objB 객체는 &lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt;이라는 값만 가지고 있죠.&lt;/p&gt;
&lt;p&gt;(1) objA 의 aFunc 함수를 실행하면 예상대로 &lt;code class=&quot;language-text&quot;&gt;a&lt;/code&gt;가 출력됩니다.&lt;/p&gt;
&lt;p&gt;(2) objA 객체의 aFunc 함수에서 bind(objB)를 호출합니다. 함수가 호출되었지만, 아무것도 출력되지 않죠. 다만, 원본 aFunc 함수와 동일한 기능을 하는 바인딩된 새로운 함수가 만들어집니다. 이때, bind 메서드에 전해진 인자는 복사된 바인딩 함수의 this 로 전달됩니다. 즉, aFunc 함수내의 &lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;가 &lt;code class=&quot;language-text&quot;&gt;objB&lt;/code&gt;가 되는 것이죠. 이게 &lt;code class=&quot;language-text&quot;&gt;bind()함수&lt;/code&gt;가 하는 일의 전부입니다.&lt;/p&gt;
&lt;p&gt;(3) 바인드 함수를 변수에 할당합니다.&lt;/p&gt;
&lt;p&gt;(4) 실행하면 &lt;code class=&quot;language-text&quot;&gt;b&lt;/code&gt;가 출력됩니다.&lt;/p&gt;
&lt;h3&gt;React 에서의 bind()&lt;/h3&gt;
&lt;p&gt;처음 잠깐 살펴보았지만, 리액트에서 bind()함수는 다음과 같이 사용됩니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import React from &amp;#39;react&amp;#39;;

class BindTest extends React.Component {
    handleClick() {
        console.log(this);
    }
    render() {
        return &amp;lt;button type=&amp;quot;button&amp;quot; onClick={this.handleClick.bind(this)}&amp;gt;Goodbye bind&amp;lt;/button&amp;gt;;
    }
}
export default BindTest;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;간단한 React 컴포넌트입니다. 버튼을 클릭하면 &lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;에 해당하는 정보가 출력됩니다.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/bind-dd9e929e444a704bee081d20bb5eec3f-3dc4e.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 67.38428417653391%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsSAAALEgHS3X78AAACGklEQVQ4y51TXW7aQBCGRmqrphLPVS7QHqNSrxA/5A69WV96g/ahKhFB4B8KBDDEsP4H22sbA+v1dNbGBKWt1PaTPo1nxvvN7M5uo9H42Oh9+/K+3fl68/22cz0ejaTpdCpNJhNJVTWpe9eRNE2T1OFQUhVFUhRZGgxUzMmVLyvXsqbd3HY6HxoV3rycab2+4xugDUfwsFhAGIZwOBwgTVNYWS4sjSWsZlMgpgWm5cBiToCsbCAW+jaBjW2B2u/9QLEm8tnr6WR8t/bXYNs2cxyHC/q+zz3P456/5o5tc1vXuWmamPM4IRYnpsMt2+WURoxuNlhEV1DshWjxkhDSLYoCckRxBOf8xBIAdeaJLXJARFGkotbzUhC32BVBkRRLa2IEzv0/sBSklP4qiMjh31GuCYLgUbDeMradR1EMYUQhjmNRtbQRjdAmQOtYEp/yaZqUgoSYj4Lz+azL2B6SmOau50MYoAANIQoCCDZroKHwj8RiiSCKRVGInfk5YxkYxkMl2Gw0L13X6cabBEzDzD3XhdAPscsY2J5BlmXAdjnssh2wA4M8y4Ft0e6q08GhlR9heLZlvCJ3qSeqLNn+sOfVCIGL/89ZxuGM1ajZccrKSVBMSBxtus7OxlLAcfJ/NZntdjuuBV/JivxpKI+MXrs/brfb97Ks3D8FPsffEp/oWNd1YzAYfK4v9gXyCvkO+fY/KdZetVqti5+XKCbd36mqhwAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;bind&quot;
        title=&quot;&quot;
        src=&quot;/static/bind-dd9e929e444a704bee081d20bb5eec3f-fb8a0.png&quot;
        srcset=&quot;/static/bind-dd9e929e444a704bee081d20bb5eec3f-1a291.png 148w,
/static/bind-dd9e929e444a704bee081d20bb5eec3f-2bc4a.png 295w,
/static/bind-dd9e929e444a704bee081d20bb5eec3f-fb8a0.png 590w,
/static/bind-dd9e929e444a704bee081d20bb5eec3f-526de.png 885w,
/static/bind-dd9e929e444a704bee081d20bb5eec3f-3dc4e.png 929w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;버튼 태그의 onClick 속성을 보면 bind() 함수가 사용되고 있는걸 알수 있습니다. 근데 좀 이상합니다. this 의 handleClick 함수에다가 this 객체를 바인드시켰습니다. 같은 this 인데 굳이 또 바인드해주는 이유가 뭘까요? bind 함수를 빼보겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import React from &amp;#39;react&amp;#39;;

class WithoutBindTest extends React.Component {
    handleClick() {
        console.log(this);
    }
    render() {
        return &amp;lt;button type=&amp;quot;button&amp;quot; onClick={this.handleClick}&amp;gt;Goodbye bind without this&amp;lt;/button&amp;gt;;
    }
}
export default WithoutBindTest;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;어떤 결과가 나올까요?&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/withoutbind-926c1336fb351d657eafc19b76819691-3dc4e.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 67.38428417653391%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsSAAALEgHS3X78AAAB+klEQVQ4y6WT227TQBCGA5UAAVKuUV8AHqMSr1Bf9Bn6aNzwBnABoiRRGh+auHac5rC212fv2oliezOM7SaBchX4pV+zs6P5dr277nQ6153hty8XP3pfr77f/LzUJxPJnJqSYRiSoqjSoN+TVFWVlPFYUmRZkuWRpGkK1kZtPpIvR6p6ddPrfey0evdqqg5vabAEbaLDYj6HOEmgKArI8xxWjgfLxRJWUxOI7YDtUHiYESArF4iDuUsgch1Qbod3CHuGfv7WNPR+6Ac1rLRtW1BKRRAEwvd94QehoK4rXMsSbc0XhDiC2FQ4ricYS0sWRbiIJSPsZb3FN4SQgRACOOdVWZS7Wpgf3AigjTvxJO4qQKVpqiDrRQNMkmQArZpi3X6Cmx7G2O/A+A/giWp64jg+AvFMGmDKeJWyDLfP8fMzXJUD4/s8b/I0ZU2tdQ7r9boBIuMInE21wXYTQRI7FaUriCMKPKWYu/Ucjj3IeAB5Fjbe5BFwFkDgE/C9ZVUVDC/UOAIpGQ2KbAosHFd5cg9ZrAOPJpAnBmzz+WEMwkd7TSw2BHgyQz9U1daF0NOPQM8P+4+XUYonai/8b9Xz2FLH8vEM5QMQn4sC/yk8S30PfC3L8ifLshb4u+mmad6f4rqn7tU07fP+YZ+hz9Ef0O//0XXvebfbPfsFbR8lknUs0+cAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;withoutbind&quot;
        title=&quot;&quot;
        src=&quot;/static/withoutbind-926c1336fb351d657eafc19b76819691-fb8a0.png&quot;
        srcset=&quot;/static/withoutbind-926c1336fb351d657eafc19b76819691-1a291.png 148w,
/static/withoutbind-926c1336fb351d657eafc19b76819691-2bc4a.png 295w,
/static/withoutbind-926c1336fb351d657eafc19b76819691-fb8a0.png 590w,
/static/withoutbind-926c1336fb351d657eafc19b76819691-526de.png 885w,
/static/withoutbind-926c1336fb351d657eafc19b76819691-3dc4e.png 929w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt;이 출력되었습니다. 왜 null 이 출력되었을까요?&lt;/p&gt;
&lt;p&gt;이 내용을 이해하려면 자바스크립트에서의 &lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;에 대해 어느정도 알고 있어야 합니다.&lt;/p&gt;
&lt;h3&gt;this&lt;/h3&gt;
&lt;p&gt;객체지향 언어에서의 일반적인 this 의 의미(현재 객체를 지칭)와는 달리 자바스크립트의 this 는 실행시의 context 를 말하죠. 아래 예제를 보면,&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const thisTest = function() {
    console.log(this.value);
}
thisTest.value = &amp;quot;I am this&amp;quot;;
thisTest();&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;quot;I am this&amp;quot;&lt;/code&gt;가 나올거라는 예상과는 달리 &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt;가 출력됩니다. 왜냐하면 &lt;code class=&quot;language-text&quot;&gt;thisTest()&lt;/code&gt;가 출력될 때의 context 가 전역객체이기 때문입니다. thisTest.value 는 thisTest 에 속성인데 전역객체에서 value 를 찾으려고 하니 undefined 가 나올수 밖에 없습니다(window 객체가 아니라 undefined 인 이유는 React 가 기본적으로 strict 모드에서 실행되기 때문입니다).&lt;/p&gt;
&lt;p&gt;“I am this”를 출력하려면, this 에 해당하는 객체의 메서드를 호출하면 this.value 값을 가져올 수 있습니다. 아래 예제를 보면,&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const thisTest = function() {
    console.log(this.value);
}
thisTest.value = &amp;quot;I am this&amp;quot;;
thisTest.func = function(){
    console.log(this.value);
}
thisTest.func();&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;thisTest.func&lt;/code&gt; 함수를 만들어서 그안에서 &lt;code class=&quot;language-text&quot;&gt;this.value&lt;/code&gt;를 출력합니다. thisTest 객체의 func() 메서드를 호출하면 이 때는 &lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;가 thisTest 가 되기 때문에 정상적으로 this.value 를 가져와 “I am this”를 출력합니다.&lt;/p&gt;
&lt;p&gt;이제, 리액트로 다시 돌아가보죠.&lt;/p&gt;
&lt;h3&gt;React 에서의 this&lt;/h3&gt;
&lt;p&gt;WithoutBindTest 클래스의 render() 함수를 다시 살펴보겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;render() {
    return &amp;lt;button type=&amp;quot;button&amp;quot; onClick={this.handleClick}&amp;gt;Goodbye bind without this&amp;lt;/button&amp;gt;;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;컴포넌트의 render()함수가 실행되면 DOM 이 그려질것입니다. 이때 this 는 WithoutBindTest 객체를 가리키는것이 맞습니다. 하지만 handleClick()함수가 호출될때의 this 는 WithoutBindTest 가 아닌 전역객체(Window)를 의미합니다. 왜냐하면 this 라는 값은 호출하는 문맥(context)에의해 좌우되는데 클릭이 실행되는 문맥이 바로 전역(window)객체이기 때문이죠.&lt;/p&gt;
&lt;h3&gt;Arrow Function&lt;/h3&gt;
&lt;p&gt;click, change 등의 이벤트 리스너를 붙여줄때마다 &lt;code class=&quot;language-text&quot;&gt;bind()&lt;/code&gt;함수를 작성하는건 귀찮은 일입니다. ES6 의 &lt;code class=&quot;language-text&quot;&gt;화살표함수&lt;/code&gt;를 사용하면 이 문제를 간단히 해결할 수 있습니다. BindTest 를 화살표 함수를 이용해 새로 작성해보았습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import React from &amp;#39;react&amp;#39;;

class BindTest extends React.Component {
    handleClick = () =&amp;gt; {
        console.log(this);
    }
    render() {
        return &amp;lt;button type=&amp;quot;button&amp;quot; onClick={this.handleClick}&amp;gt;Goodbye bind&amp;lt;/button&amp;gt;;
    }
}
export default BindTest;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이제는 this 가 무엇인지 걱정할 필요가 없습니다. 화살표 함수의 this 는 외부함수(부모함수)의 this 를 상속받기 때문에 this 는 항상 일정합니다. 위 예제의 경우에는 BindTest 클래스(사실 함수입니다)가 되겠죠.&lt;/p&gt;
&lt;h3&gt;결론&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;bind()함수는 전달된 인자를 this 로 보내는 바인딩 함수를 만듭니다.
this 는 다른 언어와 달리 실행 문맥(context)에 따라 변합니다.
React 에서 이벤트 핸들러 함수를 바인드할때 화살표 함수를 사용합니다.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[[번역] 프레젠테이션 컴포넌트와 컨테이너 컴포넌트]]></title><description><![CDATA[원본 :  https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0…]]></description><link>https://blueshw.github.io/2017/06/26/presentaional-component-container-component/</link><guid isPermaLink="false">https://blueshw.github.io/2017/06/26/presentaional-component-container-component/</guid><pubDate>Mon, 26 Jun 2017 20:04:59 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;원본 : &lt;a href=&quot;https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0&quot;&gt;https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0&lt;/a&gt;&lt;br&gt;
2 년이나 지난 글이지만, 컴포넌트를 어떻게 구현해야 하는 문제에 있어서는 이만한 가이드가 없다고 생각해서 번역해보았습니다.&lt;br&gt;
자연스럽지 못한 부분, 의역이 다수 포함되어 있을 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;리액트 어플레케이션을 만들때 제가 찾은 아주 유용하면서 간단한 패턴이 있습니다. 만약 여러분이 &lt;a href=&quot;https://facebook.github.io/react/blog/2015/03/19/building-the-facebook-news-feed-with-relay.html&quot;&gt;현재 리액트를 사용한다면&lt;/a&gt;, 이미 알고 있을지도 모릅니다. &lt;a href=&quot;https://medium.com/@learnreact/container-components-c0e67432e005&quot;&gt;이 페이지&lt;/a&gt;)가 잘 설명해 줄것입니다. 하지만, 저는 몇가지 더 얘기하고 싶네요.&lt;/p&gt;
&lt;p&gt;여러분은 컴포넌트를 더 쉽게 재사용할 수 있는 방법과 왜 컴포넌트를 두개의 카테고리로 나눠야 하는지에 대한 이유를 알게 될 것입니다. 이미 들어보았던, Fat and Skinny, Smart and Dumb, Stageful and Pure, 화면과 컴포넌트 등과 같은 개념들이 이미 있지만 저는 이것을 컨테이너와 프레젠테이션 컴포넌트(*)라 부르겠습니다. 이것들이 모두 동일한 개념은 아니지만, 기본적인 아이디어는 비슷합니다.&lt;/p&gt;
&lt;h3&gt;프레젠테이션 컴포넌트&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;어떻게 보여지는지와 관련있다.&lt;/li&gt;
&lt;li&gt;프레젠테이션 컴포넌트와 컨테이너 컴포넌트가 모두 그 안에 들어가 있을것(**)이고, 일부 DOM 마크업과 스타일도 가지고 있다.&lt;/li&gt;
&lt;li&gt;종종 this.props.children 을 통해서 노출된다.&lt;/li&gt;
&lt;li&gt;Flux 액션이나 stores 등과 같은 앱의 나머지 부분들에 의존적이지 않다.&lt;/li&gt;
&lt;li&gt;데이터를 가져오거나 변경하는 방법에 대해서 관여할 필요가 없다.&lt;/li&gt;
&lt;li&gt;props 를 통해 배타적으로 callback 함수와 데이터를 받는다.&lt;/li&gt;
&lt;li&gt;상태를 거의 가지고 있지 않다(만약 상태를 가지고 있다면, 데이터에 관한 것이 아닌 UI 상태에 관한 것이다).&lt;/li&gt;
&lt;li&gt;만약 상태, 생명주기, hooks, 또는 퍼포먼스 최적화가 필요없다면, &lt;a href=&quot;https://facebook.github.io/react/blog/2015/10/07/react-v0.14.html#stateless-functional-components&quot;&gt;유틸함수&lt;/a&gt;로서 쓰여질것이다.&lt;/li&gt;
&lt;li&gt;예를들면 페이지, 사이드바, 스토리, 유저정보, 리스트 등이 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;컨테이너 컴포넌트&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;어떻게 동작하는지와 관련있다.&lt;/li&gt;
&lt;li&gt;프레젠테이션 컴포넌트와 마찬가지로 프레젠테이션 컴포넌트와 컨테이너 컴포넌트 모두 가지고 있지만 감싼 divs 를 제외하고는 DOM 마크업을 가지고 있지 않는다. 스타일 역시 가지고 있지 않는다.&lt;/li&gt;
&lt;li&gt;데이터와 기능(행동)을 프레젠테이션 컴포넌트와 다른 컴포넌트에 제공한다.&lt;/li&gt;
&lt;li&gt;Flux(or Redux) 액션을 호출하고, 프레젠테이션 컴포넌트에 콜백함수로써 제공한다.&lt;/li&gt;
&lt;li&gt;데이터 소스 역할을 하기 때문에 상태가 자주 변경된다.&lt;/li&gt;
&lt;li&gt;직접 만드는것 보단 대게 React Redux 의 connect() 함수, Relay 의 createContainer() 함수, Flux Utils 의 Container.create()와 같은 &lt;a href=&quot;https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750&quot;&gt;Higher Order Components&lt;/a&gt;를 이용해서 만들어진다.&lt;/li&gt;
&lt;li&gt;예를들면 유저페이지, 팔로워 사이드바, 스토리 컨테이너, 팔로우한 유저 리스트 등이 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;저는 이것들을 확실하게 구분하기 위하여 서로 다른 폴더에 생성합니다.&lt;/p&gt;
&lt;h3&gt;장점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;이 방법으로 컴포넌트를 작성하면 당신의 앱(기능)과 UI 에 대한 구분을 이해하기가 더 수월하다.&lt;/li&gt;
&lt;li&gt;재사용성이 더 뛰어나다. 완전히 서로 다른 상태값과 함께 같은 프레젠테이션 컴포넌트를 사용할 수 있고, 재사용 될 수 있는 별도의 컨테이너 컴포넌트로 변경할 수 있다.&lt;/li&gt;
&lt;li&gt;프레젠테이션 컴포넌트는 말하자면 앱의 팔레트와 같다. 앱의 싱글페이지 위에서 앱의 로직을 건드리지 않고 디자이너에게 모든 변화를 조정하게 할 수 있다.&lt;/li&gt;
&lt;li&gt;이것은 사이드바, 페이징, 컨텍스트메뉴와 같은 레이아웃 컴포넌트를 추출하도록 할것이고, 이것은 동일한 마크업이나 몇몇의 컨테이너 레이아웃을 반복해서 작성하는 대신 this.props.children 을 통해서 구현될 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;컴포넌트는 DOM 을 생성하지 말아야 합니다. 컴포넌트는 단지 UI 와 관련된 것들을 조합하는 것을 제공하는 것이 필요합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이러한 이점을 당신의 앱에 적용해보세요.&lt;/p&gt;
&lt;h3&gt;언제 컨테이너를 도입해야하나요?&lt;/h3&gt;
&lt;p&gt;우선 앱을 만들때 프레젠테이션 컴포넌트를 먼저 만드세요. 그러면 너무 많은 props 를 중간 컴포넌트로 보내야 한다는 것을 깨닫게 될것입니다. 전달받은 props 를 사용하지 않고 아래로 전달하기만 하는 컴포넌트나 자식 컴포넌트가 더 많은 데이터를 필요로 할때 모든 중간 컴포넌트를 재구성해야하는 컴포넌트들이 있다는 것을 알게 될것입니다. 바로 이 때 컨테이너 컴포넌트를 도입해야합니다. 데이터나 아무 상관없는 중간 컴포넌트에 대해 걱정이 없는 leaf 컴포넌트의 행위가 담긴 props 를 얻을 수 있는 방법이 될 것입니다.&lt;/p&gt;
&lt;p&gt;리팩토링이 진행중이기 때문에 처음부터 도입하려고 시도해서는 안됩니다. 이 패턴을 실험해보려면, 어떤때에 함수를 추출할지를 아는것 처럼 어떤때에 컨테이너를 추출해야하는지를 직감으로 알아야 합니다. 저의 &lt;a href=&quot;https://egghead.io/series/getting-started-with-redux&quot;&gt;free Redux Egghead series&lt;/a&gt;가 당신에게 도움이 될것입니다.&lt;/p&gt;
&lt;h3&gt;다른 분리방법들&lt;/h3&gt;
&lt;p&gt;프레젠테이션 컴포넌트와 컨테이너 컴포넌트의 차이는 기술적인 부분이 아니라는 것을 이해하는 것은 중요합니다. 이것은 오히려 용도에 따른 차이입니다.&lt;/p&gt;
&lt;p&gt;대조적으로, 여기 기술적으로 관련된 구분이 몇가지 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Stateful and Stateless
어떤 컴포넌트들은 React 의 setState() 메소드를 사용한다. 컨테이너 컴포넌트는 상태가 자주 변하는 경향(stateful)이 있고 프레젠테이션 컴포넌트는 그렇지 않은 경향(stateless)이 있다. 다만 이것은 엄격한 규칙은 아니다. 프레젠테이션 컴포넌트에서 상태가 자주 바뀔수도 있고, 컨테이너 컴포넌트에서 상태변화가 없을수도 있다.&lt;/li&gt;
&lt;li&gt;Classes and Function
&lt;a href=&quot;https://facebook.github.io/react/blog/2015/10/07/react-v0.14.html#stateless-functional-components&quot;&gt;리액트 0.14 부터&lt;/a&gt; 컴포넌트를 클래스와 함수 모두로 선언이 가능하다. 함수 컴포넌트는 정의가 간단하지만 클래스 컴포넌트에 비해서 몇가지 부족한 점이 있다. 이러한 제한의 일부는 미래에는 없어질 수도 있지만 현재는 존재한다. 왜냐하면 함수 컴포넌트는 이해하기 쉽기 때문이다. 만약 state, 라이프사이클 후킹 또는 퍼포먼스 최적화가 필요하다면 반드시 클래스 컴포넌트를 사용해야한다. 왜냐하면 이들은 클래스 컴포넌트에서만 사용할 수 있기 때문이다.&lt;/li&gt;
&lt;li&gt;Pure and Impure
만약 같은 props 와 state 가 주어졌을때 같은 결과가 돌아오는것이 보장된다면 사람들은 컴포넌트가 pure 하다고 말한다. 퓨어 컴포넌트는 클래스나 함수로 모두 정의 될수 있습니다. 그리고 stateful 하거나 stateless 할수도 있다. 퓨어 컴포넌트의 또다른 중요한 점은 props 와 state 의 변화에 깊게 관여하지 않다. 그래서 퓨어 컴포넌트의 렌더링 퍼포먼스는 shouldComponentUpdate() 함수의 얕은 비교에 의해 최적화 될 수 있다. 현재는 클래스에서만 shouldComponentUpdate() 함수를 사용할 수 있지만 아마도 나중에는 함수에서는 사용할 수 있을것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;프레젠테이션 컴포넌트와 컨테이너 컴포넌트 둘다 어느쪽 컴포넌트에나 들어갈 수 있습니다. 제 경험에 의하면 프레젠테이션 컴포넌트는 stateless 한 pure 함수가 되는 경향이 있고, 컨테이너 컴포넌트는 stateful 한 pure 클래스가 되려는 경향이 있습니다. 하지만 규칙은 아니고 주목할만한 것입니다. 왜냐하면 저는 구체적인 상황들에서 정확히 반대의 경우로 만들어지는 것을 보았기 때문입니다.&lt;/p&gt;
&lt;h3&gt;예제&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/chantastic/fc9e3853464dffdb1e3c&quot;&gt;This Gist&lt;/a&gt; by &lt;a href=&quot;https://twitter.com/chantastic&quot;&gt;Michael Chan&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;읽을거리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://egghead.io/series/getting-started-with-redux&quot;&gt;Getting Started with Redux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750&quot;&gt;Mixins are Dead, Long Live Composition&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/@learnreact/container-components-c0e67432e005&quot;&gt;Container Components&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bradfrost.com/blog/post/atomic-web-design/&quot;&gt;Atomic Web Design&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://facebook.github.io/react/blog/2015/03/19/building-the-facebook-news-feed-with-relay.html&quot;&gt;Building the Facebook News Feed with Relay&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;각주&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;* 이전 버전의 아티클에서 저는 smart and dumb 컴포넌트라고 불렀습니다. 그러나 이것은 프레젠테이션 컴포넌트에게 너무나 심한 표현이었습니다.
그리고 가장 중요한점은 목적의 차이에 대해서 정확하게 설명할 수 없다는 것이었습니다. 저는 새로운 표현이 더 낫다고 생각했고 당신도 그랬으면 좋겠네요!&lt;/p&gt;
&lt;p&gt;** 이전 버전의 아티클에서 저는 프레젠테이션 컴포넌트가 프레젠테이션 컴포넌트만 포함해야 한다고 주장했었습니다.
저는 더이상 다른 케이스를 생각해보지 않았습니다. 어떤 컴포넌트가 프레젠테이션 컴포넌트인지 컨테이너 컴포넌트인지는 그것의 구체적인 구현방법에 따라 달라지는 것입니다. 프레젠테이션 컴포넌트는 사이트 요청에 의한 변화가 없다면 컨테이너 컴포넌트로 변경이 가능해야 합니다. 그러므로 프레젠테이션 컴포넌트와 컨테이너 컴포넌트는 둘다 서로를 포함할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[[react] react-router(리액트 라우터) v3 VS v4]]></title><description><![CDATA[react-router v4 가 릴리즈 되면서 라우팅 적용 방식이 바뀌었습니다.
이전버전(v3)까지는 일반적으로 사용하는 정적 라우팅(Static Routing)이였다면, 동적 라우팅(Dynamic Routing…]]></description><link>https://blueshw.github.io/2017/06/22/static-routing-vs-dynamic-routing/</link><guid isPermaLink="false">https://blueshw.github.io/2017/06/22/static-routing-vs-dynamic-routing/</guid><pubDate>Thu, 22 Jun 2017 22:55:43 GMT</pubDate><content:encoded>&lt;p&gt;react-router v4 가 릴리즈 되면서 라우팅 적용 방식이 바뀌었습니다.
이전버전(v3)까지는 일반적으로 사용하는 정적 라우팅(Static Routing)이였다면, 동적 라우팅(Dynamic Routing)이 적용되었는데요.
여기서 말하는 정적 라우팅이란 일반적으로 최상위 페이지에 라우팅 정보를 모두 기입해 두고, 특정 패스가 브라우저에 입력되었을 때 해당되는 컴포넌트를 그려주는 방식을 말합니다. 모든 라우팅 정보가 한곳에 위치하기 때문에 관리하기 쉽다는 장점이 있겠지만, 정적이라는 특징 때문에 확장성과 재사용성은 떨어질 수 있습니다. 반면에 동적 라우팅의 경우에는 라우팅 정보를 한곳에 모아둘 필요가 없습니다. 라우팅이 필요한 컴포넌트에 직접 붙여 사용할 수 있기 때문에 동적으로 컴포넌트를 구성하는데 더 효율적이라 할 수 있습니다.&lt;/p&gt;
&lt;p&gt;이외에도 몇가지 바뀐점이 꽤 있다보니 이전버전과 어떤 점이 달라졌나 비교해볼까 합니다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://reacttraining.com/react-router/&quot;&gt;공식 홈페이지 바로가기&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;설치&lt;/h2&gt;
&lt;p&gt;설치하는 모듈을 선택할 수 있는데요. 이전 버전까지는 &lt;code class=&quot;language-text&quot;&gt;react-router&lt;/code&gt; 하나만 사용 할 수 있었는데,
이번에 버전업 되면서 몇가지 늘었습니다. react-router 는 코어 모듈이구요.
이밖에도 &lt;code class=&quot;language-text&quot;&gt;react-router-dom&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;react-router-native&lt;/code&gt; 등이 추가되었습니다.
react-router-dom 은 react-router 모듈에 dom 이 바인딩 되어 있다고 보시면 됩니다. 즉, 웹 개발자들을 위한 모듈이죠.
그리고 react-router-native 는 이름에서도 알 수 있듯이 react-native 를 개발할 때 사용하는 모듈입니다.
저는 웹개발자이기 때문에 당연히 react-router-dom 을 사용하도록 하겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# v3
yarn add react-router
npm install react-router

# v4
yarn add react-router-dom
npm install react-router-dom&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;v3 VS v4&lt;/h2&gt;
&lt;p&gt;v3 와 v4 의 차이점을 간략히 비교해 보았습니다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;v3&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;v4&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;라우팅&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;정적(static) 라우팅&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;동적(dynamic) 라우팅&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;Route 컴포넌트&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;라우트 정보를 프로젝트 최상단에 모두 정의&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;코드 어디에나 사용 가능&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;계층구조&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;라우트 정보를 계층구조로 표현&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;계층구조 대신 렌더링 되는 컴포넌트에 직접 구현 (계층구조 표현 안됨)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;히스토리&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;browserHistory 에 저장하여 Router 객체에 props 로 삽입&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;BrowserRouter 객체에 내장&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;v3 의 라우팅 코드&lt;/h2&gt;
&lt;p&gt;프로젝트 구조를 자세히 설명하지는 않겠습니다.
간단히 구조만 살펴볼 것이기 때문에 최소한의 파일만으로 구성하였습니다.&lt;/p&gt;
&lt;p&gt;react-router v3 는 정적 라우팅을 사용하기 때문에 미리 라우팅 정보를 탑 레벨에서 모두 정해두고 시작합니다.
react-router 는 계층구조로 설정할 수가 있는데, 최상위에 &lt;code class=&quot;language-text&quot;&gt;Router&lt;/code&gt; 컴포넌트를 만들고 &lt;code class=&quot;language-text&quot;&gt;Route&lt;/code&gt;(실제 패스에 따라 컴포넌트를 교체해주는 역할) 컴포넌트를 아래에 만듭니다. 그리고 또 그 아래에 &lt;code class=&quot;language-text&quot;&gt;IndexRoute&lt;/code&gt;가 있고 여러개의 &lt;code class=&quot;language-text&quot;&gt;Route&lt;/code&gt; 컴포넌트가 존재합니다.
어떤 url 이 브라우저에 입력되면(또는 앵커 태그가 클릭되면), 각 라우터에 해당하는 컴포넌트가 렌더링 되는 구조입니다.&lt;/p&gt;
&lt;p&gt;예를 들어 &lt;code class=&quot;language-text&quot;&gt;http://localhost:3000/second&lt;/code&gt; url 이 브라우저에 입력되면 path 가 &lt;code class=&quot;language-text&quot;&gt;/&lt;/code&gt;인 라우트를 먼저 찾고 렌더링 합니다. 그리고 뒤에 해당되는 &lt;code class=&quot;language-text&quot;&gt;second&lt;/code&gt;를 찾아서 해당되는 컴포넌트를 렌더링 합니다.&lt;/p&gt;
&lt;p&gt;App.js 파일의 App 클래스를 보면, Header 컴포넌트 아래에 &lt;code class=&quot;language-text&quot;&gt;{this.props.childern}&lt;/code&gt;이 있는데, 이 부분이 바로 path 가 &lt;code class=&quot;language-text&quot;&gt;/&lt;/code&gt;인 라우트 아래의 IndexRoute, first, second, third 인 부분이 렌더링 되는곳 입니다.&lt;/p&gt;
&lt;p&gt;마지막으로 라우터의 히스토리는 browserHistory 에 저장해 둡니다. 그래야 브라우저에서 &lt;code class=&quot;language-text&quot;&gt;뒤로가기&lt;/code&gt;를 했을때 이전 페이지를 불러올 수 있기 때문이죠.&lt;/p&gt;
&lt;h4&gt;index.js&lt;/h4&gt;
&lt;p&gt;앱이 처음 시작하는 부분인 index.js 입니다.
index 에서 직접 라우팅을 구현하였습니다.
third 뒤의 &lt;code class=&quot;language-text&quot;&gt;:id&lt;/code&gt; 부분은 컴포넌트의 &lt;code class=&quot;language-text&quot;&gt;this.props.params.id&lt;/code&gt; 형태로 전달되어 컴포넌트 내에서 사용할 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import React from &amp;#39;react&amp;#39;;
import ReactDOM from &amp;#39;react-dom&amp;#39;;
import { Router, Route, IndexRoute, browserHistory } from &amp;#39;react-router&amp;#39;;
import App, { Home, First, Second, Third, Item } from &amp;#39;./App.js&amp;#39;;

ReactDOM.render(
  &amp;lt;Router history={browserHistory}&amp;gt;
    &amp;lt;Route path=&amp;quot;/&amp;quot; component={App}&amp;gt;
      &amp;lt;IndexRoute component={Home} /&amp;gt;
      &amp;lt;Route path=&amp;quot;first&amp;quot; component={First} /&amp;gt;
      &amp;lt;Route path=&amp;quot;second&amp;quot; component={Second} /&amp;gt;
      &amp;lt;Route path=&amp;quot;third/&amp;quot; component={Third}&amp;gt;
        &amp;lt;Route path=&amp;quot;:id&amp;quot; component={Item} /&amp;gt;
      &amp;lt;/Route&amp;gt;
    &amp;lt;/Route&amp;gt;
  &amp;lt;/Router&amp;gt;,
  document.getElementById(&amp;#39;root&amp;#39;),
);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Header.js&lt;/h4&gt;
&lt;p&gt;헤더의 메뉴 부분입니다.
버튼에 클릭했을때 라우터의 정보에 따라 컴포넌트를 바꿔줍니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import React, { Component } from &amp;#39;react&amp;#39;;
import { Link } from &amp;#39;react-router&amp;#39;;

class Header extends Component {
  render() {
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;ul&amp;gt;
          &amp;lt;li&amp;gt;&amp;lt;Link to={&amp;#39;/&amp;#39;}&amp;gt;홈&amp;lt;/Link&amp;gt;&amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;&amp;lt;Link to={&amp;#39;/first&amp;#39;}&amp;gt;첫번째&amp;lt;/Link&amp;gt;&amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;&amp;lt;Link to={&amp;#39;/second&amp;#39;}&amp;gt;두번째&amp;lt;/Link&amp;gt;&amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;&amp;lt;Link to={&amp;#39;/third&amp;#39;}&amp;gt;세번째&amp;lt;/Link&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}

export default Header;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;App.js&lt;/h4&gt;
&lt;p&gt;헤더를 제외한 모든 컴포넌트가 들어있는 App.js 파일입니다.&lt;/p&gt;
&lt;p&gt;App 컴포넌트는 최상위 패스인 &lt;code class=&quot;language-text&quot;&gt;/&lt;/code&gt;에서 렌더링 되는 부분인데요. &lt;code class=&quot;language-text&quot;&gt;Header&lt;/code&gt;와 같이 공통으로 사용하는 컴포넌트를 여기에 붙여줍니다.
그러면, 어떤 url 로 이동하더라도 Header 는 계속 노출되겠지요.&lt;/p&gt;
&lt;p&gt;Third 부분이 v4 와 다른부분인데요. 컴포넌트 내에서 직접 라우팅 정보를 지정할 수 없기 때문에,
우회하는 방법으로 &lt;code class=&quot;language-text&quot;&gt;this.props.children&lt;/code&gt; 컴포넌트가 있는지 여부에 따라서 어떻게 렌더링할지를 결정합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import React, { Component } from &amp;#39;react&amp;#39;;
import Header from &amp;#39;./Header.js&amp;#39;;
import { Link } from &amp;#39;react-router&amp;#39;;

class App extends Component {
  render() {
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;Header /&amp;gt;
        {this.props.children}
      &amp;lt;/div&amp;gt;
    );
  }
}

export class Home extends Component {
  render() {
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;h1&amp;gt;홈 페이지&amp;lt;/h1&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}

export class First extends Component {
  render() {
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;h2&amp;gt;1, 첫번째 페이지&amp;lt;/h2&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}

export class Second extends Component {
  render() {
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;h3&amp;gt;2, 두번째 페이지&amp;lt;/h3&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}

export class Third extends Component {
  render() {
    console.dir(this.props);
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;Link to={&amp;#39;/third/1&amp;#39;} style={{ marginRight: &amp;#39;5px&amp;#39; }}&amp;gt;
          1번
        &amp;lt;/Link&amp;gt;
        &amp;lt;Link to={&amp;#39;/third/2&amp;#39;}&amp;gt;
          2번
        &amp;lt;/Link&amp;gt;
        {this.props.children
          ? this.props.children
          : &amp;lt;div&amp;gt;
              &amp;lt;h3&amp;gt;id를 선택해 주세요.&amp;lt;/h3&amp;gt;
            &amp;lt;/div&amp;gt;}
      &amp;lt;/div&amp;gt;
    );
  }
}

export class Item extends Component {
  render() {
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;h3&amp;gt;{this.props.params.id}&amp;lt;/h3&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}

export default App;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;결과 화면입니다.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/result-fb1092558d8f5b50a2ba2af3b262bc43-ac1ec.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 67.60259179265658%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsSAAALEgHS3X78AAABkUlEQVQ4y62S307CMBTG0XfxHbzwGdyF8VWU6B0kkGjiE5mYsCWEP0YYCNkfDKyjHdsAJSLJ1rNjW3ZhojcgX/LldP263zlpWujVjdN66+nisaafdzsdzbZtzXEcbTAYaK1WSzNNUzNfB5rZ62ky7/e7Yt0VtS++TZmftzvdi1qtdlKQcl+e9XhJsG876HkefqxW+Lle42azwcVijsT3kREPp1OKs1mIHmFIfYa+3J9RpJTiklFsNJvVLdC19a/1FzLGUkIICCgEQQBRFEEURiCAQC0LPNsBnzIYj33wJj5YYi+KQ4jjOF0EDNvt53sFDMOZ/h6ucbX85BlmWZqmGedc1SRJ1FoGHCDjeSYtBRwyAEhRyLLsLXCxnBvB6APndMVlgBnuInla/TcajbbAN2tiIKhQtsUdLaWArutugYT4Rt5NAXca7y+guFQjD3leDwc8+ITZfvoF1POGiTDs4SQH3imgeMANPICGw+GDApZKpctKpXJbLpevhK/38FW1Wr0pFotnhR86/qePJEQMWvgGW9KB3SlysaIAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;result&quot;
        title=&quot;&quot;
        src=&quot;/static/result-fb1092558d8f5b50a2ba2af3b262bc43-fb8a0.png&quot;
        srcset=&quot;/static/result-fb1092558d8f5b50a2ba2af3b262bc43-1a291.png 148w,
/static/result-fb1092558d8f5b50a2ba2af3b262bc43-2bc4a.png 295w,
/static/result-fb1092558d8f5b50a2ba2af3b262bc43-fb8a0.png 590w,
/static/result-fb1092558d8f5b50a2ba2af3b262bc43-526de.png 885w,
/static/result-fb1092558d8f5b50a2ba2af3b262bc43-fa2eb.png 1180w,
/static/result-fb1092558d8f5b50a2ba2af3b262bc43-08f6a.png 1770w,
/static/result-fb1092558d8f5b50a2ba2af3b262bc43-ac1ec.png 1852w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;h2&gt;v4 의 라우팅 코드&lt;/h2&gt;
&lt;p&gt;비교를 위해서 v3 와 동일한 화면으로 만들어 보겠습니다.&lt;/p&gt;
&lt;h4&gt;index.js&lt;/h4&gt;
&lt;p&gt;Router(BrowserRouter) 컴포넌트에 히스토리가 내장되어 있는걸로 보입니다.
v3 에서는 history 객체를 별도로 가져와 Router 의 프로퍼티로 넣어줘야 했습니다만, v4 에서는 어떤 설정도 해줄 필요가 없습니다.
또한, 라우터 컴포넌트 아래로 DOM 코드를 직접 넣어줄 수 있게 되었습니다.
이게 의미하는게 뭐냐면, 어떤 코드에서든 &lt;code class=&quot;language-text&quot;&gt;Route&lt;/code&gt; 컴포넌트를 넣을 수 있다는 뜻입니다.
즉, 라우트는 필요할때마다 동적으로 생성 가능하다는 것이죠.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import React from &amp;#39;react&amp;#39;;
import ReactDOM from &amp;#39;react-dom&amp;#39;;
import { BrowserRouter as Router, Route } from &amp;#39;react-router-dom&amp;#39;;
import { Home, First, Second, Third } from &amp;#39;./App.js&amp;#39;;
import Header from &amp;#39;./Header.js&amp;#39;;

ReactDOM.render(
  &amp;lt;Router&amp;gt;
    &amp;lt;div&amp;gt;
      &amp;lt;Header /&amp;gt;
      &amp;lt;Route exact path=&amp;quot;/&amp;quot; component={Home} /&amp;gt;
      &amp;lt;Route path=&amp;quot;/first&amp;quot; component={First} /&amp;gt;
      &amp;lt;Route path=&amp;quot;/first&amp;quot; component={First} /&amp;gt;
      &amp;lt;Route path=&amp;quot;/second&amp;quot; component={Second} /&amp;gt;
      &amp;lt;Route path=&amp;quot;/third&amp;quot; component={Third} /&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/Router&amp;gt;,
  document.getElementById(&amp;#39;root&amp;#39;),
);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Header.js&lt;/h4&gt;
&lt;p&gt;v3 와 거의 같습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import React, { Component } from &amp;#39;react&amp;#39;;
import { Link } from &amp;#39;react-router-dom&amp;#39;;

class Header extends Component {
  render() {
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;ul&amp;gt;
          &amp;lt;li&amp;gt;&amp;lt;Link to={&amp;#39;/&amp;#39;}&amp;gt;홈&amp;lt;/Link&amp;gt;&amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;&amp;lt;Link to={&amp;#39;/first&amp;#39;}&amp;gt;첫번째&amp;lt;/Link&amp;gt;&amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;&amp;lt;Link to={&amp;#39;/second&amp;#39;}&amp;gt;두번째&amp;lt;/Link&amp;gt;&amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;&amp;lt;Link to={&amp;#39;/third&amp;#39;}&amp;gt;세번째&amp;lt;/Link&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}

export default Header;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;App.js&lt;/h4&gt;
&lt;p&gt;App 컴포넌트를 아예 만들지 않습니다. v3 에서 App 컴포넌트의 역할은 공통으로 사용하는 컴포넌트를 붙여주기 위함이었는데요.
v4 에서는 라우트 컴포넌트 내에 직접 다른 컴포넌트를 붙여주면 되기 때문에 App 컴포넌트는 더이상 필요하지 않습니다.&lt;/p&gt;
&lt;p&gt;그리고 &lt;code class=&quot;language-text&quot;&gt;Third&lt;/code&gt; 컴포넌트는 위에서 동적라우팅 설명할때 잠깐 언급했던 것처럼
컴포넌트 내에서 라우트 정보를 직접 넣어줄 수 있기 때문에 훨씬 명확한 코드를 작성할 수 있는것 같습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import React, { Component } from &amp;#39;react&amp;#39;;
import Header from &amp;#39;./Header.js&amp;#39;;
import { Route, Link } from &amp;#39;react-router-dom&amp;#39;;

export class Home extends Component {
  render() {
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;h1&amp;gt;홈 페이지&amp;lt;/h1&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}

export class First extends Component {
  render() {
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;h2&amp;gt;1, 첫번째 페이지&amp;lt;/h2&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}

export class Second extends Component {
  render() {
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;h3&amp;gt;2, 두번째 페이지&amp;lt;/h3&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}

export class Third extends Component {
  render() {
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;Link to={`${this.props.match.url}/1`} style={{ marginRight: &amp;#39;5px&amp;#39; }}&amp;gt;
          1번
        &amp;lt;/Link&amp;gt;
        &amp;lt;Link to={`${this.props.match.url}/2`}&amp;gt;
          2번
        &amp;lt;/Link&amp;gt;
        &amp;lt;Route
          exact
          path={this.props.match.url}
          render={() =&amp;gt; &amp;lt;div&amp;gt;&amp;lt;h3&amp;gt;id를 선택해 주세요.&amp;lt;/h3&amp;gt;&amp;lt;/div&amp;gt;}
        /&amp;gt;
        &amp;lt;Route path={`${this.props.match.url}/:id`} component={Item} /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}

class Item extends Component {
  render() {
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;h3&amp;gt;{this.props.match.params.id}&amp;lt;/h3&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;결과 화면입니다. 똑같습니다.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/result-fb1092558d8f5b50a2ba2af3b262bc43-ac1ec.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 67.60259179265658%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsSAAALEgHS3X78AAABkUlEQVQ4y62S307CMBTG0XfxHbzwGdyF8VWU6B0kkGjiE5mYsCWEP0YYCNkfDKyjHdsAJSLJ1rNjW3ZhojcgX/LldP263zlpWujVjdN66+nisaafdzsdzbZtzXEcbTAYaK1WSzNNUzNfB5rZ62ky7/e7Yt0VtS++TZmftzvdi1qtdlKQcl+e9XhJsG876HkefqxW+Lle42azwcVijsT3kREPp1OKs1mIHmFIfYa+3J9RpJTiklFsNJvVLdC19a/1FzLGUkIICCgEQQBRFEEURiCAQC0LPNsBnzIYj33wJj5YYi+KQ4jjOF0EDNvt53sFDMOZ/h6ucbX85BlmWZqmGedc1SRJ1FoGHCDjeSYtBRwyAEhRyLLsLXCxnBvB6APndMVlgBnuInla/TcajbbAN2tiIKhQtsUdLaWArutugYT4Rt5NAXca7y+guFQjD3leDwc8+ITZfvoF1POGiTDs4SQH3imgeMANPICGw+GDApZKpctKpXJbLpevhK/38FW1Wr0pFotnhR86/qePJEQMWvgGW9KB3SlysaIAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;result&quot;
        title=&quot;&quot;
        src=&quot;/static/result-fb1092558d8f5b50a2ba2af3b262bc43-fb8a0.png&quot;
        srcset=&quot;/static/result-fb1092558d8f5b50a2ba2af3b262bc43-1a291.png 148w,
/static/result-fb1092558d8f5b50a2ba2af3b262bc43-2bc4a.png 295w,
/static/result-fb1092558d8f5b50a2ba2af3b262bc43-fb8a0.png 590w,
/static/result-fb1092558d8f5b50a2ba2af3b262bc43-526de.png 885w,
/static/result-fb1092558d8f5b50a2ba2af3b262bc43-fa2eb.png 1180w,
/static/result-fb1092558d8f5b50a2ba2af3b262bc43-08f6a.png 1770w,
/static/result-fb1092558d8f5b50a2ba2af3b262bc43-ac1ec.png 1852w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;h3&gt;결론&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;아직 깊이 살펴보지 못해서 어떤 장점이 더 있는지는 모르겠습니다만,
어떻게 보면 v4 가 v3 에 비해서 산만해 보일수도 있습니다.
한곳에서 모든 라우팅 정보를 볼 수 있는게 좋다고 생각할 수도 있으니까요.
하지만, 리액트의 철학과 어울리는 라우팅 방식은 v4 의 동적 라우팅이 아닐까 생각이 듭니다.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[[ReactJs] create-react-app으로 react 시작하기]]></title><description><![CDATA[리액트를 본격적으로 사용하기 시작하면서 각종 라이브러리의 테스트 및 실험을 해볼 필요가 생겼습니다. 몇 가지 boilerplate 프로젝트를 찾아보다가 동료로부터  create-react-app…]]></description><link>https://blueshw.github.io/2017/06/20/create-react-app/</link><guid isPermaLink="false">https://blueshw.github.io/2017/06/20/create-react-app/</guid><pubDate>Tue, 20 Jun 2017 18:40:02 GMT</pubDate><content:encoded>&lt;p&gt;리액트를 본격적으로 사용하기 시작하면서 각종 라이브러리의 테스트 및 실험을 해볼 필요가 생겼습니다. 몇 가지 boilerplate 프로젝트를 찾아보다가 동료로부터 &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;create-react-app&lt;/a&gt;이라는 프로젝트에 대해 듣게 되었습니다(이제서야 알게되다니..).&lt;/p&gt;
&lt;p&gt;대부분의 비공식적인 boilerplate 프로젝트들은 package.json 과 같은 모듈 관리 파일에 필요한 모듈을 모두 정의해두고 설치해서 사용합니다. 그러다보니 특정 시점에 boilerplate 프로젝트를 다운받아 사용하다보면 어느새 오래된 프로젝트가 되어버리는 경우가 허다하죠. 워낙에 빠르게 변하는 js 환경이다 보니 일일이 변경되거나 업데이트된 부분을 바꿔주는것도 한계가 있습니다. create-react-app 을 이용하면 이 문제는 한번에 해결됩니다. (물론 추가로 설치한 모듈들에 대한 관리는 해줘야 합니다)&lt;/p&gt;
&lt;p&gt;설치는 아주 간단합니다.&lt;/p&gt;
&lt;p&gt;우선 프로젝트를 받아서(git clone 을 하던 zip 으로 받던 상관없어요) create-react-app 모듈을 글로벌로 설치해줍니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;npm install -g create-react-app&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;node 버전은 v8.1.2 를 사용하였습니다 (npm 은 v5.0.3)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;그리고는 앱을 생성합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;create-react-app react-test
cd react-test&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;만들어진 react-test 앱에 들어가보면 아래와 같은 구조로 프로젝트가 만들어져 있습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;react-test/
  README.md
  node_modules/     # 이미 modules가 설치되어 있습니다.
  package.json      # 의존성 패키지는 대부분 node_modules/react-scripts 모듈내에 선언되어 있습니다.
  .gitignore
  public/
    favicon.ico
    index.html
    manifest.json
  src/
    App.css
    App.js
    App.test.js
    index.css
    index.js        # 앱이 시작되는 부분입니다.
    logo.svg
    registerServiceWorker.js    # prodution 레벨에서 로컬캐시로부터 리소스를 제공하기 위한 서비스 워커 관련 설정,&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;앱을 실행해봅니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;npm start&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;제대로 동작하는걸 확인합니다. 끝입니다.&lt;/p&gt;
&lt;p&gt;만들어진 앱에 기본적으로 포함하고 있는 모듈은 아래와 같습니다.
이외에 필요한 모듈은 직접 설치하셔서 사용하면 되겠습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Webpack : minify, uglify 등을 포함한 모듈 번들링 도구&lt;/li&gt;
&lt;li&gt;Babel : ES6, React 등의 문법을 ES5 코드로 변환시켜주는 트랜스파일러&lt;/li&gt;
&lt;li&gt;Autoprefixer : 다양한 벤더(브라우저)들에게 적절한 CSS 가 적용될 수 있도록 prefix 를 붙여준다.&lt;/li&gt;
&lt;li&gt;ESLint : 자바스크립트 lint, 코드 컨벤션과 오류 등을 잡아준다.&lt;/li&gt;
&lt;li&gt;Jest : 자바스크립트 테스트 도구&lt;/li&gt;
&lt;li&gt;이외에 여러개&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;아무런 설정없이 react 부터 하나하나씩 설처해보는 것도 큰 도움이 되겠지만, 초기에 webpack 같은 번들링 도구에 대한 이해와 삽질하는데 상당한 시간이 소요됩니다(정말 그렇습니다). 정말 react 에만 집중하고 싶다면 이런 프로젝트를 이용해서 개발하는게 react 입문자들에게는 훨씬 도움되는 일이라 생각합니다.&lt;/p&gt;
&lt;h2&gt;참고자료&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;create-react-app github&lt;/a&gt; &gt; &lt;a href=&quot;https://github.com/facebookincubator/create-react-app/tree/master/packages/react-scripts/template&quot;&gt;craete-react-app 가이드 문서&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[[javascript] require vs import (CommonJs와 ES6)]]></title><description><![CDATA[CommonJs, AMD, ES6 Module require 와 import 에 대해서 비교해 보기 위해서는 우선  CommonJs 와  AMD(Asynchronous Module Definition) , ES…]]></description><link>https://blueshw.github.io/2017/05/16/ES-require-vs-import/</link><guid isPermaLink="false">https://blueshw.github.io/2017/05/16/ES-require-vs-import/</guid><pubDate>Tue, 16 May 2017 23:59:31 GMT</pubDate><content:encoded>&lt;h2&gt;CommonJs, AMD, ES6 Module&lt;/h2&gt;
&lt;p&gt;require 와 import 에 대해서 비교해 보기 위해서는 우선 &lt;a href=&quot;http://www.commonjs.org/&quot;&gt;CommonJs&lt;/a&gt;와 &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD&quot;&gt;AMD(Asynchronous Module Definition)&lt;/a&gt;, ES6 내장모듈과 같은 자바스크립트의 모듈 시스템에 대해 알고 있어야 합니다. 모듈에 대한 본격적인 포스팅이 아니기 때문에 깊게 다루진 않겠습니다(사실 자세히 모르게도 합니다ㅠ).&lt;/p&gt;
&lt;p&gt;기존의 자바스크립트(ES5, 현재 대부분의 브라우저에서 지원하는 자바스크립트 문법)는 모듈이라는 개념이 부족하여 각 모듈(또는 파일)간의 의존성 처리에 제한이 있었습니다. 고전적인 웹 프로젝트에서 자바스크립트를 사용하는 방법을 살펴보면, HTML 파일내부에 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그를 삽입하여 모듈을 로드하고 있습니다. 하지만 이런 방식은 한가지 문제가 있는데, 자바스크립트 파일(또는 모듈)끼리 서로 모듈을 공유하는데 제약이 없다는점입니다. 그 이유는 script 태그로 로드된 모듈은 모두 window 객체의 속성이기 때문에 서로 다른 파일에 위치하면서도 모든 객체를 공유할 수 있기 때문입니다. 이처럼 각 자바스크립트 파일이 독립적으로 존재하지 못해 발생하는 여러 문제들(예를들어 다른 파일에서 같은 이름의 변수를 사용하는 경우) 때문에 하나의 모듈로 관리하기위한 다양한 패턴(모듈패턴, 즉시실행함수 등)을 사용하여 의존성을 관리할 수 밖에 없었습니다.&lt;/p&gt;
&lt;p&gt;이를 해결하기 위한 수단으로 모듈이라는 개념을 도입하여 정의한 방법(또는 표준)이 CommonJs 와 AMD 입니다. 이 둘은 내부적으로 모듈 서로 간의 의존성(로드)이 지원되지 않는 상태로 만들어졌는데, ES6 에 이르러 언어 내부적으로 자바스크립트 모듈 의존성을 지원하게 되었습니다(import, export).&lt;/p&gt;
&lt;h3&gt;모듈정의 방식의 혼용&lt;/h3&gt;
&lt;p&gt;ES6 모듈은 기본적으로 CommonJs 와 AMD 모듈을 혼용해서 사용할 수 있습니다. 모듈을 가져오는 부분에 require 와 import 를 같이 쓰더라도 문제없이 동작하죠. import 는 ES6 문법이라 현재 사용되는 브라우저에서는 지원하지 않지만 babel 과 같은 트랜스파일러가 해결해줄수 있습니다. AMD 는 생략하고 ES6 와 CommonJs 를 비교하여 설명해보겠습니다.&lt;/p&gt;
&lt;p&gt;모듈을 정의한다는 것은 다른 모듈에서 사용할 수 있도록 하나의 모듈로써 노출하겠다는 의미다.&lt;/p&gt;
&lt;h4&gt;모듈 정의하기 (export)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;ES6&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// 모듈 전체를 export, 파일내 한번만 사용가능하다.
var module = {};
export default module


// 모든 속성을 export
export *;


// 함수를 직접 export
export function moduleFunc() {};
var property = &amp;quot;some property&amp;quot;;
export {property};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;CommonJs&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// 모듈 전체를 export
module.exports = module;


// 모든 속성을 export
// (아시는 분 알려주세요)


// 함수를 직접 export
exports.moduleFunc = function() {};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;모듈 가져오기 (import)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;ES6&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// 모듈 전체를 import
import module
import module as myModule


// 모든 속성 import
import * from module


// 특정 멤버(함수 등)만 import
import {moduleFunc, moduleFunc2} from module&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;CommonJs&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// 모듈 전체를 import
var module = require(&amp;#39;./someModule.js&amp;#39;);

// 모든 속성 import
// (위의 module 객체에 모든 속성이 담아져 온다.)

// 특정 멤버(함수 등)만 import, 위의 module을 이용한다.
module.moduleFunc&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;결론&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;바벨과 같은 트랜스파일링 모듈을 사용한다면 주저없이 ES6 를 사용합니다.
혼용하는것도 가능하지만 가급적이면 통일되게 사용하는 것이 좋다고 생각합니다.
실제로 제가 프로젝트 진행하면서 mocha 테스트 중 ES6 의 import/export 와 CommonJs 의 &lt;code class=&quot;language-text&quot;&gt;module.exports&lt;/code&gt; 를 혼용하여 사용시 문제가 발생했었습니다(자세히 언급하지 않음).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;참고&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://d2.naver.com/helloworld/12864&quot;&gt;JavaScript 표준을 위한 움직임: CommonJS 와 AMD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.exratione.com/2015/12/es6-use-of-import-property-from-module-is-not-a-great-plan/&quot;&gt;ES6: Use of “import { property } from ‘module’” is Not a Great Plan&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[[javascript] 클로저(closure)에 대해서 알아보자]]></title><description><![CDATA[자바스크립트 문법 중에 가장 어려운 부분을 꼽으라면 단연 클로저(closure…]]></description><link>https://blueshw.github.io/2017/04/12/javascript-closure/</link><guid isPermaLink="false">https://blueshw.github.io/2017/04/12/javascript-closure/</guid><pubDate>Wed, 12 Apr 2017 00:20:04 GMT</pubDate><content:encoded>&lt;p&gt;자바스크립트 문법 중에 가장 어려운 부분을 꼽으라면 단연 클로저(closure)일것입니다. 저 또한 클로저 개념은 어느정도는 이해하고 있었지만, 정확한 용도와 개념을 설명하라고 하면 명쾌하게 말하기 쉽지 않습니다. 아마도 많은 사람들이 저 처럼 대충 클로저가 무언인지는 말할 수 있지만, 정확한 의미와 용도에 대해서는 쉽고 명확히 대답하기는 힘들것입니다. 제가 클로저 개념이 헷갈렸던 이유는 의외로 황당한 이유 때문이었습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;del&gt;closer (가까운, 닫힌)&lt;/del&gt; ==&gt; &lt;strong&gt;closure (폐쇄)&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;멍청하게도 처음에는 클로저를 “closer”라고 생각했습니다. 정확한 개념은 당연히 몰랐고 단어의 의미로 단순하게 유추해서 “어떤 것을 닫는다” 정도로 느끼고 있었죠. 당시의 “닫는다”는 의미를 지금에 와서 생각해보면 “변수의 범주(스코프)를 닫는다” 정도로 이해하고 있었던거 같습니다. 하나도 모르고 있었다고해도 과언이 아니었죠.&lt;/p&gt;
&lt;p&gt;구글에서 검색하면 알 수 있는 클로저의 의미는 아래와 같이 조금 모호합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;외부함수의 맥락(context)에 접근 가능한 내부함수
좀 더 포괄적으로는 함수 선언시 생성되는 유효 범위&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이런 정의만 보고 과연 사람들이 이해를 할 수 있는건지는 잘 모르겠지만, 클로저에 대한 이해가 거의 없는 분들은 아마도 이해하기 어렵울 것입니다. 그러면, 일단 코드를 보도록 하죠.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function outFunc(name) {
	var outVar = &amp;quot;my name is &amp;quot;;
	function innerFunc() {
		return outVar + name;
	}
	return innerFunc;
}

var result = outFunc(&amp;quot;bono&amp;quot;);
console.log(&amp;quot;result: &amp;quot; + result());

// result: my name is bono&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;내부함수 &lt;code class=&quot;language-text&quot;&gt;innerFunc()&lt;/code&gt;에서 &lt;code class=&quot;language-text&quot;&gt;outFunc()&lt;/code&gt; 함수의 인자와 지역변수에 접근이 가능합니다. &lt;code class=&quot;language-text&quot;&gt;outFunc()&lt;/code&gt;의 return 값(var result 에 할당)은 &lt;code class=&quot;language-text&quot;&gt;innerFunc()&lt;/code&gt;라는 내부 함수입니다. outFunce() 함수가 실행되면, outFunc()의 스코프는 끝이 나기 때문에 outFunc() 인자인 name 과 지역변수인 outVar 는 메모리에서 정리되어야합니다. 하지만, 실제 console.log 에서 result 를 호출하면(내부 함수가 호출), 내부함수 innerFunc()가 선언될때 outFunc() 함수의 인자와 outVar() 지역변수를 innerFunc()의 클로저 객체로 남아 실제로 innerFunc()가 호출될 때 클로저 객체를 통해서 outFunc()의 인자와 변수에 접근이 가능한 것입니다. 이게 바로 클로저가 하는 일입니다.&lt;/p&gt;
&lt;p&gt;다른 예제를 살펴보겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var out = &amp;quot;out value&amp;quot;;

function outFunc() {
	var inner = &amp;quot;in value&amp;quot;;

	function inFunc(inParam) {
		console.log(&amp;quot;out: &amp;quot; + out);
		console.log(&amp;quot;inner: &amp;quot; + inner);
		console.log(&amp;quot;inParam: &amp;quot; + inParam);
	}

	return inFunc;
}

var param = &amp;quot;this is param&amp;quot;;
var outResult = outFunc();
outResult(param);

// out: out value
// inner: in value
// inParam: this is param&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 예제에는 크게 세가지 스코프가 존재합니다. 첫번째는 &lt;code class=&quot;language-text&quot;&gt;전역스코프&lt;/code&gt;, 그다음은 &lt;code class=&quot;language-text&quot;&gt;outFunc()&lt;/code&gt; 함수 내 스코프, 마지막으로 &lt;code class=&quot;language-text&quot;&gt;inFunc()&lt;/code&gt; 내 스코프입니다. 가장 위에 out 이라는 변수가 선언되어 있고, outFunc() 함수 및 param 과 outFunc() 의 return 값인 outResult 까지 총 4 개의 변수(or 함수)가 선언되어 있고 마지막에 outResult 함수를 호출하고 있습니다.&lt;/p&gt;
&lt;p&gt;outResult 는 outFunc() 함수의 결과값이므로, inFunc() 함수 자체를 참조하고 있습니다. 그 말은 마지막에 호출한 outResult 함수에 인자를 전달하면 실제 내부 함수인 inFunc()의 파라미터에 해당 값이 들어온다는 의미겠죠.&lt;/p&gt;
&lt;p&gt;클로저의 관점에서 생각해보겠습니다. outFunc() 함수가 선언되었지만, 실제로 호출되기전까진 언제 사용될지 모릅니다. 그래서 해당 함수(outFunc())의 클로저로써 유효범위(전역범위)의 변수들이 클로저 객체로 메모리상에 남아 있게 됩니다. 즉, outFunc() 함수가 실행될 때 해당 함수 내부에서 outFunc() 바깥의 전역영역의 변수에 접근할 수 있는거죠. 그리고 outFunc() 내부에 inFunc()가 선언되는 순간 outFunc() 내의 변수(여기서는 inner 변수)가 inFunc() 함수의 클로저 객체 안에 존재하게 되는것이죠. 그러고나면 각각의 outFunc(), inFunc() 함수가 실제로 호출되어 실행되는 순간에 미리 &lt;code class=&quot;language-text&quot;&gt;메모리에 저장되어 있던 클로저&lt;/code&gt;에서 각각의 변수를 가져올수 있게 되는겁니다.&lt;/p&gt;
&lt;p&gt;클로저의 정의에 대해서 알아보았으니 클로저로 활용할 수 있는게 뭐가 있는지는 다음에 알아보도록 하겠습니다.&lt;/p&gt;
&lt;h3&gt;결론&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;클로저는 단순히 함수 외부의 변수에 접근 가능한 내부함수가 아니라 함수가 선언되는 순간에 함수가 실행될때 실제 외부변수에 접근하기 위한 객체이다.
클로저도 남발하면 위험하다. 가비지컬렉션 대상이 되어야할 객체들이 메모리상에 남아 있게 되므로, 클로저를 남발하면 오버플로우가 발생할수도 있다. 이는 클로저에 대해 정확히 알아야 하는 이유이기도 하다.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[[ES6] var VS const VS let]]></title><description><![CDATA[ES6(ECMA Script 2015, 줄여서 ES6)로 넘어오면서 기존 ES5 까지 사용하던 변수 선언 키워드인  var 에다  const 와  let 이라는 키워드가 추가되었습니다. 물론 var…]]></description><link>https://blueshw.github.io/2017/03/28/ES-var-VS-const-VS-let/</link><guid isPermaLink="false">https://blueshw.github.io/2017/03/28/ES-var-VS-const-VS-let/</guid><pubDate>Tue, 28 Mar 2017 23:52:49 GMT</pubDate><content:encoded>&lt;p&gt;ES6(ECMA Script 2015, 줄여서 ES6)로 넘어오면서 기존 ES5 까지 사용하던 변수 선언 키워드인 &lt;em&gt;var&lt;/em&gt;에다 &lt;em&gt;const&lt;/em&gt;와 &lt;em&gt;let&lt;/em&gt;이라는 키워드가 추가되었습니다. 물론 var 없이도 변수를 선언할 수 있습니다만, 그렇게 되면 전역객체(브라우저 환경에서는 window 객체)의 속성이 되기 때문에 동일한 이름의 변수를 사용하다가는 치명적인 문제가 발생할 수도 있습니다.&lt;/p&gt;
&lt;p&gt;기존 자바스크립트의 변수는 기본적으로 Function Scope 입니다(var 로 선언한 변수). 변수의 유효범위가 함수단위라는 이야기입니다. java 나 C 등의 많이 사용되는 프로그래밍 언어를 공부해 보았다면 알겠지만, 대체로 이 언어들은 Function Scope 가 아닌 Block Scope 를 가집니다.(python 은 예외) 그래서 java 나 C 계열의 언어를 사용하다가 자바스크립트 코드를 짜다보면 간혹 스코프 문제로 헷갈릴때가 있기 마련이죠. 그래서 ES6 부터는 const 와 let 이 등장했습니다. 예상한대로 const 와 let 은 Block Scope 를 가집니다. 기존에 많이 사용되는 언어들과 같습니다. const 는 단어의 의미처럼 상수를 의미하고 let(무슨 단어를 줄인건지 감이 잡히지 않네요)은 기존의 var 처럼 변수를 의미합니다.&lt;/p&gt;
&lt;p&gt;이 밖에도 이 세가지 키워드에는 몇가지 차이점이 존재합니다. 예제를 통해 이 세가지 변수선언 키워드에 대해서 알아보겠습니다.&lt;/p&gt;
&lt;h3&gt;재할당 및 재선언하기&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// var의 경우
var a = 1;
a = 2;
console.log(a); // 2
var a = 3;
console.log(a); // 3

// let의 경우
let b = 1;
b = 2;
console.log(b)	// 2
let b = 3; 		// SyntaxError: Identifier &amp;#39;b&amp;#39; has already been declared

// const의 경우
const c = 1;
c = 2; 			// TypeError: Assignment to constant variable&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;var 의 경우 굉장히 유연합니다. &lt;em&gt;var a = 1;&lt;/em&gt;로 선언한 뒤, 2 를 재할당하고 다시 &lt;em&gt;var = 3;&lt;/em&gt;으로 재선언(?) 해도 문제될게 없습니다.
그런데 let 의 경우 재할당은 문제 없습니다만, &lt;em&gt;let b = 3;&lt;/em&gt;으로 재선언하고 나면 이미 선언된 변수라는 에러를 뱉어냅니다.
마지막으로 const 는 상수이기 때문에 재할당, 재선언 모두 불가합니다.&lt;/p&gt;
&lt;h3&gt;스코프 (Scope)&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var a = 1;
let b = 2;

if(true) {
	var a = 11;
	let b = 22;
	console.log(&amp;quot;a = &amp;quot; + a);		// 11
	console.log(&amp;quot;b = &amp;quot; + b);		// 22
}

console.log(&amp;quot;a = &amp;quot; + a);			// 11
console.log(&amp;quot;b = &amp;quot; + b);			// 2

function func() {
	var a = 111;
	let b = 222;
	console.log(&amp;quot;a = &amp;quot; + a);		// 111
	console.log(&amp;quot;b = &amp;quot; + b);		// 222
}

func();

console.log(&amp;quot;a = &amp;quot; + a);			// 11
console.log(&amp;quot;b = &amp;quot; + b);			// 2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;전역 영역에서 var a, let b 를 선언하고 각각 1, 2 를 할당했습니다. 우선 if 블럭 내에서 각각의 변수 값을 변형시켰더니 블럭 내에서는 변경된 값이 모두 출력되었습니다. 그런데, if 블럭 바깥으로 나갔더니 let 으로 선언했던 b 값은 가장 상단에 선언한 값과 동일한 2 인데, a 는 11 로 변경되었습니다. 그 이유는 var 의 경우 변수의 유효범위가 함수이므로 블럭으로 감쌌다고 하더라도 함수 스코프가 바뀐것이 아니기 때문에 if 블럭 내에서 재할당한 값을 출력하는 것입니다.&lt;/p&gt;
&lt;p&gt;함수내에서 a, b 각 변수를 선언했을때는 어떨까요? var 든, const 든 새로운 함수로 감싸게 되면 그 안에서 선언한 변수는 함수(func)내의 지역변수가 되므로 바깥에서 선언한 변수의 이름과 겹치더라도 함수(func) 내에서는 새로 할당한 값들이 출력됩니다. 마지막으로 함수가 호출되고 나서 각 변수를 출력해보면, 함수 내에서 할당한 값은 그 함수 호출이 끝남과 동시에 유효범위도 사라지므로 함수 선언 이전의 a, b 값이 출력됩니다.&lt;/p&gt;
&lt;h3&gt;let vs const&lt;/h3&gt;
&lt;p&gt;위에서 let 은 변수, const 는 상수라고 구분지어 설명했지만, 좀더 구체적으로 설명할 필요가 있어보입니다. let 은 변수고 const 는 상수가 맞긴 하지만, 할당된 값이 원시타입이냐 참조타입(array, object, function)이냐에 따라서 조금 다르게 사용됩니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;let a = 1;
const b = 2;

a = 11;
b = 22;				// TypeError: Assignment to constant variable.

let obj_a = {
	name: &amp;#39;obj_a&amp;#39;
};

const obj_b = {
	name: &amp;#39;obj_b&amp;#39;
}

obj_a[&amp;#39;name&amp;#39;] = &amp;#39;a&amp;#39;;
obj_b[&amp;#39;name&amp;#39;] = &amp;#39;b&amp;#39;;

obj_a[&amp;#39;number&amp;#39;] = 1;
obj_b[&amp;#39;number&amp;#39;] = 2;

obj_a = {}
obj_b = {}			// TypeError: Assignment to constant variable.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;기본적으로 let 은 재할당이 가능한반면, const 는 재할당이 불가합니다. 재할당하게 되면 TypeError 가 발생하죠. 그런데 차이점이 있다면, 처음 할당된 객체를 변형시킬때는 아무 문제없이 동작한다는 것을 알 수 있습니다. 처음에는 두 객체 모두 ‘name’ 이라는 속성만 가지고 있었는데, 이를 변형하거나 새로운 속성(number)를 추가하더라도 let, const 둘다 에러를 발생시키지 않습니다. 이는 array 와 function 의 경우도 마찬가지인데, 이유는 const 에 실제로 할당된 값은 원시타입처럼 특정 값이 아니라 객체의 주소값이기 때문입니다. 실제 객체가 변한다고해서 한번 할당된 객체의 주소값이 바뀌는건 아니죠.&lt;/p&gt;
&lt;h3&gt;결론&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;ES6 에서 var, const, let 모두 사용 가능하지만, 상황에 맞게 적절한 키워드를 사용해야 하겠습니다. (되도록 const, let 을 사용하는게 좋겠죠)&lt;/li&gt;
&lt;li&gt;객체를 새로 할당할 특별한 이유(이런 경우는 드물다 생각합니다)가 없다면 되도록 const 를 사용하여 객체를 선언하는게 좋을것 같습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[Sublime Text 3 패키지 공유하기]]></title><description><![CDATA[SublimeText…]]></description><link>https://blueshw.github.io/2017/03/23/migration-packages-sublime-text-3/</link><guid isPermaLink="false">https://blueshw.github.io/2017/03/23/migration-packages-sublime-text-3/</guid><pubDate>Thu, 23 Mar 2017 00:37:32 GMT</pubDate><content:encoded>&lt;h3&gt;SublimeText 3 환경 설정 공유하기&lt;/h3&gt;
&lt;p&gt;서브라임 텍스트 사용 중에 가장 아쉬운 점은 바로 환경설정 부분입니다. 아톰 등의 몇몇 텍스트에디터들은 계정과 연동되어 어느 기기에서 설치하더라도 동일한 환경으로 작업할 수 있는 장점이 있는데, 서브라임은 이 기능을 지원하지 않아 매번 &lt;em&gt;&lt;a href=&quot;https://packagecontrol.io/installation&quot;&gt;package Control&lt;/a&gt;&lt;/em&gt;부터 사용하는 패키지를 새로 설치해야 되는 문제가 있죠. 패키지를 몇가지 사용하지 않는다면 이게 뭐가 문제냐라고 생각할지 모르지만, 수많은 패키지를 설치한 사용자에게는 모든 패키지 리스트를 받아서 새로 설치하는건 크나큰 고역이 아닐 수 없습니다.&lt;/p&gt;
&lt;p&gt;방법은 의외로 간단합니다. 사용자가 개발한 여러 싱크 플러그인 중 하나를 사용해도 무방하지만 저는 package control 사이트에서 기본적으로 제안하는 방법을 사용하도록 하겠습니다.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;https://packagecontrol.io/docs/syncing&quot;&gt;Syncing&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;위 페이지를 보면 크게 2 가지 방법이 있는 것을 알 수 있습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Using Git (Git 을 이용하는 방법)&lt;/li&gt;
&lt;li&gt;Using Dropbox (Dropbox 를 이용하는 방법)&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;Git 을 이용하게 되면 별도의 Git 서버를 구축하지 않는 이상 대부분 Github 같은 서비스를 이용하게 될텐데 이때 문제가 하나 있습니다. Github 은 private 저장소가 아닌 이상 오픈되어 있기 때문에 서브라임을 사용하면서 유료로 구매한 패키지 정보들이 고스란히 노출될 수 있습니다. 그래서 저는 Git 을 이용하지 않고 안전한 Dropbox 를 선택했습니다.&lt;/p&gt;
&lt;h3&gt;Using Dropbox (mac)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Step 1. 드롭박스를 이용하려면 우선 mac 용 드롭박스 앱을 설치합니다. (~/Dropbox 생성)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Step 2. 우선 저장할 패키지를 가진 기기에서 아래의 명령어를 차례로 입력합니다. Dropbox 에 Sublime 이라는 디렉토리를 생성하고, Packages 디렉토리 안에있는 User 정보를 dropbox 의 Sublime 디렉토리로 이동합니다. 그리고 dropbox 내 유저 정보를 simbolic link 로 연결합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;cd ~/Library/Application\ Support/Sublime\ Text\ 3/Packages/
mkdir ~/Dropbox/Sublime
mv User ~/Dropbox/Sublime/
ln -s ~/Dropbox/Sublime/User&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Step 3. 이제 다른 기기(새로 설치할 기기)에 가서 아래 명령어를 순차적으로 입력합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;cd ~/Library/Application\ Support/Sublime\ Text\ 3/Packages/
rm -r User
ln -s ~/Dropbox/Sublime/User&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이렇게 초기의 환경에서&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/sublime-before-cac0ac739ec96de3e33ed95d29be7269-c7177.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 69.27426955702168%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsSAAALEgHS3X78AAACHklEQVQ4y6WSX2/SUBTAa6LGRx/UsmzAitCObWxQoJRtL2KMfgGCEBIILlIXg4lfwnc/gsmamBgS3Jb5CLz4YhwFYmlDoAGU8ufJ+LR1PbttIMbMORea/HLu7Tn53dOei314+uaG+PkgWWsJO0pLyYoNkSuXy1yxWDTj4eEnrlAocPl8ntvfP+BKpZKZm2LsjZqPe3vPUc097PXLV3ePvn752VbaMBwOodvtwuMnDyHI+IANByEU8gPD0GhPA4PWbDgALPsnxnsj7/EsRzBu5wVerdZ+CBUB+v3+caMhaqseUrMvWjTH/XmNcMybcbr+CyfEJGeZuxPBcrkcLgiCWq/VodfrnSKh7vWt6C7Sri+5HTq1RPwXJEXoNttcBEun07gsSWq9Xkefawgb4PUtg9NlA1QIJLV4GfqkTrfaLBEsmUzizWZzIuyeShISen8LL+OcMJVK4bIsq9VqFZS2cq7DKwunHVaOKiBJsvEPZxNOO+x0OqAOBrMLY7EY3mq11NFoBAMkFMVvVxJOpjwRoinH43FcUZTvxqUej8fHqFttbd2N7t2CRlJ2DV2ff4IOPnGRNjMuWPEHWDQataAJ/0IyUFUVjA7ZsB88a5TZ6br3Itxmnvavgo9eMSEc1keY0+m8vf1s+202m32fyWR2E4kEz4SCfCBA84GgH8WLoPlQiOG3tjZ2w2GW39zceEdSLjeGnmuI64hbM3LTcJ0B+xjekE2HWAUAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;before&quot;
        title=&quot;&quot;
        src=&quot;/static/sublime-before-cac0ac739ec96de3e33ed95d29be7269-fb8a0.png&quot;
        srcset=&quot;/static/sublime-before-cac0ac739ec96de3e33ed95d29be7269-1a291.png 148w,
/static/sublime-before-cac0ac739ec96de3e33ed95d29be7269-2bc4a.png 295w,
/static/sublime-before-cac0ac739ec96de3e33ed95d29be7269-fb8a0.png 590w,
/static/sublime-before-cac0ac739ec96de3e33ed95d29be7269-526de.png 885w,
/static/sublime-before-cac0ac739ec96de3e33ed95d29be7269-c7177.png 1061w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;이렇게 변합니다.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/sublime-after-0bc4e2c7a1ff2099e80f4510acc810ec-c7177.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 69.27426955702168%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsSAAALEgHS3X78AAAB5klEQVQ4y62Sy27TUBCGjQQobBpIYpJSkri+JCk+dmKJxJfm6tgVaRcVEkvWrcVr8AY8AUJqECuKAilFZVHJdp4E5DVi1dg9zLGLIKu0FEufzu3XpxmNqbfPXt46/fD6+fT04wvf9fddz3Vc13M8z3Nms5lzcvLVmX6aOpPJxDk+/uL4vg9vfyBnkjk6+rx3+P7wPrWWK9C2Zf7YfbqLd7Z38Gg0Ap7grS0b27aNLWuIh0OCGe/JnW1bC1iWFb/rzaZJpe6k8iJC37vdLu52OmcIiWG1xoQcXwzX2TXgYchyCWSf3C0wZy/uVx/QJpW5l8lLkhQYhoE1TYskWTqv1tavTKXKnBdLqyaVTqdj4WAwwJqqRlAhrm2wGAIYgkupVGMhToSFRCjLckBabrfbkaIoJAThywqZRWE2m80jhIJWqxULG4367+A/CnM0CMVg09Bwv9+PZFm6njADFUqkwuZjrOt6VK/L/6NCFOiqCi13IhjQlYQXU/6rQiIUxW+62sQw6TNFaYQwFIC5LHOyCpXyHIQDUmGhLss/25sG7vV60LaGRVHAj0R+KSKqxCApWeE/tKmVlfRdQRBeSUh8B60fMAwzLpdLSymVimOOYwkHPM+NBZ57Q9O5DQq+G8BNIHVNbhPXL6nYeMdj6f53AAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;after&quot;
        title=&quot;&quot;
        src=&quot;/static/sublime-after-0bc4e2c7a1ff2099e80f4510acc810ec-fb8a0.png&quot;
        srcset=&quot;/static/sublime-after-0bc4e2c7a1ff2099e80f4510acc810ec-1a291.png 148w,
/static/sublime-after-0bc4e2c7a1ff2099e80f4510acc810ec-2bc4a.png 295w,
/static/sublime-after-0bc4e2c7a1ff2099e80f4510acc810ec-fb8a0.png 590w,
/static/sublime-after-0bc4e2c7a1ff2099e80f4510acc810ec-526de.png 885w,
/static/sublime-after-0bc4e2c7a1ff2099e80f4510acc810ec-c7177.png 1061w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;h3&gt;결론&lt;/h3&gt;
&lt;p&gt;이게 끝입니다. 간단하죠?
혹시 완료했는데 적용이 안된다면, Sublime Text 를 완전히 종료한 뒤 다시 실행시켜보세요.
서브라임은 최초에 실행될때 누락된 패키지가 있는지 체크하고 설치하는 과정을 거쳐
간단히 요약해보면, 아래와 같습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;패키지 정보가 들어있는 User 정보를 dropbox 로 이동하고 해당 폴더를 simbolic link 로 바라보게 만든다.
이렇게 되면 내 sublime 정보가 dropbox 에만 존재하므로, 어느 기기에서 사용하더라도 동일한 환경으로 설정이 가능하다.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[[ionic] ionic 개발에 필요한 것들]]></title><description><![CDATA[ionic 개발에 필요한 것들 기본적으로 ionic, nodejs, cordova 등만 있어도 개발은 가능하겠지만, 안드로이드 에뮬레이터 실행을 위해서는 jdk 설치가 필요하겠고, ios 에뮬레이터 실행을 위해서는 xcode…]]></description><link>https://blueshw.github.io/2016/11/16/ionic-install/</link><guid isPermaLink="false">https://blueshw.github.io/2016/11/16/ionic-install/</guid><pubDate>Wed, 16 Nov 2016 01:14:00 GMT</pubDate><content:encoded>&lt;h2&gt;ionic 개발에 필요한 것들&lt;/h2&gt;
&lt;p&gt;기본적으로 ionic, nodejs, cordova 등만 있어도 개발은 가능하겠지만, 안드로이드 에뮬레이터 실행을 위해서는 jdk 설치가 필요하겠고, ios 에뮬레이터 실행을 위해서는 xcode 설치도 필수가 되겠다(아래에선 생략한다). 그리고 ionic 과 관련해서 설치해두면 편리하게 사용할 수 있는 모듈들을 몇개 추려봤다.&lt;/p&gt;
&lt;p&gt;참고로 아직 ionic 파악이 덜 끝난 상태이므로 해당 리스트는 추가되거나 삭제될 수 있다.&lt;/p&gt;
&lt;h4&gt;JAVA&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&quot;&gt;http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;안드로이드가 자바기반으로 개발되기 때문에 반드시 필요하다.&lt;/li&gt;
&lt;li&gt;JAVA&lt;em&gt;HOME 경로를 ~/.bash&lt;/em&gt;profile(or ~/.profile)파일에 설정한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_25.jdk/Contents/Home
export PATH=$PATH:$JAVA_HOME/bin&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Android SDK&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Android 에뮬레이터 설치, 디버깅 등에 필요하다.&lt;/li&gt;
&lt;li&gt;Ionic 이 Android 앱을 빌드하거나 실행할 때는 Stand-Alone SDK Tools 가 필요하다.&lt;/li&gt;
&lt;li&gt;ANDROID_HOME 경로도 지정해준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;export ANDROID_HOME=/Projects/Libraries/adt-bundle-mac-x86_64/sdk
export PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Node.js&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;우선 설치부터, &lt;a href=&quot;https://nodejs.org/en/download/&quot;&gt;https://nodejs.org/en/download/&lt;/a&gt; 사이트에서 원하는 os, version 을 선택하여 설치한다.&lt;/li&gt;
&lt;li&gt;또는 맥 사용자라면, 아래 명령어로 설치한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;brew install node&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;NODE_HOME 도 경로설정 해준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;export NODE_HOME=p/Projects/Libraries/node/node-v0.12.7-darwin-x64
export NODE_PATH=$NODE_HOME/lib/node_modules
export PATH=$PATH:$NODE_HOME/bin:$NODE_PATH&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;cordova&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;npm install -g cordova (-g 옵션은 global, CLI(Command Line Interface) 명령어를 제공하는 경우는 글로벌로 설치)&lt;/li&gt;
&lt;li&gt;ionic 은 내부적으로 cordova 를 이용한다(디바이스 배포용도).&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;gulp&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;npm install -g gulp&lt;/li&gt;
&lt;li&gt;ionic 빌드 시스템&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;bower&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;npm install -g bower&lt;/li&gt;
&lt;li&gt;ionic 은 필요한 패키지를 bower 를 이용해서 다운 받는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;ios-sim&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;npm install -g ios-sim&lt;/li&gt;
&lt;li&gt;폰갭 프로젝트를 ios 시뮬레이터에서 실행하기 위한 패키지&lt;/li&gt;
&lt;li&gt;다음 명령어로 타겟을 지정해줄수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# 가능한 device 확인
ios-sim showdevices

# 타겟 지정 실행
ionic emualte ios --target=&amp;quot;iPhone-5s&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;ios-deploy&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;npm imstall -g ios-deploy&lt;/li&gt;
&lt;li&gt;PhoneGap 프로젝트를 Xcode 없이 iOS 디바이스로 앱을 설치하거나 디버깅하는 패키지&lt;/li&gt;
&lt;li&gt;ios-sim, ios-deploy 패키지를 설치했다면, ios 시뮬레이터를 띄우기 위해서 굳이 xcode 를 실행할 필요는 없다(물론 설치는 되어있어야 함).&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;ionic&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;npm install -g ionic&lt;/li&gt;
&lt;li&gt;드디어 ionic 설치, 이전것들은 ionic 프로젝트를 만들기전 꼭 필요한 패키지 들이니 꼭 설치하고 시작하도록 하자.&lt;/li&gt;
&lt;li&gt;몇가지 명령어를 살펴보자&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# sidemenu 형식의 프로젝트 생성
ionic start testApp sidemenu

# ionic 서버 실행
ionic serve

# ionic ios 앱 빌드
ionic build

# ios 에뮬레이터 실행
ionic emulate ios (--target=&amp;quot;iPhone-6s&amp;quot;)

# ios real 디바이스에서 실행
ionic run ios

# android 추가
ionic platform add android&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;참고자료 : &lt;a href=&quot;http://blog.saltfactory.net/ionic/start-ionic-edge-book.html&quot;&gt;http://blog.saltfactory.net/ionic/start-ionic-edge-book.html&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[[coursera] AngularJS week 4]]></title><description><![CDATA[Client-Server Communication and Angular Testing Networking Essentials 이번 챕터에서는 클라이언트 서버 구조에서 AngularJS…]]></description><link>https://blueshw.github.io/2016/10/02/frontend-javascript-framework-angularjs-week4/</link><guid isPermaLink="false">https://blueshw.github.io/2016/10/02/frontend-javascript-framework-angularjs-week4/</guid><pubDate>Sun, 02 Oct 2016 17:38:30 GMT</pubDate><content:encoded>&lt;h2&gt;Client-Server Communication and Angular Testing&lt;/h2&gt;
&lt;h3&gt;Networking Essentials&lt;/h3&gt;
&lt;p&gt;이번 챕터에서는 클라이언트 서버 구조에서 AngularJS 가 어떻게 동작하는지 살펴볼것이다.
요즘 가장 많이 사용되는 Client-Server 관계는 HTTP 프로토콜과 REST API 를 이용한 백엔드(서버)와 브라우저(클라이언트)간의 통신으로 이뤄진다. 이전 강의까지 보았던 방식은 브라우저에 출력되는 데이터가 services.js 파일의 자바스크립트 오브젝트로 존재했었다. 하지만, Client-Server 구조에서는 거의 모든 데이터를 서버사이드에서 클라이언트 사이드로 제공해준다. HTTP 와 REST API 에 대한 내용은 자세히 다루지는 않겠다(강의 보세요).&lt;/p&gt;
&lt;p&gt;HTTP Response 는 클라이언트로 보낼 HTML 페이지나 특정 포맷으로 data 를 가지는데, 주로 XML 또는 JSON 을 많이 사용한다. 이 중에서 JSON(Javascript Object Notation)은 가장 많이 사용되는 데이터 포맷이다. 이름만 보면 자바스크립트에서만 사용될것 같지만, 모바일이나 웹서비스 등 일반적인 HTTP 통신에서 대부분 사용된다. XML 이 잘 사용되지 않는 이유는 JSON 에 비해서 데이터를 parsing 하는 과정이 복잡하기 때문이다.&lt;/p&gt;
&lt;p&gt;JSON 데이터 구조를 간단히 살펴보자
자바스크립트 object 와 구조가 비슷하다. name : value 구조로 이뤄지며, value 내에는 array, 스트링, 숫자, object 등의 데이터 타입 등이 들어갈 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;{&amp;quot;promotion&amp;quot;:
	[
		{
			&amp;quot;id&amp;quot;: 0,
			&amp;quot;name&amp;quot;: &amp;quot;weekend buffet&amp;quot;,
			&amp;quot;image&amp;quot;: &amp;quot;images/buffet.png&amp;quot;,
			&amp;quot;label&amp;quot;: &amp;quot;New&amp;quot;,
			&amp;quot;price&amp;quot;: &amp;quot;19.99&amp;quot;,
			&amp;quot;description&amp;quot;: &amp;quot;asdjfkljaskdlfjas...&amp;quot;
		}
	]
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Client-Server Communication using $http&lt;/h3&gt;
&lt;h4&gt;Angular $http&lt;/h4&gt;
&lt;p&gt;$http 는 브라우저에서 서버와의 통신을 위한 가장 핵심적인 서비스로 HTTP protocol 을 사용한다. 아마 내부적으로는 AJAX 통신을 할것이기 때문에 비동기로 처리될 것이다.&lt;/p&gt;
&lt;h4&gt;Promise&lt;/h4&gt;
&lt;p&gt;자바스크립트에서 Promise 란 비동기 통신이 완료된 후에 상태에 따라 특정 콜백을 리턴해 줄 것이라는 일종의 약속 같은 것을 말한다. $http 서비스 역시 프로미스를 리턴한다. 패턴은 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$http({method: &amp;#39;GET&amp;#39;, url:&amp;#39;/dishes&amp;#39;})
	.then(function() { ... }, function() { ... });&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;then 뒤에는 두개의 function 이 파라미터로 들어가 있다. 첫번째는 request 가 성공했을 때 발생하는 함수이고, 두번째는 요청이 실패했을때 발생하는 함수이다. 보통 AJAX 통신을 사용할 때, ‘success’, ‘error’ 속성을 사용하는 것과 비슷하다.&lt;/p&gt;
&lt;h4&gt;HTTP Response&lt;/h4&gt;
&lt;p&gt;요청의 결과로 response 라는 object 가 서버로부터 넘어온다. 이때 reponse 객체에는 다음과 같은 속성들이 포함되어 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;response.data : 메세지 바디를 포함하느 string / object&lt;/li&gt;
&lt;li&gt;response.status : 상태 코드 (200, 400 등)&lt;/li&gt;
&lt;li&gt;response.headers : 헤더정보&lt;/li&gt;
&lt;li&gt;response.config : configuration object&lt;/li&gt;
&lt;li&gt;response.statusText : response 상태 텍스트 값&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;ng-if directive&lt;/h4&gt;
&lt;p&gt;html 코드를 작성할 때 해당 DOM 을 보여줄지 말지를 결정하기 위해 ngIf directive 를 사용할 수 있다. 사용법은 간단하다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;div class=&amp;quot;col-xs-12&amp;quot; ng-if=&amp;quot;!showMenu&amp;quot;&amp;gt;
	&amp;lt;h3&amp;gt;{{message}}&amp;lt;/h3&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;showMenu 가 true 면 ng-if 는 false 가 되므로 해당 message 는 안보일것이고, showMenu 가 false 면 반대로 message 가 나타날 것이다.&lt;/p&gt;
&lt;h3&gt;Brief Representational State Transfer (REST)&lt;/h3&gt;
&lt;p&gt;본격적으로 서버와의 통신을 해보기 전에 가장 많이 사용하는 방식인 REST 에 대해서 알아보자. 웹 서비스를 만들때 네트워크와 연결하는 방법에 대한 시스템은 보통 아래 두개 접근법이 가장 일반적이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SOAP (Simple Object Access Protocol) : Uses WSDL(Web Service Description Language), 프레젠테이션 영역에 XML 을 사용&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;REST (Representational State Transfer) : 가장 많이 사용됨, Use Web standards, Exchange of data using either XML or JSON, SOAP 나 WSDL 보다 훨씬 간단한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;REST 는 WWW(World Wide Web)과 같이 분산 hypermedia systems 을 위한 아키텍쳐 스타일 중 하나이며, 웹 페이지의 리소스에 어떻게 접근하고 어떻게 정의되고 어떻게 이동하는지에 대한 법칙을 모아놓은 시스템이다.&lt;/p&gt;
&lt;h4&gt;REST 의 기본 법칙&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;HTTP 메소드를 사용하며 (Use HTTP methods explicitly)&lt;/li&gt;
&lt;li&gt;상태를 저장하지 않는다 (Be stateless)&lt;/li&gt;
&lt;li&gt;리소스는 URI 와 같이 디렉토리 스트럭쳐가 그대로 노출된다 (Expose directory structure-like URIs)&lt;/li&gt;
&lt;li&gt;통신의 매개체로 XML, JSON 등이 사용된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;REST 는 세가지 컨셉으로 표현할 수 있다. 특정 URI 로 표현되는 &lt;em&gt;Nouns(Resources)&lt;/em&gt;, GET or POST 등의 HTTP 메소드인 &lt;em&gt;Verbs&lt;/em&gt;, XML or JSON 등으로 표현하는 &lt;em&gt;Representaions&lt;/em&gt;&lt;/p&gt;
&lt;h4&gt;Resources&lt;/h4&gt;
&lt;p&gt;REST 의 리소스는 다음과 같이 표기한다. 리소스에는 문서나 이미지, 리소스 컬렉션 등이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;http://www.conFusion.food/dishes/			# Retrieve all dishses
http://www.conFusion.food/dishes/123		# Retrieve information about the specific dish (id:123)
http://www.conFusion.food/promotions/
http://www.conFusion.food/leadership/
http://www.conFusion.food/leadership/456&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Verbs&lt;/h4&gt;
&lt;p&gt;Verb 에 해당하는 HTTP 메소드는 각각 다음과 같은 의미를 가진다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GET -&gt; READ&lt;/li&gt;
&lt;li&gt;POST -&gt; CREATE&lt;/li&gt;
&lt;li&gt;PUT -&gt; UPDATE&lt;/li&gt;
&lt;li&gt;DELETE -&gt; DELETE&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;GET 메소드는 클라이언트가 서버에게 어떤 리소스를 요청하는 메소드이다. 어떤 GET 메소드가 서버에 요청(Request)이 들어오면, 서버는 XML 또는 JSON 형태로 클라이언트(브라우저)에게 응답(Response)을 한다.&lt;/p&gt;
&lt;h4&gt;Representaions&lt;/h4&gt;
&lt;p&gt;표현을 위해 클라이언트에게 어떤 데이터를 보낼 것이냐 하는 것인데, 가장 많이 쓰이는 두가지 방식이 바로 JSON 과 XML 이다. 최근에는 JSON 타입이 정보 교환을 위한 standards 로 여겨지고 있다.&lt;/p&gt;
&lt;h4&gt;Stateless&lt;/h4&gt;
&lt;p&gt;REST 는 상태를 저장하지 않다. 매 요청바다 항상 새로운 요청이 발생하게 된다. 그렇기 때문에 클라이언트측에서 요청에 따라 상태가 변화하는 것을 트래킹하기 위해서는 클라이언트 자신이 요청 전의 상태를 기억하고 있어야 한다.&lt;/p&gt;
&lt;h3&gt;Clint-Server Communication using $resource&lt;/h3&gt;
&lt;h4&gt;Angular ngResource&lt;/h4&gt;
&lt;p&gt;ngResource 모듈은 restful API 서버와 통신하기 위해 $http 보다 고수준의 추상화를 제공한다(흠…). angular core 가 아니기 때문에 따로 설치해 줘야 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;bower install angular-resource -S&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;DI 를 이용해서 ngResource 를 사용할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;angular.module(&amp;#39;confusionApp&amp;#39;, [&amp;#39;ui.router&amp;#39;, &amp;#39;ngResource&amp;#39;])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Angular $resource Service&lt;/h4&gt;
&lt;p&gt;$http 에 비해 $resource 는 훨씬 편리하게 사용할 수 있다. 우선 사용 예시를 살펴보기 전에 $resource 서비스를 사용하기 위해서는 사용하고자하는 service 나 controller 에 DI 로 추가한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;.service(&amp;#39;menuFactory&amp;#39;, [&amp;#39;$resouce&amp;#39;, &amp;#39;baseURL&amp;#39;, function($resource, baseURL) {

	...

	$scope.dishes = $resouce(baseURL + &amp;quot;dishes/:id&amp;quot;, null, {&amp;#39;update&amp;#39;:{method:&amp;#39;PUT&amp;#39;}}).query();

	var dish = $resource(baseURL + &amp;quot;dishes/:id&amp;quot;, null, {&amp;#39;update&amp;#39;:{method:&amp;#39;PUT&amp;#39;}}).get({id:0}, function() {
			dish.name = &amp;quot;dovanut&amp;quot;;
			dish.$save();
		})
	...

}])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;$resource 의 기본 action 들은 다음과 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;{‘get’:{method:‘GET’},
‘save’:{method:‘POST’},
‘query’:{method:‘GET’, isArray:true},
‘remove’:{method:‘DELETE’},
‘delete’:{method:‘DELETE’}};&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;action 을 커스텀으로 만들 수도 있는데, 위의 예제에서 본 것 처럼 update 라는 메서드를 HTTP PUT 메서드로 정의해 놓으면 update() 함수를 사용할 수 있다. 다음의 예제를 보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$resource(baseURL+&amp;quot;dishes/:id&amp;quot;, null, {&amp;#39;update&amp;#39;:{method:&amp;#39;PUT&amp;#39;}}).update({id:$scope.dish.id},$scope.dish);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Angular Testing&lt;/h3&gt;
&lt;p&gt;Angular 테스팅은 unit 테스트를 제공한다. unit 테스트란 각 부분의 독립된 로직을 테스트하는 기법을 말하는데, Angluar 에서는 작성한 controller, filter, factory, service 등의 모듈을 개별적으로 검사할 수 있다. 그렇기 때문에 angular 로 작성한 코드는 DOM 과는 완전히 분리되어 테스트할 수가 있다.&lt;/p&gt;
&lt;h4&gt;Jasmine&lt;/h4&gt;
&lt;p&gt;angularJS 를 테스트하기위해 Behavior driven development 프레임웍인 Jasmine 을 이용한다. 구체적으로 그룹 테스트를 위해 “describe” 함수를 이용하고, 개별테스트를 위해서 “it” 함수를 이용한다.&lt;/p&gt;
&lt;p&gt;다음의 예를 보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;describe(&amp;#39;Controller:MenuController&amp;#39;, function() {
	it(&amp;#39;should create &amp;quot;dishes&amp;quot; with 2 dishes fetched from xhr&amp;#39;, function() {
		// showMenu가 true이길 기대함
		expect(scope.showMenu).toBeTruthy();
		// dishes가 정의됨을 기대함
		expect(scope.dishes).toBeDefined();
		// dishes의 개수가 2개임을 기대함
		expect(scope.dishes.length).toBe(2);
	});
});&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;describe 는 MenuController 를 테스트 한다는것을 말한다. 두번째 it 은 xhr 로부터 dishes 가 2 dishes 가 fetched 된 dishes 가 만들어질 것이라는 걸 말하고 두번째 인자에 들어간 함수 내에서는 expect 함수로 각각의 조건이 만족하는지를 체크한다.&lt;/p&gt;
&lt;h4&gt;Karma&lt;/h4&gt;
&lt;p&gt;카르마는 자바스크립트 기반 command line tool 이다(NodeJS application). 카르마를 이용하면 Jasmine 으로 테스트한 결과를 브라우저로 가져와 쉽게 확인할 수 있다.&lt;/p&gt;
&lt;h4&gt;angular-mocks&lt;/h4&gt;
&lt;p&gt;ngMock 모듈을 이용하면 테스트의 결과를 의존성을 가지는 다른 서비스나 컨트롤러에 미리 적용해 볼 수 있다. 한가지 예로 $httpBackend 를 이용하면 서버에 XHR 리퀘스트를 테스트로 날려볼수도 있다.&lt;/p&gt;
&lt;h4&gt;exercise&lt;/h4&gt;
&lt;p&gt;우선 필요한 모듈들을 install 한다. 글로벌로 설치하는 건 상관없지만 그 외에는 conFusion 폴더 내에서 설치하도록 하자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# 자스민 코어 설치
sudo npm install jasmine-core --save-dev

# karma-jasmine 설치
sudo npm install karma-jasmine --save-dev

# 카르마, 클라이언트 설치
sudo npm install karma --save-dev
sudo npm install karma-cli -g
sudo npm install karma-cli --save-dev

# 카르마를 통한 결과를 크롬에 보여주기 위한 모듈 설치
sudo npm install phantomjs karma-phantomjs-launcher karma-chrome-launcher --save-dev

# angular mocks 설치
bower install angular-mocks -S&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;/conFusion/test 폴더를 생성하고 karma.conf.js 파일을 생성한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;module.exports = function(config) {
	config.set({
		basePath: &amp;#39;../&amp;#39;,
		frameworks: [&amp;#39;jasmine&amp;#39;],
		// list of files, 테스트하려는 파일 목록
		files: [
			&amp;#39;bower_components/angular/angular.js&amp;#39;,
			&amp;#39;bower_components/angular-resource/angular-resource.js&amp;#39;,
			&amp;#39;bower_components/angular-ui-router/release/angular-ui-router.js&amp;#39;,
			&amp;#39;bower_components/angular-mocks/angular-mocks.js&amp;#39;,
			&amp;#39;app/scripts/*.js&amp;#39;,
			&amp;#39;test/unit/**/*.js&amp;#39;
		],
		// list of files to exclude, 테스트 제외 목록
		exclude: [
			&amp;#39;test/protractor.conf.js&amp;#39;, &amp;#39;test/e2e/*.js&amp;#39;
		],
		preprocessors: {

		},
		// test results reporter to use
		// possible values: &amp;#39;dots&amp;#39;, &amp;#39;progress&amp;#39;
		reporters: [&amp;#39;progress&amp;#39;],
		port: 9876,
		// colors in the output (reporters and logs)
		colors: true,
		// config.LOG_DISALBE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG
		logLevel: config.LOG_INFO,
		// 파일 변경시 auto reload
		autoWatch: true,
		// browser, available browser launchers
		browsers: [&amp;#39;Chrome&amp;#39;, &amp;#39;PhantomJS&amp;#39;, &amp;#39;PhantomJS_custom&amp;#39;],
		customLaunchers: {
			&amp;#39;PhantomJS_custom&amp;#39;: {
				base: &amp;#39;PhantomJS&amp;#39;,
				options: {
					windowName: &amp;#39;my-window&amp;#39;,
					settings: {
						webSecurityEnabled: false
					},
				},
				flags: [&amp;#39;--load-images=true&amp;#39;],
				debug: true
			}
		},
		phantomjsLauncher: {
			// ResourceError 발생시 phantomjs 종료, 비정상 종료시 유용함
			exitOnResourceError: true
		},
		// Continuous Integration mode
		// if true, Karma captures browsers, runs the tests and exits
		singleRun: false,
		// Concurrency level
		concurrency: Infinity

	})
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;conFusion/test/unit/menucontroller.js 파일을 생성해서 unit 테스트를 실행한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[[coursera] AngularJS week 3-2]]></title><description><![CDATA[Single Page Applications Angular ngRoute and Single Page Applications Single Page Applications(SPA) Single Page Application…]]></description><link>https://blueshw.github.io/2016/09/05/frontend-javascript-framework-angularjs-week3-2/</link><guid isPermaLink="false">https://blueshw.github.io/2016/09/05/frontend-javascript-framework-angularjs-week3-2/</guid><pubDate>Mon, 05 Sep 2016 23:10:10 GMT</pubDate><content:encoded>&lt;h2&gt;Single Page Applications&lt;/h2&gt;
&lt;h3&gt;Angular ngRoute and Single Page Applications&lt;/h3&gt;
&lt;h4&gt;Single Page Applications(SPA)&lt;/h4&gt;
&lt;p&gt;Single Page Application 이란, 말그대로 하나의 페이지에서 동작하는 어플리케인션을 말한다. 기존의 웹사이트를 보면, 어떤 페이지를 서버에 요청하면 서버가 요청 받은 페이지를 브라우저에 보내는 방식이 반복되는 형태였다. 그래서 어떤 페이지로 이동하려면 서버에 해당 페이지 전부를 요청해야만 했다. 이런방법은 사실 header 나 footer, js, css 파일 등과 같이 모든 페이지에서 필요로하는 것들을 매번 요청해야하는 문제가 따른다(물론 캐싱이 된다).
하지만 SPA 는 index.html 과 같은 single master page 를 다운받은 후, 다른 페이지로 이동하는 것이 아니라 서버에 필요한 데이터만 요청하여 화면을 바꿔치기 하는 형태로 동작한다.&lt;/p&gt;
&lt;p&gt;하지만 SPA 도 극복해야할 문제들이 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;검색엔진 같은 경우, 검색 후 결과를 클릭하면 다른 웹사이트로 이동해야하는데 과연 SPA 로 가능할것이냐?
SPA 같은 경우는 서버의 데이터를 다운받아 클라이언트에서 사용하게 되는데 이때 서버와 클라이언트 중에 어디에 책임을 전가해야할지를 정하는 문제
단일 페이지이기 때문에 history 관리가 어려운 문제
페이지의 데이터를 모으기 어려운 문제
필요한 모든 라이브러리 및 페이지가 들어있는 최초의 페이지를 읽어 올때의 속도 문제&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;Angular and SPA&lt;/h4&gt;
&lt;p&gt;지금까지 봐왔던 많은 요소들은 Angular JS 로 SPA 디자인이 가능하다는 것을 보여주고 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;one-way and two-way 바인딩
MVC/MVVM/MVW 프레임워크
view -&gt; template 을 사용하고 controller 를 통해서 모델의 데이터를 이용해서 render
location and routing 을 제공&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;SPA 에서 서버는 REST API 를 통해서 데이터를 제공하거나 static HTML, Angular templates 와 리소스를 제공한다. 클라이언트는 Temlating 과 라우팅을 이용하여 뷰를 그리는 역할을 한다.&lt;/p&gt;
&lt;h4&gt;Deep Linking&lt;/h4&gt;
&lt;p&gt;검색이 가능하거나 indexing 이 가능한 웹페이지 내 컨텐츠의 하이퍼링크를 말한다.
예를들면,&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;http://www.conFusion.food/index.html#/menu/0&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;해시태그(#)가 url 에 왜 붙었느냐??
url 에 해시태그가 붙으면 해시태그 이후에 나타나는 부분에 대해서는 서버에 요청(?)하지 말라는 의미다. 즉, reload 안하겠다는 거다. 이미 index.html 페이지에 위치한 상태에서 #/menu/0 가 붙는다고 페이지가 리로드 되지 않는다. 다만, #/menu/0 에 해당하는 리소스를 찾는다. angularJS 에서는 router 의해 해당 리소스를 찾게된다. 물론 페이지가 리로드되지 않지만 해시태그 뒷부분 url 의 데이터가 서버에 위치할 수도 있지만 아마 그때는 ajax 로 데이터를 가져오지 않을까 싶다.&lt;/p&gt;
&lt;p&gt;즉, angularJS 에서는 url 의 해시태그 뒷부분을 handling 하여 페이지를 변경하게된다.&lt;/p&gt;
&lt;h4&gt;$location service&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;현재 주소창의 URL 을 보여준다.&lt;/li&gt;
&lt;li&gt;back / forward 버튼 등에 의한 url 변화에 대해 동기화시켜준다.&lt;/li&gt;
&lt;li&gt;url(), path(), search(), hash() 등의 메서드로 get / set 을 통해 url 을 변경할 수 있도록 해준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;ngRoute Module&lt;/h4&gt;
&lt;p&gt;우선 install 한다. conFusion 폴더에서 실행한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;bower install angular-route -S&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ngRoute 는 $location 서비스와 렌더된 뷰 사이의 관계를 관리한다. url 을 변경할 필요가 있으면 $location 서비스의 메서드를 이용하여 url 변경(# 뒷부분)하여 페이지를 갱신할 수 있다.&lt;/p&gt;
&lt;p&gt;다음과 괕이 angular module 에서 사용된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// 의존적으로 주입한다.
angular.module(&amp;#39;confusionApp&amp;#39;, [&amp;#39;ngRoute&amp;#39;])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ngRoute 에서는 Angular provider 를 사용할 수 있는데, provider 는 url 이 변경됨에 따라 그에 알맞는 적절한 template 과 url(handlers)로 매핑시켜준다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;angular.module(&amp;#39;confusionApp&amp;#39;, [&amp;#39;ngRoute&amp;#39;])
	// 라우팅을 위해 config 함수를 사용한다.
	// 파라미터로 $routeProvider가 들어간다.
    .config(function($routeProvider) {

      $routeProvider
        .when(&amp;#39;/contactus&amp;#39;, {
          templateUrl : &amp;#39;contactus.html&amp;#39;,
          controller : &amp;#39;ContactController&amp;#39;
        })

        .when(&amp;#39;/menu&amp;#39;, {
          templateUrl : &amp;#39;menu.html&amp;#39;,
          controller : &amp;#39;MenuController&amp;#39;
        })

        .when(&amp;#39;/menu/:id&amp;#39;, {
          templateUrl : &amp;#39;dishDetail.html&amp;#39;,
          controller : &amp;#39;DishDetailController&amp;#39;
        })
        // 디폴트, 아무것도 매치가 안되면 otherwise 실행
        .otherwise(&amp;#39;/contactus&amp;#39;)
    })
;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;url 이 변경되면 해당되는 url 을 $routeProvider.when 의 첫번째 파라미터에서 찾은 다음 각각 알맞는 template 과 contoller 를 지정해주어 view 를 렌더링한다.&lt;/p&gt;
&lt;p&gt;$routeParams 를 이용하면 주어진 파라미터로 url 에 삽입할 수 있다.
예를 보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// menu.html
&amp;lt;div class=&amp;quot;media-left media-middle&amp;quot;&amp;gt;
	&amp;lt;a ng-href=&amp;quot;#/menu/{{dish._id}}&amp;quot;&amp;gt;

// controllers.js
.controller(&amp;#39;DishDetailController&amp;#39;, [&amp;#39;$scope&amp;#39;, &amp;#39;$routeParams&amp;#39;,
	&amp;#39;menuFactory&amp;#39;, function($scope, $routeParams, menuFactory) {
		var dish = menuFactory.getDish(parseInt($routeParams.id, 10));
	}]);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;/menu/[id]와 같은 url 이 들어왔을때 [id] 부분은 파라미터로 처리한다.
만약 dish 이미지를 클릭햇을때 각각의 detail 페이지로 이동하는 동작을 처리한다고 생각해보자. 각각의 dish 에 id 를 부여하고 이미지의 a 태그에 id 를 이용하여 링크를 만들어 둔다.&lt;/p&gt;
&lt;p&gt;이미지를 클릭하면 DishDetailController 에 의존적으로 주입한 $routeParams 에 url 에 전달된 dish._id 가 id 라는 이름으로 들어가 이 id 에 해당하는 dish 데이터를 가져오게 될 것이다.&lt;/p&gt;
&lt;p&gt;마지막으로 지난 강의에서 index.html 의 header 와 footer 사이에 넣었던 ng-include 를 ng-view 로 변경하자. ng-view directive 는 $route 서비스와 함께 동작하여 url 변경에 따라 현재 렌더링된 템플릿을 html 파일에 포함시켜준다.&lt;/p&gt;
&lt;h3&gt;Angular UI-Router for Single Page Applications&lt;/h3&gt;
&lt;p&gt;이전 강의에서 살펴본 ngRoute 는 한계가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;한 페이지 당 하나의 뷰만 사용이 가능하다 (no multiple, no nested)&lt;/li&gt;
&lt;li&gt;view 가 url 에 종속적이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이에반해 UI Router 는 어플리케이션의 상태에 기반을 두고 있다. 이 말은 즉, url 이 바뀌지 않아도 일부분을 바꿀 수 있다는 뜻이다. (multiple, nested)&lt;/p&gt;
&lt;p&gt;우선 설치부터 하자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;bower install angular-ui-router -S&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;사용법은 이전과 비슷하다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;angular.module(&amp;#39;confusionApp&amp;#39;, [&amp;#39;ui.router&amp;#39;])
	.config(function($stateProvider, $urlRouterProvider) {
		$stateProvider
			.state(&amp;#39;app&amp;#39;, {
				url:&amp;#39;/&amp;#39;,
				views: {
					&amp;#39;header&amp;#39;: {templateUrl: &amp;#39;views/header&amp;#39;html},
					&amp;#39;content&amp;#39;: {template: &amp;#39;&amp;lt;h1&amp;gt;To be Completed&amp;lt;/h1&amp;gt;&amp;#39;, controller : &amp;#39;IndexController&amp;#39;}
					&amp;#39;footer&amp;#39;: {templateUrl: &amp;#39;views/footer.html&amp;#39;}
				}
			})
			.state(&amp;#39;app.aboutus&amp;#39;, {
				url:&amp;#39;aboutus&amp;#39;,
				views: {
					&amp;#39;content@&amp;#39;: {template: &amp;#39;&amp;lt;h1&amp;gt;To be Completed&amp;lt;/h1&amp;gt;&amp;#39;, controller : &amp;#39;AboutController&amp;#39;}

			});
			// default
			$urlRouterProvider.otherwise(&amp;#39;/&amp;#39;);
	})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;state 에 따라서 각각 url 을 지정해줄 수 있다. 그리고 views 속성에 여러 뷰(multiple)를 선언해줄 수도 있다.&lt;/p&gt;
&lt;p&gt;두번째 state 는 app 의 nested view 를 나타내는데, 특이하게 content 뒤에 ’@’ 마크가 붙어 있다. 이는 해당 view 가 content 에 속하는 view 라는 것을 말해준다.&lt;/p&gt;
&lt;p&gt;위의 state 내 views 속성에 지정해둔 view name 은 html 코드에서 ui-view 로 매핑시켜준다.
그리고 ui-sref 속성은 state 를 변경 시켜주는데 사용한다. href 가 url 을 이동하기 위한 속성이었다면 ui-sref 는 url 은 변경시켜주지 않고 속성만 바꾸는 link 역할을 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;div ui-view=&amp;quot;header&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div ui-view=&amp;quot;content&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div ui-view=&amp;quot;footer&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;

&amp;lt;a ui-sref=&amp;quot;app&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;
&amp;lt;a ui-sref=&amp;quot;app.aboutus&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;
&amp;lt;a ui-sref=&amp;quot;app.menu&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;$routeParams 와 마찬가지로 $stateParams 를 사용할 수 있다.
사용법은 기존과 거의 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// menu.html
&amp;lt;a ui-sref=&amp;quot;app.dishdetails({id:dish._id})&amp;quot;&amp;gt; ... &amp;lt;/a&amp;gt;

// DishDetailController
.controller(&amp;#39;DishDetailController&amp;#39;, [&amp;#39;$scope&amp;#39;, &amp;#39;$stateParams&amp;#39;,
	&amp;#39;menuFactory&amp;#39;, function($scope, $stateParams, menuFactory) {
		var dish = menuFactory.getDish(parseInt(parseInt($stateParams.id,10));
		$scope.dish = dish;
	}
])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[[coursera] AngularJS week 3-1]]></title><description><![CDATA[Single Page Applications Angular Factory, Service and Dependency Injection Dependency Injection Dependency Injection(DI…]]></description><link>https://blueshw.github.io/2016/09/02/frontend-javascript-framework-angularjs-week3-1/</link><guid isPermaLink="false">https://blueshw.github.io/2016/09/02/frontend-javascript-framework-angularjs-week3-1/</guid><pubDate>Fri, 02 Sep 2016 20:46:10 GMT</pubDate><content:encoded>&lt;h2&gt;Single Page Applications&lt;/h2&gt;
&lt;h3&gt;Angular Factory, Service and Dependency Injection&lt;/h3&gt;
&lt;h4&gt;Dependency Injection&lt;/h4&gt;
&lt;p&gt;Dependency Injection(DI)이란 의존성을 해결하기 위한 Inversino of Control(IoC)을 구현한 소프트웨어 디자인 패턴이다. IoC(제어의 역전)와 DI(의존성 주입)는 여전히 영어로든, 한글로 번역해서든 이해하기 힘든건 마찬가지다. 우선, Ioc 라는건 내가 짜놓은 것을 무언가 대신 해주는 개념으로 받아들이면 되겠다. 스프링 같은 프레임웍에서는 컨테이너라는 녀석이 바로 IoC 에 해당한다. IoC 개념을 이해하고 다시 DI 를 살펴보자. DI 는 구성 요소간의 의존관계를 무언가 대신 처리해주는(IoC, 설정 or 객체 or 무엇이든) 디자인 패턴이라 말할 수 있다. 여전히 조금 모호하다.&lt;/p&gt;
&lt;p&gt;마틴 파울러가 말한 DI 를 구현하는 세가지 방법은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Create dependency using new operator&lt;/li&gt;
&lt;li&gt;Look up dependency using a global variable&lt;/li&gt;
&lt;li&gt;Have dependency passed to it where needed&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위의 두가지에 비해서 세번째는 필요할때만 의존성을 주입하면 되므로 가장 유연하다.&lt;/p&gt;
&lt;h4&gt;Angular and DI&lt;/h4&gt;
&lt;p&gt;AngularJS 에서는 DI 를 구현하기 위해 비지니스 로직을 별도로 구현해 놓는다. 그리고 필요할 때마다 주입시켜서 사용한다.&lt;/p&gt;
&lt;p&gt;services, directives, filters and animations 등의 컴포넌트에서 DI 가 사용된다. 주입 가능한 factory method 나 생성자를 정의한 다음 Controller 와 같은 곳에 주입시켜 호출한다.&lt;/p&gt;
&lt;p&gt;또한 config 와 run method 역시 어떤 컴포넌트를 주입하여 사용 가능한다.
몇가지 예를 들어보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// 첫번째 방법은 array에 명시
module.controller(&amp;#39;MenuController&amp;#39;, [&amp;#39;$scope&amp;#39;, &amp;#39;menuFactory&amp;#39;, function($scope, menuFactory) {

}]);

// 두번째 방법은 property 추가
var MenuController = funciton($scope, menuFactory) {

};
MenuController.$Inject = [&amp;#39;$scope&amp;#39;, &amp;#39;menuFactory&amp;#39;];
module.controller(&amp;#39;MenuController&amp;#39;, MenuController);

// 세번째 방법은 Implicit annotation
module.controller(&amp;#39;MenuController&amp;#39;, function($scope, menuFactory) {

});&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Angular Factory and Service&lt;/h4&gt;
&lt;p&gt;factory 와 service 는 controller 에 데이터를 제공하기 위한 객체(?)이다. 그리고 아마 백엔드에서 데이터를 주고 받을때 factory 와 service 를 사용하지 않을까 싶다. 해당 내용은 추후 나오니 일단은 factory 와 service 에 집중하자.&lt;/p&gt;
&lt;h4&gt;Angular Services&lt;/h4&gt;
&lt;p&gt;service 는 여러개의 app 에 공통으로 사용되는 데이터 or 메서드를 담고 있다. 그렇기 때문에 DI 를 이용하여 필요한 곳에 주입되어야 하고 Lazily instantiated(필요할 때만 인스턴스화 되어야 함) 되어야 하며 singlton 객체여야한다.&lt;/p&gt;
&lt;p&gt;$http, $scope, $rootScope, $location, $parse, $templateCache, $animate $injector 와 같은 built-in 서비스들이 존재한다. 이외에 개발자가 직접 서비스를 등록할 수도 있는데, service(), factory(), provider(), constant(), value() 등의 메서드를 이용하면 가능하다.&lt;/p&gt;
&lt;h4&gt;Angular Factory&lt;/h4&gt;
&lt;p&gt;factory 는 보통 컨트롤러에 데이터를 제공하는 역할을 한다. factory 에서 미리 데이터와 메서드 셋을 만들어 둔 다음 필요한 컨트롤러에 의존적으로 주입해서 사용한다. 이렇게 보면 service 와 factory 의 차이가 별로 안 느껴지는데, 결정적으로 service 는 초기화 과정이 있기 때문에 prototype 상속이 가능한다. 그래서 보통 상속이 필요한 데이터 or 모델링은 서비스를 이용하고 정적인 메서드나 데이터 같은 경우에는 factory 를 많이 이용한다.&lt;/p&gt;
&lt;p&gt;우선 factory 사용 예를 보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// factory code
angular.module(&amp;#39;confusionApp&amp;#39;)
    .factory(&amp;#39;menuFactory&amp;#39;, function() {
    	var menufac = {};
    	var dishes = [ ... ];

    	menufac.getDishes = function() {
    		return dishes;
    	};

    	menufac.getDish = function (index) {
    		return dishes[index];
    	};
    	// 객체를 리턴한다.
    	return menufac;
    });

// usage
angular.module(&amp;#39;confusionApp&amp;#39;)
    .controller(&amp;#39;MenuController&amp;#39;, [&amp;#39;$scope&amp;#39;, &amp;#39;menuFactory&amp;#39;, function($scope, menuFactory) {
    	$scope.dishes = menuFactory.getDishes();
    }]);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;service 사용과 비교해보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// service code
angular.module(&amp;#39;confusionApp&amp;#39;)
    .service(&amp;#39;menuFactory&amp;#39;, function() {
    	// 객체선언, 리턴이 필요없다.
    	var dishes = [ ... ];

    	this.getDishes = function() {
    		return dishes;
    	};

    	this.getDish = function (index) {
    		return dishes[index];
    	};
    });

// usage
angular.module(&amp;#39;confusionApp&amp;#39;)
    .controller(&amp;#39;MenuController&amp;#39;, [&amp;#39;$scope&amp;#39;, &amp;#39;menuFactory&amp;#39;, function($scope, menuFactory) {
    	$scope.dishes = menuFactory.getDishes();
    }]);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;service 와 factory 의 사용법은 완전히 같다. 하지만 차이가 있는데, factory 는 객체를 생성해서 리턴을 한다. 하지만 service 의 경우에는 service() 함수가 호출되면서 기본 생성자가 만들어진다. 그래서 service 코드 내에서 this 로 바로 접근이 가능하기 때문에 별도로 객체를 만들어 리턴해줄 필요가 없다.&lt;/p&gt;
&lt;h4&gt;exercise&lt;/h4&gt;
&lt;p&gt;app.js&lt;/p&gt;
&lt;p&gt;모든 컨트롤러 코드는 controllers.js 로 이동한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;#39;use strict&amp;#39;;

angular.module(&amp;#39;confusionApp&amp;#39;, [])

;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;controllers.js&lt;/p&gt;
&lt;p&gt;controller 코드는 모두 controllers.js 로 이동하였고, 데이터를 가져오는 부분은 services.js 로 이동&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;#39;use strict&amp;#39;;

angular.module(&amp;#39;confusionApp&amp;#39;)
    .controller(&amp;#39;MenuController&amp;#39;, [&amp;#39;$scope&amp;#39;, &amp;#39;menuFactory&amp;#39;, function($scope, menuFactory){

        $scope.tab = 1;
        $scope.filtText = &amp;#39;&amp;#39;;
        $scope.showDetails = false;

        $scope.dishes = menuFactory.getDishes();

        ...

    }])

    ...

    .controller(&amp;#39;DishDetailController&amp;#39;, [&amp;#39;$scope&amp;#39;, &amp;#39;menuFactory&amp;#39;, function($scope, menuFactory) {
        var dish = menuFactory.getDish(3);
        $scope.dish = dish;

    }])

    ...

    ;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;services.js&lt;/p&gt;
&lt;p&gt;데이터 관련 파일은 모두 이쪽으로 이동 (factory / service 메서드 이용)
아래는 service 를 사용한 예제임.
그리고 dishdetail.html 에서 사용하던 comment 를 dishes 에 합쳐서 사용
각 dish 의 comment 속성에 리스트로 선언&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;#39;use strict&amp;#39;;

angular.module(&amp;#39;confusionApp&amp;#39;)
		.service(&amp;#39;menuFactory&amp;#39;, function() {
	        var dishes = [
				{
					name: &amp;#39;Uthapizza&amp;#39;,
					image: &amp;#39;images/uthapizza.png&amp;#39;,
					category: &amp;#39;mains&amp;#39;,
					label: &amp;#39;Hot&amp;#39;,
					price: &amp;#39;4.99&amp;#39;,
					description:&amp;#39;A unique combination of Indizan Uthappam (pancake) and Italian pizza, topped with Cerignola olives, ripe vine cherry tomatoes, Vidalia onion, Guntur chillies and Buffalo Paneer&amp;#39;,
					comment: &amp;#39;aaaaaaa&amp;#39;
				},

				...
			];

			this.getDishes = function() {
				return dishes;
			};

			this.getDish = function(index) {
				return dishes[index];
			};

		});&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Angular Templates&lt;/h3&gt;
&lt;p&gt;Angular Tmeplate 은 HTML 과 함께 쓰여진다. 동적 뷰(Dynamic View)를 만들기 위해서는 Angular Template 의 역할이 반드시 필요하다.&lt;/p&gt;
&lt;p&gt;Angular Template 은 Angular JS 의 여러 요소에 사용되었는데, Directives, Markup:{{expression}}, Filter, Form controls 등이 대표적이다.&lt;/p&gt;
&lt;h4&gt;ng-include directive&lt;/h4&gt;
&lt;p&gt;external HTML 조각을 HTML 내에 포함하기 위해 directive 다.
사용방법은 간단하다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;div ng-include=&amp;quot;&amp;#39;menu.html&amp;#39;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;ng-include src=&amp;quot;&amp;#39;menu.html&amp;#39;&amp;quot;&amp;gt;&amp;lt;/ng-include&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;두가지 방법이 있다. 태그의 속성으로 사용하거나 ng-include 태그를 사용하는 것이다.&lt;/p&gt;
&lt;p&gt;그리고 한가지 알아두어야 할 점이 있다. ng-include directive 를 사용하면 ng-controller 를 사용할 때처럼 새로운 scope 가 생성된다는 점이다.&lt;/p&gt;
&lt;h4&gt;exercise&lt;/h4&gt;
&lt;p&gt;index.html&lt;/p&gt;
&lt;p&gt;header, footer, js, css 등을 import 하는 부분을 모두 index.html 에 둔다. 그리고 필요한 부분에 menu.html, dishdetail.html, contactus.html 등의 파일을 ng-include 를 이용하여 포함시킨다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot; ng-app=&amp;quot;confusionApp&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;

...

&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;header class=&amp;quot;jumbotron&amp;quot;&amp;gt;

    	...

    &amp;lt;/header&amp;gt;

    &amp;lt;ng-include src=&amp;quot;&amp;#39;menu.html&amp;#39;&amp;quot;&amp;gt;&amp;lt;/ng-include&amp;gt;

    &amp;lt;footer class=&amp;quot;row-footer&amp;quot;&amp;gt;

    	...

    &amp;lt;/footer&amp;gt;

    ...

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;single page application 을 구현하기 위해서는 데이터가 변함에 따라서 ng-include 를 이용하여 동적으로 뷰를 전환할 필요가 있다. 다음 강의를 통해서 각 html 페이지끼리 이동하는 방법에 대해서 배워보도록 하자.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[[coursera] AngularJS week 2-2]]></title><description><![CDATA[Task Runners, Angular Scope, Forms and Form Validation-2 Angular Scope 스코프는 다음과 같이 정의된다. 스코프는 application model 과 관련된 object 다.
This is at…]]></description><link>https://blueshw.github.io/2016/08/28/frontend-javascript-framework-angularjs-week2-2/</link><guid isPermaLink="false">https://blueshw.github.io/2016/08/28/frontend-javascript-framework-angularjs-week2-2/</guid><pubDate>Sun, 28 Aug 2016 01:46:10 GMT</pubDate><content:encoded>&lt;h2&gt;Task Runners, Angular Scope, Forms and Form Validation-2&lt;/h2&gt;
&lt;h3&gt;Angular Scope&lt;/h3&gt;
&lt;p&gt;스코프는 다음과 같이 정의된다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;스코프는 application model 과 관련된 object 다.
This is at the core of Angular’s two-way data binding
view 와 controller 사이를 연결해주는 역할을 한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;우선 controller 에 scope 를 만들어 속성을 부여한다. 그리고 view 는 controller 에 정의된 속성들을 bind 한다. 이런 방식을 통해 view 와 controller 의 sync 를 맞춰준다.&lt;/p&gt;
&lt;h4&gt;$rootScope&lt;/h4&gt;
&lt;p&gt;가장 상위의 scope 다. app 이 시작되면 만들어진다. 새로운 스코프는 ng-controller 와 같은 directives 를 통해 만들수 있다. scope 의 구조는 DOM 의 구조와 비슷하다. 그렇기 때문에 child scope 에서는 parent scope 의 속성에 접근이 가능하지만 그 반대는 불가하다.&lt;/p&gt;
&lt;h4&gt;app.js&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// 기존 코드
angular.module(&amp;#39;confusionApp&amp;#39;, [])
    .controller(&amp;#39;MenuController&amp;#39;,function(){
        this.tab = 1;
        this.filtText = &amp;#39;&amp;#39;;

        ...

	});

// scope 적용 코드
angular.module(&amp;#39;confusionApp&amp;#39;, [])
	// scope 정의
    .controller(&amp;#39;MenuController&amp;#39;, [&amp;#39;$scope&amp;#39;,function($scope){
        $scope.tab = 1;
        $scope.filtText = &amp;#39;&amp;#39;;

        ...

    )]};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;기존의 코드를 보면 this 접근자를 통해서 속성들을 부여하고 있다. 여기서 스코프를 사용하면, this 가 아닌 scope 에 속성들을 부여함으로써 view 단에서 scope 를 통해 각 속성에 접근하게 된다.&lt;/p&gt;
&lt;h4&gt;menu.html&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;!-- 기존 코드 --&amp;gt;
&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;row row-content&amp;quot; ng-controller=&amp;quot;MenuController as menuCtrl&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;col-xs-12&amp;quot;&amp;gt;
            &amp;lt;ul class=&amp;quot;nav nav-tabs&amp;quot; role=&amp;quot;tablist&amp;quot;&amp;gt;
                &amp;lt;li role=&amp;quot;presentation&amp;quot; ng-class=&amp;quot;{active:menuCtrl.isSelected(1)}&amp;quot;&amp;gt;
                    &amp;lt;a ng-click=&amp;quot;menuCtrl.select(1)&amp;quot; aria-controls=&amp;quot;all menu&amp;quot;
                     role=&amp;quot;tab&amp;quot;&amp;gt;The Menu&amp;lt;/a&amp;gt;
                     ...
                &amp;lt;/li&amp;gt;
            &amp;lt;/ul&amp;gt;
            &amp;lt;div class=&amp;quot;tab-content&amp;quot;&amp;gt;
                &amp;lt;ul class=&amp;quot;media-list tab-pane fade in active&amp;quot;&amp;gt;
                    &amp;lt;li class=&amp;quot;media&amp;quot; ng-repeat=&amp;quot;dish in menuCtrl.dishes | filter:menuCtrl.filtText&amp;quot;&amp;gt;
                    ...
	                &amp;lt;/li&amp;gt;
	            &amp;lt;/ul&amp;gt;
	        &amp;lt;/div&amp;gt;
	    &amp;lt;/div&amp;gt;
	&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;


&amp;lt;!-- scope 적용 코드 --&amp;gt;
&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;row row-content&amp;quot; ng-controller=&amp;quot;MenuController&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;col-xs-12&amp;quot;&amp;gt;
            &amp;lt;ul class=&amp;quot;nav nav-tabs&amp;quot; role=&amp;quot;tablist&amp;quot;&amp;gt;
                &amp;lt;li role=&amp;quot;presentation&amp;quot; ng-class=&amp;quot;{active:isSelected(1)}&amp;quot;&amp;gt;
                    &amp;lt;a ng-click=&amp;quot;select(1)&amp;quot; aria-controls=&amp;quot;all menu&amp;quot;
                     role=&amp;quot;tab&amp;quot;&amp;gt;The Menu&amp;lt;/a&amp;gt;
                     ...
                &amp;lt;/li&amp;gt;
            &amp;lt;/ul&amp;gt;
            &amp;lt;div class=&amp;quot;tab-content&amp;quot;&amp;gt;
                &amp;lt;ul class=&amp;quot;media-list tab-pane fade in active&amp;quot;&amp;gt;
                    &amp;lt;li class=&amp;quot;media&amp;quot; ng-repeat=&amp;quot;dish in dishes | filter:filtText&amp;quot;&amp;gt;
                    ...
	                &amp;lt;/li&amp;gt;
	            &amp;lt;/ul&amp;gt;
	        &amp;lt;/div&amp;gt;
	    &amp;lt;/div&amp;gt;
	&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;기존코드에서는 menuController 의 alias 인 menuCtrl 을 만들어 각 변수와 함수 앞에 붙여줬었다. 하지만 MenuController 에 스코프가 적용되면서 해당 컨트롤러가 속한 DOM 내부에서는 컨트롤러 이름없이 변수/함수명으로 직접 접근이 가능해진다. 스코프를 적용함으로써 훨씬 코드가 간단해졌다.&lt;/p&gt;
&lt;h4&gt;ng-show&lt;/h4&gt;
&lt;p&gt;ng-show directive 는 주어진 조건(true/false)에 따라서 해당 DOM 객체를 보여줄것인지(show) 말것인지(not show)를 결정해준다. 길게 설명할 필요없이 예제를 보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;div class=&amp;quot;col-xs-12&amp;quot;&amp;gt;
    &amp;lt;button ng-click=&amp;quot;toggleDetails()&amp;quot; class=&amp;quot;btn btn-xs btn-primary pull-right&amp;quot; type=&amp;quot;button&amp;quot;&amp;gt;
        {{showDetails ? &amp;#39;Hide Details&amp;#39;:&amp;#39;Show Details&amp;#39;}}
    &amp;lt;/button&amp;gt;
    &amp;lt;ul class=&amp;quot;nav nav-tabs&amp;quot; role=&amp;quot;tablist&amp;quot;&amp;gt;
	    ...
	&amp;lt;/ul&amp;gt;
	...
        &amp;lt;p ng-show=&amp;quot;showDetails&amp;quot;&amp;gt;{{dish.description}}&amp;lt;/p&amp;gt;
    ...
&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;$scope.showDetails 를 app.js 에 설정해놓고 기본값으로 false 를 지정해놓자. 그리고는 button 을 하나 만들어 showDetails 가 true 이면 Hide Details 문구의 버튼을 노출하고 false 면 Show Details 문구의 버튼을 노출한다. 리스트의 요소중에 description 부분에 ng-show directive 를 선언하고 showDetails 를 넣어주자. 그리고 버튼을 클릭하면(showDetails 가 toggle 된다. app.js 에 function 을 만들어둔다.) showDetails 가 true 가 됐다가 false 가 되면서 description 이 보여졌다가 가려졌다가 할 것이다.&lt;/p&gt;
&lt;h3&gt;Angular Forms and Form Validation&lt;/h3&gt;
&lt;h4&gt;Forms&lt;/h4&gt;
&lt;p&gt;form 은 유저에게 웹 사이트의 정보를 제공하는 가장 널리 상요되는 방법이다. 이번 강의에서는 angularJS 에서 form 을 이용하는 방법과 form 의 validation 체크하는 방법에 대해서 알아보자.&lt;/p&gt;
&lt;p&gt;form 에서는 two-way data binding 이 중요하게 사용되는데,
넘어가기 앞서 잠깐 짚고 넘어가야할게 있다.
ng-model 의 개념이 약간 모호해서 한번 찾아봤다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;ng-model&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;html 의 input, select, textarea 와 같은 입력 요소에 값을 갱신하면 ng-model 해 설정된 변수의 값도 변함
반대로 변수의 값이 바뀌면 input 등의 화면도 동일하게 변경된다.
이를 two-way data binding 이라 한다.
참고로 form 필드에 설정된 ng-model 의 속성을 필드 내에서 부여할 수도 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;form 과 자바스크립트 object 간의 연결해주는 역할을 하는 것이 ng-model 이다. ng-model 에 설정된 변수가 변경되면 변경된 것을 html 에 그대로 반영해준다.
예를들어보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// javascript code
.controller(&amp;#39;ContactController&amp;#39;, [&amp;#39;$scope&amp;#39;, function($scope){
    $scope.feedback = {mychannel:&amp;quot;&amp;quot;, firstname:&amp;quot;&amp;quot;,
                       lastname:&amp;quot;&amp;quot;, agree:&amp;quot;&amp;quot;, email:&amp;quot;&amp;quot;};
}]);

// html code
&amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;form-control&amp;quot; id=&amp;quot;firstname&amp;quot;
	name=&amp;quot;firstname&amp;quot; placeholder=&amp;quot;Enter First Name&amp;quot;
	ng-model=&amp;quot;feedback.firstname&amp;quot; required&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위와 같이 angularJS 의 controller 에 feedback 이라는 object 를 만들어두고, html 에서 feedback.firstname 을 ng-model attribute 에 지정해두면, firstname 이 변함에 따라서 자동으로 feedback.firstname 의 값을 변경한다.&lt;/p&gt;
&lt;p&gt;select 의 경우에는 어떤가 보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// javascript code
var channels = [{value:&amp;quot;tel&amp;quot;, label:&amp;quot;Tel.&amp;quot;}, {value:&amp;quot;Email&amp;quot;, label:&amp;quot;Email&amp;quot;}];

// html code
&amp;lt;select class=&amp;quot;form-control&amp;quot; ng-model=&amp;quot;feedback.mychannel&amp;quot;
		ng-options=&amp;quot;channel.value as channel.label for channel in channels&amp;quot;&amp;gt;
	&amp;lt;option value=&amp;quot;&amp;quot;&amp;gt;Tel. or Email?&amp;lt;/option&amp;gt;
&amp;lt;/select&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;우선 select 의 item 들을 저장해둘 자바스크립트 array 변수 channels 를 만든다. 그리고 select 태그내에 ng-model, ng-options 를 위와 같이 설정해두자. ng-model 의 mychannel 에는 유저가 선택된 channel 의 value 가 들어갈 것이다. ng-options directive 에서 channels 라는 자바스크립트 array 를 for loop 로 분해하여 각각 channel 이라는 object 를 가져온다. 그리고 channel.label 이 option 의 text 로 들어가고, channel.value 가 option 태그의 value 로써 들어가게 된다. 즉, 만들어진 selectbox 의 item 하나를 선택하게 되면, 해당 item 의 value 가 feedback.mychannel 변수에 할당된다.&lt;/p&gt;
&lt;p&gt;위의 방법을 이용하면 form 의 다른요소나, 웹페이지의 상태에 따라 select 의 항목을 동적으로 바꿀 수 있게 된다.&lt;/p&gt;
&lt;h4&gt;Form Validation&lt;/h4&gt;
&lt;p&gt;우선 HTML5 form validation 을 끄자
그리고 ng-submit directive 를 이용하여 form 이 submit 될 때 sendFeedback 함수를 호출하도록 하자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;form class=&amp;quot;form-horizontal&amp;quot; name=&amp;quot;feedbackForm&amp;quot; ng-submit=&amp;quot;sendFeedback()&amp;quot; novalidate&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;validation 체크할때 field name 을 이용하여 다음의 필드 속성들을 체크할 수 있다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;property&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$pristine&lt;/td&gt;
&lt;td&gt;true if form has not been changed (form 의 변경사항이 없다면,)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$dirty&lt;/td&gt;
&lt;td&gt;reverse of $pristine&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$valid&lt;/td&gt;
&lt;td&gt;true if form field/whole form is valid (form 이 valid 하면,)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$invalid&lt;/td&gt;
&lt;td&gt;reverse of $valid&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;예를 들어보자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;feedbackForm.firstName.$pristine : firstName 필드의 변경사항이 없으면 true&lt;/li&gt;
&lt;li&gt;feebackForm.$valid : feedbackForm 의 모든 항목이 valid 하면 true&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;에러가 있을경우(invalid 하면) bootstrap 의 class 를 이용하자.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;.has-error, .has-warning, .has-success
.help-block to display helpful messages below the field&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;app.js&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;...

	.controller(&amp;#39;ContactController&amp;#39;, [&amp;#39;$scope&amp;#39;, function($scope){
	    $scope.feedback = {mychannel:&amp;quot;&amp;quot;, firstname:&amp;quot;&amp;quot;,
	                       lastname:&amp;quot;&amp;quot;, agree:&amp;quot;&amp;quot;, email:&amp;quot;&amp;quot;};
	    var channels = [{value:&amp;quot;tel&amp;quot;, label:&amp;quot;Tel.&amp;quot;},
	                    {values:&amp;quot;Email&amp;quot;, label:&amp;quot;Email&amp;quot;}];
	    $scope.channels = channels;
	    $scope.invalidChannelSelection = false;

	}])
	.controller(&amp;#39;FeedbackController&amp;#39;, [&amp;#39;$scope&amp;#39;, function($scope){
	    $scope.sendFeedback = function() {
	        console.log($scope.feedback);

	        if ($scope.feedback.agree &amp;amp;&amp;amp; ($scope.feedback.mychannel == &amp;quot;&amp;quot;)) {
	            $scope.invalidChannelSelection = true;
	            console.log(&amp;#39;incorrent&amp;#39;);
	        } else {
	            $scope.invalidChannelSelection = false;
	            $scope.feedback = {
	                mychannel:&amp;quot;&amp;quot;, firstname:&amp;quot;&amp;quot;,
	                lastname:&amp;quot;&amp;quot;, agree:false, email:&amp;quot;&amp;quot;
	            };
	            $scope.feedback.mychannel = &amp;quot;&amp;quot;;
	            $scope.feedbackForm.$setPristine();
	            console.log($scope.feedback);
	        }
	    };
	}]);

...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;contactus.html&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot; ng-app=&amp;quot;confusionApp&amp;quot;&amp;gt;

...

&amp;lt;body&amp;gt;
    &amp;lt;div class=&amp;quot;container&amp;quot; ng-controller=&amp;quot;ContactController&amp;quot;&amp;gt;
    	...
                &amp;lt;form class=&amp;quot;form-horizontal&amp;quot; role=&amp;quot;form&amp;quot; name=&amp;quot;feedbackForm&amp;quot; ng-submit=&amp;quot;sendFeedback()&amp;quot; novalidate&amp;gt;
                    &amp;lt;div class=&amp;quot;form-group&amp;quot; ng-class=&amp;quot;{ &amp;#39;has-error&amp;#39; : feedbackForm.firstname.$error.required &amp;amp;&amp;amp; !feedbackForm.firstname.$pristine }&amp;quot;&amp;gt;
                        &amp;lt;label for=&amp;quot;firstname&amp;quot; class=&amp;quot;col-sm-2 control-label&amp;quot;&amp;gt;First Name&amp;lt;/label&amp;gt;
                        &amp;lt;div class=&amp;quot;col-sm-10&amp;quot;&amp;gt;
                            &amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;form-control&amp;quot; id=&amp;quot;firstname&amp;quot; name=&amp;quot;firstname&amp;quot; placeholder=&amp;quot;Enter First Name&amp;quot; ng-model=&amp;quot;feedback.firstname&amp;quot; required&amp;gt;
                            &amp;lt;span ng-show=&amp;quot;feedback.firstname.$error.required &amp;amp;&amp;amp; !feedbackForm.firstname.$pristine&amp;quot; class=&amp;quot;help-block&amp;quot;&amp;gt;Your First name is required&amp;lt;/span&amp;gt;
                        &amp;lt;/div&amp;gt;
                    &amp;lt;/div&amp;gt;
                    &amp;lt;div class=&amp;quot;form-group&amp;quot; ng-class=&amp;quot;{ &amp;#39;has-error&amp;#39; : feedbackForm.lastname.$error.required &amp;amp;&amp;amp; !feedbackForm.lastname.$pristine }&amp;quot;&amp;gt;
                        &amp;lt;label for=&amp;quot;lastname&amp;quot; class=&amp;quot;col-sm-2 control-label&amp;quot;&amp;gt;Last Name&amp;lt;/label&amp;gt;
                        &amp;lt;div class=&amp;quot;col-sm-10&amp;quot;&amp;gt;
                            &amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;form-control&amp;quot; id=&amp;quot;lastname&amp;quot; name=&amp;quot;lastname&amp;quot; placeholder=&amp;quot;Enter Last Name&amp;quot; ng-model=&amp;quot;feedback.lastname&amp;quot; required&amp;gt;
                            &amp;lt;span ng-show=&amp;quot;feedback.lastname.$error.required &amp;amp;&amp;amp; !feedbackForm.lastname.$pristine&amp;quot; class=&amp;quot;help-block&amp;quot;&amp;gt;Your Last name is required&amp;lt;/span&amp;gt;
                        &amp;lt;/div&amp;gt;
                    &amp;lt;/div&amp;gt;
                    &amp;lt;div class=&amp;quot;form-group&amp;quot;&amp;gt;
                        &amp;lt;label for=&amp;quot;telnum&amp;quot; class=&amp;quot;col-sm-2 control-label&amp;quot;&amp;gt;Contact Tel.&amp;lt;/label&amp;gt;
                        &amp;lt;div class=&amp;quot;col-xs-5 col-sm-4 col-md-3&amp;quot;&amp;gt;
                            &amp;lt;div class=&amp;quot;input-group&amp;quot;&amp;gt;
                                &amp;lt;div class=&amp;quot;input-group-addon&amp;quot;&amp;gt;(&amp;lt;/div&amp;gt;
                                    &amp;lt;input type=&amp;quot;tel&amp;quot; class=&amp;quot;form-control&amp;quot; id=&amp;quot;areacode&amp;quot; name=&amp;quot;areacode&amp;quot; placeholder=&amp;quot;Area code&amp;quot; ng-model=&amp;quot;feedback.tel.areacode&amp;quot;&amp;gt;
                                &amp;lt;div class=&amp;quot;input-group-addon&amp;quot;&amp;gt;)&amp;lt;/div&amp;gt;
                            &amp;lt;/div&amp;gt;
                        &amp;lt;/div&amp;gt;
                        &amp;lt;div class=&amp;quot;col-xs-7 col-sm-6 col-md-7&amp;quot;&amp;gt;
                                    &amp;lt;input type=&amp;quot;tel&amp;quot; class=&amp;quot;form-control&amp;quot; id=&amp;quot;telnum&amp;quot; name=&amp;quot;telnum&amp;quot; placeholder=&amp;quot;Tel. number&amp;quot; ng-model=&amp;quot;feedback.tel.number&amp;quot;&amp;gt;
                        &amp;lt;/div&amp;gt;
                    &amp;lt;/div&amp;gt;
                    &amp;lt;div class=&amp;quot;form-group&amp;quot; ng-class=&amp;quot;{ &amp;#39;has-error&amp;#39; : feedbackForm.emailid.$invalid &amp;amp;&amp;amp; !feedbackForm.emailid.$pristine }&amp;quot;&amp;gt;
                        &amp;lt;label for=&amp;quot;emailid&amp;quot; class=&amp;quot;col-sm-2 control-label&amp;quot;&amp;gt;Email&amp;lt;/label&amp;gt;
                        &amp;lt;div class=&amp;quot;col-sm-10&amp;quot;&amp;gt;
                            &amp;lt;input type=&amp;quot;email&amp;quot; class=&amp;quot;form-control&amp;quot; id=&amp;quot;emailid&amp;quot; name=&amp;quot;emailid&amp;quot; placeholder=&amp;quot;Email&amp;quot; ng-model=&amp;quot;feedback.email&amp;quot; required&amp;gt;
                            &amp;lt;span ng-show=&amp;quot;feedbackForm.emailid.$invalid &amp;amp;&amp;amp; !feedbackForm.emailid.$pristine&amp;quot; class=&amp;quot;glyphicon glyphicon-remove form-control-feedback&amp;quot; aria-hidden=&amp;quot;true&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
                            &amp;lt;span ng-show=&amp;quot;feedbackForm.emailid.$invalid &amp;amp;&amp;amp; !feedbackForm.emailid.$pristine&amp;quot; class=&amp;quot;help-block&amp;quot;&amp;gt;Enter a valid email address.&amp;lt;/span&amp;gt;
                            &amp;lt;span ng-show=&amp;quot;feedbackForm.emailid.$error.required &amp;amp;&amp;amp; !feedbackForm.emailid.$pristine&amp;quot; class=&amp;quot;help-block&amp;quot;&amp;gt;Enter a valid email address.&amp;lt;/span&amp;gt;
                        &amp;lt;/div&amp;gt;
                    &amp;lt;/div&amp;gt;
                    &amp;lt;div class=&amp;quot;form-group&amp;quot; ng-class=&amp;quot;{ &amp;#39;has-error&amp;#39; : invalidChannelSelection }&amp;quot;&amp;gt;
                       &amp;lt;div class=&amp;quot;checkbox col-sm-5 col-sm-offset-2&amp;quot;&amp;gt;
                            &amp;lt;label class=&amp;quot;checkbox-inline&amp;quot;&amp;gt;
                                &amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;approve&amp;quot; value=&amp;quot;&amp;quot; ng-model=&amp;quot;feedback.agree&amp;quot;&amp;gt;
                                &amp;lt;strong&amp;gt;May we contact you?&amp;lt;/strong&amp;gt;
                            &amp;lt;/label&amp;gt;
                        &amp;lt;/div&amp;gt;
                        &amp;lt;div class=&amp;quot;col-sm-3 col-sm-offset-1&amp;quot; ng-show=&amp;quot;feedback.agree&amp;quot;&amp;gt;
                            &amp;lt;select class=&amp;quot;form-control&amp;quot; ng-model=&amp;quot;feedback.mychannel&amp;quot; ng-options=&amp;quot;channel.value as channel.label for channel in channels&amp;quot;&amp;gt;
                                &amp;lt;option value=&amp;quot;&amp;quot;&amp;gt;Tel. or Email?&amp;lt;/option&amp;gt;
                            &amp;lt;/select&amp;gt;
                            &amp;lt;span ng-show=&amp;quot;invalidChannelSelection&amp;quot; class=&amp;quot;help-block&amp;quot;&amp;gt;Select an option.&amp;lt;/span&amp;gt;
                        &amp;lt;/div&amp;gt;
                    &amp;lt;/div&amp;gt;
                    &amp;lt;div class=&amp;quot;form-group&amp;quot;&amp;gt;
                        &amp;lt;label for=&amp;quot;feedback&amp;quot; class=&amp;quot;col-sm-2 control-label&amp;quot;&amp;gt;Your Feedback&amp;lt;/label&amp;gt;
                        &amp;lt;div class=&amp;quot;col-sm-10&amp;quot;&amp;gt;
                            &amp;lt;textarea class=&amp;quot;form-control&amp;quot; id=&amp;quot;feedback&amp;quot; name=&amp;quot;feedback&amp;quot; rows=&amp;quot;12&amp;quot; ng-model=&amp;quot;feedback.comments&amp;quot;&amp;gt;&amp;lt;/textarea&amp;gt;
                        &amp;lt;/div&amp;gt;
                    &amp;lt;/div&amp;gt;
                    &amp;lt;div class=&amp;quot;form-group&amp;quot;&amp;gt;
                        &amp;lt;div class=&amp;quot;col-sm-offset-2 col-sm-10&amp;quot;&amp;gt;
                            &amp;lt;button type=&amp;quot;submit&amp;quot; class=&amp;quot;btn btn-primary&amp;quot; ng-disabled=&amp;quot;feedbackForm.$invalid&amp;quot;&amp;gt;Send Feedback&amp;lt;/button&amp;gt;
                        &amp;lt;/div&amp;gt;
                    &amp;lt;/div&amp;gt;
                &amp;lt;/form&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;div class=&amp;quot;col-xs-12 col-sm-3&amp;quot;&amp;gt;
                &amp;lt;h3&amp;gt;Your Current Feedback:&amp;lt;/h3&amp;gt;
                &amp;lt;p&amp;gt;{{feedback.firstname}} {{feedback.lastname | uppercase }}&amp;lt;/p&amp;gt;
                &amp;lt;p&amp;gt;Contact Tel.: ({{feedback.tel.areacode}}){{feedback.tel.number}}&amp;lt;/p&amp;gt;
                &amp;lt;p&amp;gt;Contact Email: {{feedback.email}}&amp;lt;/p&amp;gt;
                &amp;lt;p ng-show=&amp;quot;feedback.agree&amp;quot;&amp;gt;Contact by:{{feedback.mychannel}}&amp;lt;/p&amp;gt;
                &amp;lt;p&amp;gt;Comments: {{feedback.comments}}&amp;lt;/p&amp;gt;
            &amp;lt;/div&amp;gt;
       &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[[coursera] AngularJS week 2-1]]></title><description><![CDATA[Task Runners, Angular Scope, Forms and Form Validation-1 Web Tools: Grunt and Gulp Task-Runners 웹개발을 하다보면 반복적으로 처리해야하는 태스크가 많이 있다. DRY(do…]]></description><link>https://blueshw.github.io/2016/08/25/frontend-javascript-framework-angularjs-week2-1/</link><guid isPermaLink="false">https://blueshw.github.io/2016/08/25/frontend-javascript-framework-angularjs-week2-1/</guid><pubDate>Thu, 25 Aug 2016 02:30:10 GMT</pubDate><content:encoded>&lt;h2&gt;Task Runners, Angular Scope, Forms and Form Validation-1&lt;/h2&gt;
&lt;h3&gt;Web Tools: Grunt and Gulp&lt;/h3&gt;
&lt;h4&gt;Task-Runners&lt;/h4&gt;
&lt;p&gt;웹개발을 하다보면 반복적으로 처리해야하는 태스크가 많이 있다. DRY(do not repeat yourself) 원칙에 따라 태스크를 자동화하기 빌드툴을 사용할 필요가 있다.&lt;/p&gt;
&lt;p&gt;CSS 에서 보면 Sass 나 Less 로 컴파일하거나, 어떤 vender prefixes 를 추가하거나 Minification(spaces, newlines, comments 등의 불필요한 캐릭터 삭제)하거나 Concatenation 등의 반복적이 Tasks 가 있다.&lt;/p&gt;
&lt;p&gt;Javascript 의 경우에는, JSHint 를 이용한 자바스크립트 에러체킹이나 Concatenation, Uglification(minification + mangling(변수명 char 하나로 줄이기)) 등이 있겠다.&lt;/p&gt;
&lt;p&gt;이 외에도 Image 용량 최적화, 태스크 rerunning, 변경된 사항 반영하기 위한 server and Livereload, 파일 변경, 테스팅 등의 반복적인 태스크가 있다.&lt;/p&gt;
&lt;p&gt;위에서 살펴본 반복적인 태스크를 Grunt, Gulp 등의 Task Runners 를 이용해 자동화 할 수 있다.&lt;/p&gt;
&lt;h3&gt;Grunt&lt;/h3&gt;
&lt;p&gt;Grunt 는 configuration 기반의 태스크 러너이다. 우선 install 하자. -g 옵션을 주어 global 하게 사용할 수 있도록 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;npm install -g grunt-cli&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Grunt 의 설정팔일은 Gruntfile.js 로 정의한다. 대략적인 구조를 살펴보면 아래와 같다.
function 의 argument 에 grunt 객체가 들어가고 그 아래에 필요한 코드를 추가한다. 자세한 내용은 차차 알아보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;module.exports = function(grunt) {
	// do requires here
	require(&amp;#39;jit-grunt&amp;#39;)(grunt);

	// do grunt task configurations here
	grunt.initConfig({

	});

	// register tasks here
	grunt.registerTask(&amp;#39;build&amp;#39;, [&amp;#39;jshint&amp;#39;]);
	grunt.registerTask(&amp;#39;default&amp;#39;, [&amp;#39;build&amp;#39;]);
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;File Globbing Patterns&lt;/h4&gt;
&lt;p&gt;Grunt 는 File Globbing Patterns 를 사용한다. File Globbing Patterns 이란 다음의 내용을 말한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;* 문자열, but not /&lt;/li&gt;
&lt;li&gt;? 문자 하나, but not /&lt;/li&gt;
&lt;li&gt;** 문자열 including /&lt;/li&gt;
&lt;li&gt;{} comma 로 or 를 표현함&lt;/li&gt;
&lt;li&gt;! 패턴매치가 negative 함&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;몇가지 예제를 살펴보자
우선 jshint 와 jshint-stylish 모듈을 install 한다.
jshint 는 자바스크립트의 문법을 체크해주는 모듈이다. 세미콜론이 빠졌거나, 괄호가 빠져 있는것 처럼 문법오류나 개선할 부분이 필요한 것을 체크해준다. jshint-stylish 는 jshint 의 메세지를 좀 더 잘 보여주기 위한 스타일을 제공하는 모듈이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;npm install grunt-contrib-jshint --save-dev
npm install jshint-stylish --save-dev&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그리고 Configuration 을 다음과 같이 작성하자.
Configuration 파일은 프로젝트 root 폴더에서 Gruntfile.js 를 만들어 아래 내용을 저장한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;jshint: {
	options: {
		jshintrc: &amp;#39;.jshintrc&amp;#39;,
		reporter: require(&amp;#39;jshint-stylish&amp;#39;)
	},
	all: {
		// 실제 체크할 자바스크립트 파일의 경로를 지정한다.
		// Gruntfile.js와 app/scripts의 모든 .js 파일을 검사하겠다는 의미다.
		src: [&amp;#39;Gruntfile.js&amp;#39;, &amp;#39;app/scripts/{,*/}*.js&amp;#39;]
	}
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;설정파일은 자바스크립트 객체 형식으로 구성된다. options 는 jshint 설정파일과 그외 포맷을 위한 style 모듈이 reporter 로 정의되어 있다. hshintrc 는 jshint 설정파일이다. all 부분은 jshint 를 적용할 자바스크트 파일을 Globbing 패턴으로 지정하였다.&lt;/p&gt;
&lt;h4&gt;Greating a Distribution Folder&lt;/h4&gt;
&lt;p&gt;수많은 Grunt 관련 모듈과 css, js 파일들을 설치함으로써 프로젝트 구성이 점점 복잡해지고 있다. 그래서 Distribution Folder 를 만들어 꼭 필요한 모듈만 이용하는 웹사이트를 만들어 보자.&lt;/p&gt;
&lt;p&gt;다음의 모듈을 설치한다.
global(-g) 옵션이 없는 설치는 local 설치이므로 모듈을 사용할 프로젝트 디렉토리에서 실행한다.&lt;/p&gt;
&lt;h4&gt;usemin module&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// 조건에 맞는 모든 파일을 원하는 폴더(여기서는 dist)로 복사한다.
npm install grunt-contrib-copy --save-dev

// 해당 폴더의 clean out 한다. rebuild를 위한 초반 작업이다. 그렇기 때문에 가장 먼저 실행해야한다.
npm install grunt-contrib-clean --save-dev

// js, css 파일들을 하나로 합쳐준다.
npm install grunt-contrib-concat --save-dev

// css 파일 minification
npm install grunt-contrib-cssmin --save-dev

// 자바스크립트 변수를 문자열 =&amp;gt; 문자로 변경한다.
npm install grunt-contrib-uglify --save-dev

// minification한 뒤, css, js 파일을 버전업한다. (브라우저 캐싱 대비)
// 해싱 알고리즘과 length등을 선택할 수 있다.
npm insatll grunt-filerev --save-dev

// css, js 파일을 minification 해준다.
// useminPrepare -&amp;gt; concat -&amp;gt; cssmin -&amp;gt; uglify -&amp;gt; filerev -&amp;gt; usemin의 순서로 태스크가 진행된다.
npm insatll grunt-usemin --save-dev&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;usemin 은 js, css 파이릉 minification 하기 위한 모듈이다. usemin 은 독자적으로 동작하지 않고 여러가지 모듈을 거쳐가는데 대체로 다음과 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;useminPrepare -&gt; concat -&gt; cssmin -&gt; uglify -&gt; filerev -&gt; usemin&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;우선 useminPrepare 는 html 주석 처리된 부분을 기준으로 css, js 각각의 하나의 파일로 합치기 위한 준비를 한다. concat 을 통해 css, js 파일들을 각각 하나로 합쳐준다. 그리고 cssmin, uglify 모듈을 통해 css, js 파일을 minification 하고 filerev 로 버전관리를 한다. 마지막으로 usemin 이 html 파일에 이전의 모든 모듈이 행한 결과를 반영한다.&lt;/p&gt;
&lt;h4&gt;watch&lt;/h4&gt;
&lt;p&gt;original 파일의 변경이 발생하였을때 rerun 하기 위한 모듈이다.
설정된 모든 파일중에 하나라도 변경이 일어나면 즉시 reload 한다.
reload 는 모든 파일들을 복사하는것과 같다고 보면 된다.
그런데, js, css 파일들은 copy 를 예외처리하는데, usemin 모듈에서 먼저 빌드처리 되기 때문에 watch 에서는 제외된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;npm install grunt-contrib-watch --save-dev&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;connect&lt;/h4&gt;
&lt;p&gt;브라우저에서 dist 폴더의 특정 html 파일(보통 index.html)이 실행되도록 한다.
watch 모듈과 같이 사용하면 이렇게 사용할 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;파일 변경 -&gt; livereload (build and copy) -&gt; open(update) browse&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;npm install grunt-contlib-connect --save-dev&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Gruntfile.js&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;#39;use strict&amp;#39;;

module.exports = function (grunt) {

	require(&amp;#39;time-grunt&amp;#39;)(grunt);
	require(&amp;#39;jit-grunt&amp;#39;)(grunt, {
		useminPrepare: &amp;#39;grunt-usemin&amp;#39;
	});

	grunt.initConfig({
		pkg: grunt.file.readJSON(&amp;#39;package.json&amp;#39;),
		jshint: {
			options: {
				jshintrc: &amp;#39;.jshintrc&amp;#39;,
				reporter: require(&amp;#39;jshint-stylish&amp;#39;)
			},
			all: {
				src: [
					&amp;#39;Gruntfile.js&amp;#39;,
					&amp;#39;app/scripts/{,*/}*.js&amp;#39;
				]
			}
		},
		useminPrepare: {
			html: &amp;#39;app/menu.html&amp;#39;,
			options: {
				dest: &amp;#39;dist&amp;#39;
			}
		},
		concat: {
			options: {
				separator: &amp;#39;;&amp;#39;
			},
			dist: {}
		},
		uglify: {
			dist: {}
		},
		cssmin: {
			dist: {}
		},
		filerev: {
			options: {
				encoding: &amp;#39;utf8&amp;#39;,
				algorithm: &amp;#39;md5&amp;#39;,
				length: 20
			},
			release: {
				files: [{
					src: [
						&amp;#39;dist/scripts/*js&amp;#39;,
						&amp;#39;dist/styles/*.css&amp;#39;
					]
				}]
			}
		},
		usemin: {
			html: [&amp;#39;dist/*.html&amp;#39;],
			css: [&amp;#39;dist/styles/*.css&amp;#39;],
			options: {
				assetsDirs: [&amp;#39;dist&amp;#39;, &amp;#39;dist/styles&amp;#39;]
			}
		},

		copy: {
			dist: {
				cwd: &amp;#39;app&amp;#39;,
				src: [&amp;#39;**&amp;#39;, &amp;#39;!styles/**/*.css&amp;#39;, &amp;#39;!scripts/**/*.js&amp;#39;],
				dest: &amp;#39;dist&amp;#39;,
				expand: true
			},
			fonts: {
				files:[
					{
						expand: true,
						dot: true,
						cwd: &amp;#39;bower_components/bootstrap/dist&amp;#39;,
						src: [&amp;#39;fonts/*.*&amp;#39;],
						dest: &amp;#39;dist&amp;#39;
					}, {
						expand: true,
						dot: true,
						cwd: &amp;#39;bower_components/font-awesome&amp;#39;,
						src: [&amp;#39;fonts/*.*&amp;#39;],
						dest: &amp;#39;dist&amp;#39;
					}
				]
			}
		},
		watch: {
			copy: {
				files: [&amp;#39;app/**&amp;#39;, &amp;#39;!app/**/*.css&amp;#39;, &amp;#39;!app/**/*.js&amp;#39;],
				tasks: [&amp;#39;build&amp;#39;]
			},
			scripts: {
				files: [&amp;#39;app/scripts/app.js&amp;#39;],
				tasks: [&amp;#39;build&amp;#39;]
			},
			styles: {
				files: [&amp;#39;app/styles/mystyles.css&amp;#39;],
				tasks:[&amp;#39;build&amp;#39;]
			},
			livereload: {
				options: {
					livereload: &amp;#39;&amp;lt;%= connect.options.livereload %&amp;gt;&amp;#39;
				},
				files: [
					&amp;#39;app/{,*/}*.html&amp;#39;,
					&amp;#39;.tmp/styles/{,*/}*.css&amp;#39;,
					&amp;#39;app/images/{,*/}*.{png,jpg,jpeg,gif,webp,svg}&amp;#39;
				]
			}
		},
		connect: {
			options: {
				port: 9000,
				hostname: &amp;#39;localhost&amp;#39;,
				livereload: 35729
			},
			dist: {
				options: {
					open: true,
					base: {
						path: &amp;#39;dist&amp;#39;,
						options: {
							index: &amp;#39;menu.html&amp;#39;,
							maxAge: 300000
						}
					}
				}
			}
		},
		clean: {
			build: {
				src: [&amp;#39;dist/&amp;#39;]
			}
		}
	});

	// 태스크 등록
	// 순서가 중요하다.
	// jshint로 모든 .js 파일을 검사하게 된다.
	grunt.registerTask(&amp;#39;build&amp;#39;, [
		&amp;#39;clean&amp;#39;,
		&amp;#39;jshint&amp;#39;,
		&amp;#39;useminPrepare&amp;#39;,
		&amp;#39;concat&amp;#39;,
		&amp;#39;cssmin&amp;#39;,
		&amp;#39;uglify&amp;#39;,
		&amp;#39;copy&amp;#39;,
		&amp;#39;filerev&amp;#39;,
		&amp;#39;usemin&amp;#39;
	]);

	// 순서가 중요하다. 먼저 build, 다음에는 브라우져 오픈, watch
	// watch가 마지막에 실행되므로, 파일 변경을 감지하면 build, 브라우저 오픈, 다시 watch 와 같은 순서로 진행된다.
	grunt.registerTask(&amp;#39;serve&amp;#39;, [&amp;#39;build&amp;#39;,&amp;#39;connect:dist&amp;#39;,&amp;#39;watch&amp;#39;]);
	grunt.registerTask(&amp;#39;default&amp;#39;, [&amp;#39;build&amp;#39;]);
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Gulp&lt;/h3&gt;
&lt;p&gt;Grunt 는 Configuration 기반의 태스크 러너였다면, 반대로 Gulp 는 코드 기반의 태스크 러너 이다. Gulp 는 Grunt 처럼 태스크를 실행하기 위한 중간 파일을 만들지 않고 NodeJS streams 을 사용하여 복잡한 파이프라인 형태로 실행된다(무슨 말이지는 잘 모르겠지만, 예제를 보면 알겠지).&lt;/p&gt;
&lt;p&gt;일단 global 로 설치하자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;npm install -g gulp&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Grunt 예제와 비슷하게 동작하는 예제를 실행하기 위해 다음과 같은 plugins 을 설치한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;npm install
	gulp-jshint jshint-stylish
	gulp-imagemin gulp-concat gulp-uglify gulp-minify-css gulp-usemin
	gulp-cache gulp-rev gulp-rename gulp-notify
	browser-sync del
--save-dev&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;플러그인을 로드하는 방법은 다음과 같다.
직접 각 플러그인을 로드해도 되지만, package.json 파일 형태로 저장할 수도 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var gulp = require(&amp;#39;gulp&amp;#39;),
  jshint = require(&amp;#39;gulp-jshint&amp;#39;)
  sylish = require(&amp;#39;jshint-stylish&amp;#39;)

  ...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Gulp Streams&lt;/h4&gt;
&lt;p&gt;Gulp Streams 는 nodeJS streams 를 사용하여 파이프라인을 구성하는데, 파이프 라인이란 하나의 function 의 결과가 다음 function 으로 그대로 전달되는 연쇄적인 명령셋을 말한다. 예제를 살펴보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;gulp.task(&amp;#39;jshint&amp;#39;, function() {
	gulp.src(&amp;#39;app/scripts/**/*.js&amp;#39;)
	.pipe(jshint())
	.pipe(jshint.reporter(stylish));
});&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;우선 걸프 태스크를 생성하고 그 안에서 소스를 선택하고 jshint 를 생성하고 스타일을 적용해주는 일련의 명령들을 pipe 라는 function 을 이용하여 연결하였다.&lt;/p&gt;
&lt;p&gt;Watch 태스크 예제를 살펴보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;gulp.task(&amp;#39;watch&amp;#39;, [&amp;#39;browser-sync&amp;#39;], function() {
	gulp.watch(&amp;#39;{app/scripts/**/*.js, app/style/**/*.css, app/**/*.html}&amp;#39;, [&amp;#39;usemin&amp;#39;]);
	gulp.watch(&amp;#39;app/images/**/*&amp;#39;, [&amp;#39;imagemin&amp;#39;]);
});&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;태스크의 두번째 인자를 보면, browser-sync 가 대괄호로 묶여져 있다. 이 의미는 browser-sync 는 watch 태스크에 종속적이라는 말이다. 즉, watch 태스크가 실행되면 자동으로 browser-sync 가 실행된다.&lt;/p&gt;
&lt;h4&gt;Default Task&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;gulp.task(&amp;#39;default&amp;#39;, [&amp;#39;clean&amp;#39;], function() {
	gulp.start(&amp;#39;usemin&amp;#39;, &amp;#39;imagemin&amp;#39;, &amp;#39;copyfonts&amp;#39;);
});&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;default 태스크는 콘솔창에서 gulp 라고 입력하면 실행되는 태스크이다. clean 태스크가 연쇄적으로 발생하게 되고, 내부에서는 서로 dependency 가 없는 usemin, imagemin, copyfonts 가 동시에 실행된다.&lt;/p&gt;
&lt;h4&gt;gulpfile.js&lt;/h4&gt;
&lt;p&gt;콤마(,)와 띄어쓰기에 유의해야 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var gulp = require(&amp;#39;gulp&amp;#39;),
	minifycss = require(&amp;#39;gulp-minify-css&amp;#39;),
	jshint = require(&amp;#39;gulp-jshint&amp;#39;),
	stylish = require(&amp;#39;jshint-stylish&amp;#39;),
	uglify = require(&amp;#39;gulp-uglify&amp;#39;),
	usemin = require(&amp;#39;gulp-usemin&amp;#39;),
	imagemin = require(&amp;#39;gulp-imagemin&amp;#39;),
	rename = require(&amp;#39;gulp-rename&amp;#39;),
	concat = require(&amp;#39;gulp-concat&amp;#39;),
	notify = require(&amp;#39;gulp-notify&amp;#39;),
	cache = require(&amp;#39;gulp-cache&amp;#39;),
	changed = require(&amp;#39;gulp-changed&amp;#39;),
	rev = require(&amp;#39;gulp-rev&amp;#39;),
	browserSync = require(&amp;#39;browser-sync&amp;#39;),
	del = require(&amp;#39;del&amp;#39;);

gulp.task(&amp;#39;jshint&amp;#39;, function() {
	return gulp.src(&amp;#39;app/scripts/**/*.js&amp;#39;)
		.pipe(jshint())
		.pipe(jshint.reporter(stylish));
});

gulp.task(&amp;#39;usemin&amp;#39;, [&amp;#39;jshint&amp;#39;], function() {
	return gulp.src(&amp;#39;./app/menu.html&amp;#39;)
		.pipe(usemin({
			css:[minifycss(),rev()],
			js: [uglify(),rev()]
		}))
		.pipe(gulp.dest(&amp;#39;dist/&amp;#39;));
});

gulp.task(&amp;#39;imagemin&amp;#39;, function() {
	return del([&amp;#39;dist/images&amp;#39;]), gulp.src(&amp;#39;app/images/**/*&amp;#39;)
		.pipe(cache(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true })))
		.pipe(gulp.dest(&amp;#39;dist/images&amp;#39;))
		.pipe(notify({ message: &amp;#39;Images task complete&amp;#39; }));
});

gulp.task(&amp;#39;clean&amp;#39;, function() {
	return del([&amp;#39;dist&amp;#39;])
});

gulp.task(&amp;#39;copyfonts&amp;#39;, [&amp;#39;clean&amp;#39;], function() {
	gulp.src(&amp;#39;./bower_components/font-awesome/fonts/**/*.{ttf,woff,eof,svg}*&amp;#39;)
		.pipe(gulp.dest(&amp;#39;./dist/fonts&amp;#39;));
	gulp.src(&amp;#39;./bower_components/bootstrap/dist/fonts/**/*.{ttf,woff,eof,svg}*&amp;#39;)
		.pipe(gulp.dest(&amp;#39;./dist/fonts&amp;#39;));
});

gulp.task(&amp;#39;watch&amp;#39;, [&amp;#39;browser-sync&amp;#39;], function() {
	gulp.watch(&amp;#39;{app/scripts/**/*.js,app/styles/**/*.css,app/**/*.html}&amp;#39;, [&amp;#39;usemin&amp;#39;]);
	gulp.watch(&amp;#39;app/images/**/*&amp;#39;, [&amp;#39;imagemin&amp;#39;]);
});

gulp.task(&amp;#39;browser-sync&amp;#39;, [&amp;#39;default&amp;#39;], function() {
	var files = [
		&amp;#39;app/**/*.html&amp;#39;,
		&amp;#39;app/styles/**/*.css&amp;#39;,
		&amp;#39;app/images/**/*.png&amp;#39;,
		&amp;#39;app/scripts/**/*.js&amp;#39;,
		&amp;#39;dist/**/*&amp;#39;
	];

	browserSync.init(files, {
		server: {
			baseDir: &amp;quot;dist&amp;quot;,
			index: &amp;quot;menu.html&amp;quot;
		}
	});

	gulp.watch([&amp;#39;dist/**&amp;#39;]).on(&amp;#39;change&amp;#39;, browserSync.reload);
});

gulp.task(&amp;#39;default&amp;#39;, [&amp;#39;clean&amp;#39;], function() {
	gulp.start(&amp;#39;usemin&amp;#39;, &amp;#39;imagemin&amp;#39;, &amp;#39;copyfonts&amp;#39;);
});&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[[coursera] AngularJS week 1]]></title><description><![CDATA[Full-Stack Web Development: The Big Picture Three Tier Architecture 보통 웹개발에서 말하는 3-티어 아키텍쳐는 아래의 세 영역으로 나뉜다. Presentaion Layer : HTML, CSS…]]></description><link>https://blueshw.github.io/2016/08/18/frontend-javascript-framework-angularjs-week1/</link><guid isPermaLink="false">https://blueshw.github.io/2016/08/18/frontend-javascript-framework-angularjs-week1/</guid><pubDate>Thu, 18 Aug 2016 23:10:50 GMT</pubDate><content:encoded>&lt;h2&gt;Full-Stack Web Development: The Big Picture&lt;/h2&gt;
&lt;h3&gt;Three Tier Architecture&lt;/h3&gt;
&lt;p&gt;보통 웹개발에서 말하는 3-티어 아키텍쳐는 아래의 세 영역으로 나뉜다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Presentaion Layer : HTML, CSS, JS&lt;/li&gt;
&lt;li&gt;Business Layer : Ruby, Python, Java, C++&lt;/li&gt;
&lt;li&gt;Data Access Layer : DBMS&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;반면에 Full-Stack 웹 개발은 자바스크립트를 이용하여 위의 세 layer 의 개발을 가능하도록 하는 방법을 말하며, 조금씩 다른 프레임웍을 사용할 수 있겠지만, 이 강의에서는 presentaion layer 에는 자바스크립트 프레임웍인 AngularJS, business layer 에서는 NodeJS, 그리고 Data Access Layer 영역에서는 자바스크립트를 이용한 MongoDB 를 사용하여 개발한다.&lt;/p&gt;
&lt;p&gt;이 세 영역은 모두 자바스크리트 기반으로 만들어져 있기 때문에 서버, 브라우저, 모바일 디바이스 등 모든 영역에서 JSON 형태로 통신이 가능하다.&lt;/p&gt;
&lt;h3&gt;Course Overview&lt;/h3&gt;
&lt;p&gt;이번 강의에서 다루는 주제는 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AngularJS : 자바스크립트 프레임워크 (버전: 1.4.2)&lt;/li&gt;
&lt;li&gt;Web Tools : Grunt, Gulp, Yo and Yeoman&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Introduction to AngularJS&lt;/h2&gt;
&lt;h3&gt;Front-End JavaScript Frameworks OverView&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;소프트웨어 라이브러리란 어떤 동작을 실행하는 잘 정의된 인터페이스(or functions or methods)의 집합이라 할 수 있다. 재사용성과 모듈화를 통해서 더 효율적인 개발이 가능하다. 대표적인 예로 jQuery 가 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;소프트웨어 프레임워크란 라이브러리와는 다소 차이가 있다. 라이브러리는 이미 잘 만들어진 유용한 코드(functions)를 사용한다고 한다면, 프레임워크는 개발자가 작성한 코드가 프레임워크안에서 적절하게 실행할 수 있도록 환경을 제공하는 것이라 할 수 있다. 프레임워크는 일반적인(generic) 함수 셋을 제공하며 개발자가 구체적인 코드를 구현해야한다. 그리고 구현된 코드는 프레임워크가 필요한 경우, 어떤 임무를 완수하기 위해 불려진다. 즉, 라이브러리는 개발자에게 코드를 컨트롤 할 수 있는 권한이 주어지는 반면 프레임워크는 코드의 컨트롤 권한이 프레임워크에게 있는 것과 같다. 이번 강의에서 배울 AngularJS 나 durandal, backbone 등이 대표적이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;10 가지 Javascript Framework&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Angular : one of the three Major JS framework&lt;/li&gt;
&lt;li&gt;Ember : one of the three Major JS framework&lt;/li&gt;
&lt;li&gt;Backbone : one of the three Major JS framework&lt;/li&gt;
&lt;li&gt;React : 프레임웍이라기 보다 라이브러리에 가까움&lt;/li&gt;
&lt;li&gt;Aurelia&lt;/li&gt;
&lt;li&gt;Meteor : 요즘 각광받기 시작&lt;/li&gt;
&lt;li&gt;Polymer&lt;/li&gt;
&lt;li&gt;Knockout&lt;/li&gt;
&lt;li&gt;Vue&lt;/li&gt;
&lt;li&gt;Mercury&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;3 가지 메이저 JS Frameworks 비교 (3 &gt; 2 &gt; 1)&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;Ember&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;Angular&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;Backbone&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Opinionated&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Ease of Use&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;3&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Learning Curve&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Popularity&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;-&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;3&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;Introduction to AngularJS&lt;/h3&gt;
&lt;p&gt;HTML 은 static 한 문서이기 때문에 동적인 웹 어플리케이션을 지원하기에는 HTML 만으로는 한계가 있다. 보통은 자바스크립트의 DOM 객체를 이용해서 HTML 을 동적으로 만들 수 있지만, 자바스크립트 프레임웍인 Angular 를 이용하면 다음과 같은 이점을 가질 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Solving the impedance mismatch&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;back end 데이터와 static content 를 출력하는데 HTML 만으로는 한계가 있기 때문에 이 문제(impedance mismatch)를 해결이 가능하도록 해준다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Designed with CRUD applications (data-driven) in mind&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;데이터가 변경되면 변경된 데이터에 맞춰서 동적으로 HTML 이 update 된다. Create, Read, Update, Delete 이 네 가지를 이르는 CRUD 에 대해서는 다음 모듈에서 자세하게 다루기로 한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Declarative approach&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Angular 는 선언적인 개발방법을 지원하는데, 이는 개발자가 원하는 것을 기술하면 Angluar 가 그에 맞게 처리해내는 것을 뜻한다(무슨 말인지 잘…)&lt;/p&gt;
&lt;h4&gt;Angular Vocabulary&lt;/h4&gt;
&lt;p&gt;앞으로 배울 Angular 의 문법은 아래와 같은 것들이 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Two-way Data Binding&lt;/li&gt;
&lt;li&gt;Scope&lt;/li&gt;
&lt;li&gt;Directives&lt;/li&gt;
&lt;li&gt;Templates&lt;/li&gt;
&lt;li&gt;Routing&lt;/li&gt;
&lt;li&gt;Testing&lt;/li&gt;
&lt;li&gt;Modules&lt;/li&gt;
&lt;li&gt;Controllers&lt;/li&gt;
&lt;li&gt;Filters&lt;/li&gt;
&lt;li&gt;Factory&lt;/li&gt;
&lt;li&gt;Service&lt;/li&gt;
&lt;li&gt;Provider&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;우선은 Two-way Data Binding 과 Directives 에 대해서 먼저 알아보자&lt;/p&gt;
&lt;h4&gt;Directives&lt;/h4&gt;
&lt;p&gt;Angular Directives 는 ng-_ or data-ng-_ 로 시작하는 HTML 속성이다. 다음의 몇가지 예를 살펴보자&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ng-app : Angular 앱을 시작과 끝을 나타낸다. 어떠한 태그에도 붙일 수 있다. 즉, 하나의 HTML 파일에 하나 이상의 Angular 앱이 존재할 수도 있다는 말과 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ng-init : 자바스크립트 변수를 선언하는것과 같다. Angular expression 을 Evaluation 한다(좀더 매끄러운 한글 표현이 필요할 것 같다). object, array 도 사용가능하다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;p ng-init=&amp;quot;index=1&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;div ng-init=&amp;quot;dish={name:&amp;#39;example&amp;#39;, ...}&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;ng-model : input value 를 변수로 바인드 한다. (Two-way data binding) ng-model 속성을 부여하면 언제든지 어떤 변수든지 변경이 가능하게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;p&amp;gt;Comment: {{dish.comment}}&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;Type your comment:
	&amp;lt;input type=&amp;quot;text&amp;quot; ng-model=&amp;quot;dish.comment&amp;quot; /&amp;gt;
&amp;lt;/p&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;dish object 의 comment 는 위에서 이미 정의를 한 상태다. 이때 아래의 input tag 에서 ng-model 속성을 부여하고 이미 정의된 dish.comment 를 입력하면 Two-way data binding 에 의해 처음 설정된 값이 input 태그의 변경되는 값으로 동적으로 변경된다.&lt;/p&gt;
&lt;p&gt;양 방향에서 바인딩이 가능하기 때문에 아마도 Two-way data binding 이라고 부르는 것 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ng-repeat : 반복적인 태그를 작성할 필요가 있을때 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Angular Expressions&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Evaluated against an Angular scope object
Angular 스코프에 맞게 value 가 평가된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;No conditionals, loops, or exceptions
위의 사항들은 expression 으로 사용이 불가하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Expressions enclosed in {{ expression }}
중괄호 두개를 겹쳐서 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;p&amp;gt;6 + 5 = {{ 6 + 5 }}&amp;lt;/p&amp;gt;
&amp;lt;h2&amp;gt;{{ dish.name }}&amp;lt;/h2&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Models, Views and Controllers&lt;/h2&gt;
&lt;h3&gt;The Model View Controller Framework&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Design pattern is ell-documented solution to a recurring problem&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;디자인 패턴은 비슷하고 반복되는 문제를 매번 똑같이 구현하는 것이 아니라 재사용 가능하도록 만들어진 일종의 솔루션을 말한다.&lt;/p&gt;
&lt;h4&gt;MVC&lt;/h4&gt;
&lt;p&gt;MVC 는 소프트웨어 엔지니어링 구조에서 가장 대표적인 디자인 패턴이다. M(Model), V(View), C(Controller) 세가지 영역으로 나누어져있고, 각 영역은 독립적으로 존재한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Model : 애플리케이션에서 도메인의 상태나 도메인 로직을 구현하는 영역이다. 여기서 말하는 도메인은 일반 개발 영역에서 말하는 것과 마찬가지로 소프트웨어가 다루는 특정 활동이나 지식의 범주를 뜻한다(표현이 조금 어렵다). 웹 어플리케이션단에서 보면 model 은 request 요청에 대한 상태 변화에 반응하여 특정 도메인의 행위나 상태를 관리한다고 볼 수 있다. 그리고 대게 모델의 변화는 컨트롤러에 의해 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;View : 사용자에게 보여지는 영역이다. view 는 유저와 상호작용을 위해 form 에 모델정보를 redering 한다. 하나의 model 로 서로 다른 목적의 뷰를 만들수도 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Controller : View 와 모델 사이를 중재하는 역할을 한다. 일반적으로 컨트롤러는 유저의 input 을 받아서 모델의 상태변화를 만들어낸다. 그렇기 때문에 컨트롤러는 결과적으로 모델의 변화를 이끌어 낸다고 할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;MVVM (Model View View-Model)&lt;/h4&gt;
&lt;p&gt;MVC 패턴의 파생된 형태중 하나인 MVVM 은 Model, View, View-Model 로 구성된다. 컨트롤러에 들어갈 비즈니스 로직이 모델이 있으며 View-Model 과 View 사이에서 데이터 바인딩이 이루어진다.&lt;/p&gt;
&lt;h3&gt;Angular Modules and Controllers&lt;/h3&gt;
&lt;p&gt;일반적으로 Angular 도 MVC 패턴을 따르고 있다고 할 수 있지만, 어떤 사람들은 Angular 가 MVVM 이 적합하다고도 한다. 또한 많은 사람들은 모델(M)과 뷰(V), 그리고 그 사이는 무엇이든 상관없다는 MVW(model-view-whatever)로 간단히 부르기도 한다.&lt;/p&gt;
&lt;h4&gt;Angular Modules&lt;/h4&gt;
&lt;p&gt;Angular Modules 은 다음처럼 스크립트 태그안에 정의한다. angular.module 메서드는 두개의 파라미터를 가지는데, 첫번째는 ngApp 속성에 정의된 이름이고 두번째는 array 인데 나중에 설명할 것이다. 아래같은 경우 ngApp 이 html 태그에 선언되어 있으므로 아래의 모듈에서 현재 페이지 모두를 관리 할 수 있게 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;html ngApp=&amp;quot;confusionApp&amp;quot;&amp;gt;

...

&amp;lt;body&amp;gt;

...

	&amp;lt;script&amp;gt;
		var app = angular.module(&amp;#39;confusionApp&amp;#39;,[]);
	&amp;lt;/script&amp;gt;

&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Angular Controller&lt;/h4&gt;
&lt;p&gt;Angular 컨트롤러는 특정 태그의 ng-controller 속성으로 선언된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;div class=&amp;quot;row row-content&amp;quot; ng-controller=&amp;quot;menuController as menuCtrl&amp;quot;&amp;gt;

&amp;lt;/div&amp;gt;

&amp;lt;script&amp;gt;
var app = angular.module(&amp;#39;confusionApp&amp;#39;, []);

app.controller(&amp;#39;menuController&amp;#39;, function() {
	var dishes = [item, ... ];
	this.dishes = dishes;
});

&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;모듈과 컨트롤러는 위와 같이 구현할 수 있다. 이전에 보았던 ng-init directive 는 HTML 속성으로 직접 넣어줘야하지만, 컨트롤러를 사용하면 해당 태그(여기서는 div) 내부의 데이터를 자바스크립트 코드로 컨트롤할 수 있게 된다. 컨트롤러의 두번째 파라미터인 익명함수 마지막에 &lt;strong&gt;this.dishes = dishes&lt;/strong&gt; 부분은 아마도 div 태그 내에서 사용가능한 dishes 를 정의해주기 위해 자바스크립트 오브젝트인 dishes 를 this.dishes 에 할당해준게 아닌가 생각된다.&lt;/p&gt;
&lt;h2&gt;Angular Filters&lt;/h2&gt;
&lt;p&gt;필터는 서버사이드 또는 클라이언트에서 만들어진 data 를 end user 에게 잘 표현하기 위한 수단으로 사용된다. 필터는 기반 데이터를 바꿀 수는 없으며 view templates, controllers, services 등에서 사용된다. AngularJS 는 기본적으로 빌트인 필터를 여러개 제공하고 있고, 개발자 필요에 따라 커스텀 필터를 만들어 사용할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;div class=&amp;quot;media-body&amp;quot;&amp;gt;
	&amp;lt;h2 class=&amp;quot;media-headgin&amp;quot;&amp;gt;{{dish.name}}
		&amp;lt;span class=&amp;quot;label label-danger label-xs&amp;quot;&amp;gt;{{dish.label}}&amp;lt;/span&amp;gt;
		&amp;lt;!-- currency 필터는 price에 $를 붙여준다.--&amp;gt;
		&amp;lt;span class=&amp;quot;badge&amp;quot;&amp;gt;{{dish.price | currency}}&amp;lt;/span&amp;gt;
	&amp;lt;/h2&amp;gt;
	&amp;lt;p&amp;gt;{{dish.description}}&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Angluar 의 Built-in Filters&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;uppercase / lowercase : converts the text&lt;/li&gt;
&lt;li&gt;currency : $를 붙여준다.&lt;/li&gt;
&lt;li&gt;date : 날짜 포맷을 변경한다.&lt;/li&gt;
&lt;li&gt;filter : 특정 조건에 맞게 array 의 서브셋을 리턴한다.&lt;/li&gt;
&lt;li&gt;orderBy : 조건에 맞게 정렬한다.&lt;/li&gt;
&lt;li&gt;json, limitTo 등도 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;!-- filter 예제, HTML 코드 --&amp;gt;
&amp;lt;li class=&amp;quot;media&amp;quot; ng-repeat=&amp;quot;dish in menuCtrl.dishes | filter:menuCtrl.filtText&amp;quot;&amp;gt;...&amp;lt;/li&amp;gt;

&amp;lt;!-- javascript 코드 --&amp;gt;
var filtText = &amp;quot;&amp;quot;;

this.select = function(setTab) {
	this.tab = setTab;
	if (setTab === 2)
		this.filtText = &amp;quot;appetizer&amp;quot;
	else if (setTab === 3)
		this.filtText = &amp;quot;mains&amp;quot;
	else if (setTab === 4)
		this.filtText = &amp;quot;dessert&amp;quot;
	else
		this.filtText = &amp;quot;&amp;quot;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위와 같이 HTML 과 javascript 코드를 작성한다.
그리고 특정 탭을 만들어 각 탭에 번호를 부여한다(setTab).
그럼 각 탭 을 눌렀을때 filtText 가 특정 문자열로 변경된다.
미리 적용해놓은 filter 에 따라서 각 li 태그가 보여지기도 하고 가려지기도 할 것이다.&lt;/p&gt;
&lt;h2&gt;Excercise Code&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot; ng-app=&amp;quot;confusionApp&amp;quot;&amp;gt;

&amp;lt;head&amp;gt;
     &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
    &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;IE=edge&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1&amp;quot;&amp;gt;
    &amp;lt;!-- The above 3 meta tags *must* come first in the head; any other head
         content must come *after* these tags --&amp;gt;
    &amp;lt;title&amp;gt;Ristorante Con Fusion: Menu&amp;lt;/title&amp;gt;
        &amp;lt;!-- Bootstrap --&amp;gt;
    &amp;lt;link href=&amp;quot;../bower_components/bootstrap/dist/css/bootstrap.min.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt;
    &amp;lt;link href=&amp;quot;../bower_components/bootstrap/dist/css/bootstrap-theme.min.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt;
    &amp;lt;link href=&amp;quot;../bower_components/font-awesome/css/font-awesome.min.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt;
    &amp;lt;link href=&amp;quot;styles/bootstrap-social.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt;
    &amp;lt;link href=&amp;quot;styles/mystyles.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt;

    &amp;lt;!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries --&amp;gt;
    &amp;lt;!-- WARNING: Respond.js doesn&amp;#39;t work if you view the page via file:// --&amp;gt;
    &amp;lt;!--[if lt IE 9]&amp;gt;
      &amp;lt;script src=&amp;quot;https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
      &amp;lt;script src=&amp;quot;https://oss.maxcdn.com/respond/1.4.2/respond.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;![endif]--&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;

    &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;row row-content&amp;quot; ng-controller=&amp;quot;menuController as menuCtrl&amp;quot;&amp;gt;
            &amp;lt;div class=&amp;quot;col-xs-12&amp;quot;&amp;gt;
                &amp;lt;ul class=&amp;quot;nav nav-tabs&amp;quot; role=&amp;quot;tablist&amp;quot;&amp;gt;
                    &amp;lt;li role=&amp;quot;presentation&amp;quot; ng-class=&amp;quot;{active:menuCtrl.isSelected(1)}&amp;quot;&amp;gt;
                        &amp;lt;a ng-click=&amp;quot;menuCtrl.select(1)&amp;quot; aria-controls=&amp;quot;all menu&amp;quot; role=&amp;quot;tab&amp;quot;&amp;gt;The Menu&amp;lt;/a&amp;gt;
                    &amp;lt;/li&amp;gt;
                    &amp;lt;li role=&amp;quot;presentation&amp;quot; ng-class=&amp;quot;{active:menuCtrl.isSelected(2)}&amp;quot;&amp;gt;
                        &amp;lt;a ng-click=&amp;quot;menuCtrl.select(2)&amp;quot; aria-controls=&amp;quot;appetizers&amp;quot; role=&amp;quot;tab&amp;quot;&amp;gt;Appetizers&amp;lt;/a&amp;gt;
                    &amp;lt;/li&amp;gt;
                    &amp;lt;li role=&amp;quot;presentation&amp;quot; ng-class=&amp;quot;{active:menuCtrl.isSelected(3)}&amp;quot;&amp;gt;
                        &amp;lt;a ng-click=&amp;quot;menuCtrl.select(3)&amp;quot; aria-controls=&amp;quot;mains&amp;quot; role=&amp;quot;tab&amp;quot;&amp;gt;Mains&amp;lt;/a&amp;gt;
                    &amp;lt;/li&amp;gt;
                    &amp;lt;li role=&amp;quot;presentation&amp;quot; ng-class=&amp;quot;{active:menuCtrl.isSelected(4)}&amp;quot;&amp;gt;
                        &amp;lt;a ng-click=&amp;quot;menuCtrl.select(4)&amp;quot; aria-controls=&amp;quot;desserts&amp;quot; role=&amp;quot;tab&amp;quot;&amp;gt;Desserts&amp;lt;/a&amp;gt;
                    &amp;lt;/li&amp;gt;
                &amp;lt;/ul&amp;gt;
                &amp;lt;div class=&amp;quot;tab-content&amp;quot;&amp;gt;
                    &amp;lt;ul class=&amp;quot;media-list tab-pane fade in active&amp;quot;&amp;gt;
                        &amp;lt;li class=&amp;quot;media&amp;quot; ng-repeat=&amp;quot;dish in menuCtrl.dishes | filter:menuCtrl.filtText&amp;quot;&amp;gt;
                            &amp;lt;div class=&amp;quot;media-left media-middle&amp;quot;&amp;gt;
                                &amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;
                                &amp;lt;img class=&amp;quot;media-object img-thumbnail&amp;quot; ng-src=&amp;quot;{{dish.image}}&amp;quot; alt=&amp;quot;Uthapizza&amp;quot;&amp;gt;
                                &amp;lt;/a&amp;gt;
                            &amp;lt;/div&amp;gt;
                            &amp;lt;div class=&amp;quot;media-body&amp;quot;&amp;gt;
                                &amp;lt;h2 class=&amp;quot;media-heading&amp;quot;&amp;gt;{{dish.name}}
                                    &amp;lt;span class=&amp;quot;label label-danger&amp;quot;&amp;gt;{{dish.label}}&amp;lt;/span&amp;gt;
                                    &amp;lt;span class=&amp;quot;badge&amp;quot;&amp;gt;{{dish.price | currency}}&amp;lt;/span&amp;gt;
                                &amp;lt;/h2&amp;gt;
                                &amp;lt;p&amp;gt;{{dish.description}}&amp;lt;/p&amp;gt;
                                &amp;lt;!-- &amp;lt;p&amp;gt;Comment: {{dish.comment}}&amp;lt;/p&amp;gt; --&amp;gt;
                                &amp;lt;!-- &amp;lt;p&amp;gt;Type your comment: --&amp;gt;
                                    &amp;lt;!-- &amp;lt;input type=&amp;quot;text&amp;quot; ng-model=&amp;quot;dish.comment&amp;quot;&amp;gt; --&amp;gt;
                                &amp;lt;/p&amp;gt;
                            &amp;lt;/div&amp;gt;
                        &amp;lt;/li&amp;gt;
                    &amp;lt;/ul&amp;gt;
                &amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;script src=&amp;quot;../bower_components/angular/angular.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script&amp;gt;
        var app = angular.module(&amp;#39;confusionApp&amp;#39;, []);
        app.controller(&amp;#39;menuController&amp;#39;, function(){

            this.tab = 1;
            this.filtText = &amp;#39;&amp;#39;;

            var dished = [
                              {
                                name: &amp;#39;Uthapizza&amp;#39;,
                                image: &amp;#39;images/uthapizza.png&amp;#39;,
                                category: &amp;#39;mains&amp;#39;,
                                label: &amp;#39;Hot&amp;#39;,
                                price: &amp;#39;4.99&amp;#39;,
                                description:&amp;#39;A unique combination of Indizan Uthappam (pancake) and Italian pizza, topped with Cerignola olives, ripe vine cherry tomatoes, Vidalia onion, Guntur chillies and Buffalo Paneer&amp;#39;,
                                comment: &amp;#39;aaaaaaa&amp;#39;
                              },
                              {
                                name: &amp;#39;Uthapizza2&amp;#39;,
                                image: &amp;#39;images/zucchipakoda.png&amp;#39;,
                                category: &amp;#39;mains&amp;#39;,
                                label: &amp;#39;&amp;#39;,
                                price: &amp;#39;4.99&amp;#39;,
                                description:&amp;#39;A unique combination of Indizan Uthappam (pancake) and Italian pizza, topped with Cerignola olives, ripe vine cherry tomatoes, Vidalia onion, Guntur chillies and Buffalo Paneer&amp;#39;,
                                comment: &amp;#39;&amp;#39;
                              },
                              {
                                name: &amp;#39;Uthapizza3&amp;#39;,
                                image: &amp;#39;images/vadonut.png&amp;#39;,
                                category: &amp;#39;appetizer&amp;#39;,
                                label: &amp;#39;New&amp;#39;,
                                price: &amp;#39;4.99&amp;#39;,
                                description:&amp;#39;A unique combination of Indizan Uthappam (pancake) and Italian pizza, topped with Cerignola olives, ripe vine cherry tomatoes, Vidalia onion, Guntur chillies and Buffalo Paneer&amp;#39;,
                                comment: &amp;#39;&amp;#39;
                              },
                              {
                                name: &amp;#39;Uthapizza4&amp;#39;,
                                image: &amp;#39;images/elaicheesecake.png&amp;#39;,
                                category: &amp;#39;dessert&amp;#39;,
                                label: &amp;#39;&amp;#39;,
                                price: &amp;#39;4.99&amp;#39;,
                                description:&amp;#39;A unique combination of Indizan Uthappam (pancake) and Italian pizza, topped with Cerignola olives, ripe vine cherry tomatoes, Vidalia onion, Guntur chillies and Buffalo Paneer&amp;#39;,
                                comment: &amp;#39;&amp;#39;
                              },
                            ];
            this.dishes = dished;

            this.select = function(setTab) {
                this.tab = setTab;

                if (setTab === 2)
                    this.filtText = &amp;quot;appetizer&amp;quot;;
                else if (setTab === 3)
                    this.filtText = &amp;quot;mains&amp;quot;
                else if (setTab === 4)
                    this.filtText = &amp;quot;dessert&amp;quot;
                else
                    this.filtText = &amp;quot;&amp;quot;;
            }

            this.isSelected = function(checkTab) {
                return (this.tab === checkTab)
            }
        });
    &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[Functional Programming in Scala week 6]]></title><description><![CDATA[6.1 Other Collections 이제껏 리스트에 대해서 알아보았다. 이번 챕터에서는 리스트 외에도 스칼라의 기본적인 컬렉션(Seq, Set, Map)에 대해 알아보도록 하자. Vector 리스트의 경우에는 첫번째 element…]]></description><link>https://blueshw.github.io/2016/07/26/functional-programming-in-scala-week6/</link><guid isPermaLink="false">https://blueshw.github.io/2016/07/26/functional-programming-in-scala-week6/</guid><pubDate>Tue, 26 Jul 2016 23:29:50 GMT</pubDate><content:encoded>&lt;h2&gt;6.1 Other Collections&lt;/h2&gt;
&lt;p&gt;이제껏 리스트에 대해서 알아보았다. 이번 챕터에서는 리스트 외에도 스칼라의 기본적인 컬렉션(Seq, Set, Map)에 대해 알아보도록 하자.&lt;/p&gt;
&lt;h3&gt;Vector&lt;/h3&gt;
&lt;p&gt;리스트의 경우에는 첫번째 element 에 접근하는게 마지막 element 에 접근하는 것보다 훨씬 빠르다. 리스트의 구조가 트리 형태로 구성되어 있고 우측으로 갈수록 트리의 깊이가 깊어지기 때문에 그렇다. 이에 반해 Vector 는 리스트 보다 access pattern 이 훨씬 균형잡혀 있다.&lt;/p&gt;
&lt;p&gt;벡터는 최초에 2^5(32 개)의 원소를 가지는 array 가 만들어 진다. 32 개가 넘는 원소가 필요하게 되면, 그다음은 32 개를 추가로 만드는 것이 아니라, 2^5 * 2^5 개, 그러니깐 총 2^10(1024 개)의 원소가 들어갈 수 있는 리스트가 추가로 만들어 지는 것이다. 왜 이런식으로 커질까? 원소가 32 개보다 커지면, 처음 만들어진 32 개짜리 벡터는 각각의 32 개짜리 원소를 가지는 벡터의 포인터가 되고 그 아래로 각각 벡터가 만들어진다. 즉, 처음 32 개짜리 원소에서 1024 개를 담을 수 있는 벡터로 바뀌게 된다. 그렇기 때문에 어떤 값을 찾는데 log32(N) 시간만 소요된다. 리스트보다 훨 낫다.&lt;/p&gt;
&lt;p&gt;또 다른 장점으로는 map, for, filter, fold 와 같은 연산(bulk operations)이 빠르다는 것이다. 왜냐하면 벡터는 리스트와 달리 원소가 32 개가 하나의 묶음이다보니 a single cache line 에 위치하기 때문에 접근이 훨씬 빠를것이기 때문이다. 즉 list 는 vector 에 비해서 locality 가 나쁘다고 할 수 있다.&lt;/p&gt;
&lt;p&gt;vector 가 이렇게 좋다는데, list 를 써야하는 이유는 무엇일까? recursive data structure 의 head 를 취하고 나머지를 다시 연산하는 모델 안에서는 list 가 훨씬 쉽다. 왜냐하면 한 노드에 하나의 아이템만 존재하기 때문에 head 를 취하기가 훨씬 쉽기 때문이다. 하지만 vector 의 경우 depth 가 1 일때는 몰라도 depth 가 1 만 더 증가해도 훨씬 복잡해진다.&lt;/p&gt;
&lt;p&gt;list 의 concat 연산 (::)은 vector 에서 다음과 같이 쓰인다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;x +: xs     // xs 앞에 x를 포함하는 새로운 벡터를 붙인다.
xs :+ x     // xs 뒤에 x를 포함하는 새로운 벡터를 붙인다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;벡터 또한 immutable 하기 때문에 위의 연산을 처리하기 위해서는 기존의 벡터를 새롭게 만들어지는 벡터와 함께 새로운 포인터에 연결해야한다. root 까지 새로운 포인터로 연결이 되고 나면 연산이 완료된다.&lt;/p&gt;
&lt;h3&gt;Collection Hierachy&lt;/h3&gt;
&lt;p&gt;스칼라의 collection 은 크게 세가지로 나뉘는데, 하나는 지금껏 살펴봤던 List 와 Vector 가 속하는 Seq, 나머지는 Set 과 Map 이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://docs.scala-lang.org/resources/images/collections.immutable.png&quot; alt=&quot;Collectino Hierachy&quot;&gt;&lt;/p&gt;
&lt;p&gt;Array 와 String 는 점선으로 되어있는데, 이들도 Seq 로써 아래와 같이 똑같이 동작한다. 다만 자바에서 가져온 타입이기 때문에 앞으로 어떻게 될지(Scala.sequence.String 같은걸 누군가 만들지도 모르므로..) 몰라 점선으로 연결해놓은거 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// Array
val xs = Array(1, 2, 3, 44)
xs map (x =&amp;gt; x * 2)
// res0 : Array[Int] = Array(2, 4, 6, 88)

// String
val s = &amp;quot;Hello World&amp;quot;
s filter (c =&amp;gt; c.isUpper)
// res1: String = HW&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Range&lt;/h3&gt;
&lt;p&gt;Range 는 심플한 seq 타입이다. 사용법 또한 매우 간단하다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;val r: Range = 1 until 5    // 1, 2, 3, 4
val s: Range = 1 to 5     // 1, 2, 3, 4, 5
1 to 10 by 3          // 1, 4, 7, 10
6 to 1 by -2          // 6, 4, 2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Some more Sequence Operations&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;xs exists p : p 함수의 조건을 만족하는 원소가 있는지&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;xs forall p : 모든 원소가 p 함수의 조건을 만족하는지&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;xs zip ys : 두 collection 의 원소를 pair 로 가지는 새로운 collection 생성, 타입은 xs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;xs.unzip : zip 형태의 collection 을 분해해서 List 의 tuples 을 만듦, Array 는 안되는군각 요소(xy: pair)의 첫번째와 두번째 요소를 곱한다음 모든값을 sum 해준다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;xs.flatMap f : 모든 element 에 collection-valued functino f 를 적용&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;xs.sum : numeric collection 의 요소들의 합&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;xs.product : numeric collection 의 요소들의 곱&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;xs.max : 최고값&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;xs.min : 최소값&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Scalar Product&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;val a: Vector[Double] = Vector(1.0, 2.0, 3.0)
val b: Vector[Double] = Vector(3.0, 4.0, 5.0)

def scalarProduct(xs: Vector[Double], ys: Vector[Double]): Double =
  (xs zip ys).map(xy =&amp;gt; xy._1 * xy._2).sum

scalarProduct(a, b)

def scalarProduct2(xs: Vector[Double], ys: Vector[Double]): Double =
  (xs zip ys).map{ case (x, y) =&amp;gt; x * y }.sum

scalarProduct2(a, b)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;두 벡터의 각 요소끼리 곱한다음 모든 값을 합하는 함수이다. 우선 xs 와 ys 를 zip 으로 묶은 다음 각 요소(xy: pair)의 첫번째와 두번째 요소를 곱한다음 모든값을 sum 해준다. map 안의 함수는 case 문으로 대체할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;{case p1 =&amp;gt; e1 ... case pn =&amp;gt; en}

// 위와 동일
x =&amp;gt; x match { case p1 =&amp;gt; e1 ... case pn =&amp;gt; en }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;isPrime&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def isPrime(n: Int): Boolean = (2 until n) forall (x =&amp;gt; (n % x) != 0)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2 부터 n 전까지의 수가 모두 n 으로 나누어 떨어지지 않으면 n 을 prime number(소수)라 할 수 있다.&lt;/p&gt;
&lt;h2&gt;6.2 Combinatorial Search and For-Expressions&lt;/h2&gt;
&lt;p&gt;양수 n 이 있고, 또다른 양수 i 와 j 가 1 &amp;#x3C;= j &amp;#x3C; i &amp;#x3C; n 을 만족하고 i + j 가 소수라는 조건이 있다.
코드로 나타내면 다음과 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;val n = 7
(1 until n) map (i =&amp;gt; (1 until i) map (j =&amp;gt; (i, j)))

// result
res0: scala.collection.immutable.IndexedSeq[scala.collection.immutable.IndexedSeq[(Int, Int)]] = Vector(Vector(), Vector((2,1)), Vector((3,1), (3,2)), Vector((4,1), (4,2), (4,3)), Vector((5,1), (5,2), (5,3), (5,4)), Vector((6,1), (6,2), (6,3), (6,4), (6,5)))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;음.. 분명 Range 타입을 사용하였는데 결과는 Vector of Vectores 가 나왔다.
Range 는 Seq 의 하위 타입이지만 사실 그 중간에 IndexedSeq 라는 타입이 존재한다. 결과값으로 pair 가 나왔으므로, Range 타입에는 결과값을 담을 수 없다. 그래서 일단 바로 위의 상위 타입인 IndexedSeq 타입 중에서 pair 를 담을 가장 적합한 타입인 Vector 가 선택되어 나타난것이다.&lt;/p&gt;
&lt;p&gt;원래 우리가 찾으려고 했던 결과는 Vector 의 Vector 가 아니라 pair 를 하나의 single list 에 담아져야 한다. 그래서 모든 sub-sequences 를 foldRight 와 ++를 이용해서 결합할 필요가 있다. (xss: seq of seq)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;(xss foldRight Seq[Int]())(_ ++ _)

// equvalently
xss.flatten

// so, 원래식 포함해서 아래와 같이 나타낼 수 있다.
((1 until n) map (i =&amp;gt; (1 until i) map (j =&amp;gt; (i, j)))).flatten

// 아래의 법칙을 이용하면
xs flatMap f = (xs map f).flatten

// 더 간단해질 수 있다.
(1 until n) flatMap (i =&amp;gt; (1 until i) map (j =&amp;gt; (i, j)))

// result
res0: scala.collection.immutable.IndexedSeq[(Int, Int)] = Vector((2,1), (3,1), (3,2), (4,1), (4,2), (4,3), (5,1), (5,2), (5,3), (5,4), (6,1), (6,2), (6,3), (6,4), (6,5))

// 두 합이 prime인것만 추려야함, 이전 챕터에서 만든 isPrime 이용
(1 until n) flatMap (i =&amp;gt; (1 until i) map (j =&amp;gt; (i, j))) filter (pair =&amp;gt; isPrime(pair._1 + pair._2))

// result
res0: scala.collection.immutable.IndexedSeq[(Int, Int)] = Vector((2,1), (3,2), (4,1), (4,3), (5,2), (6,1), (6,5))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;For-Expression&lt;/h3&gt;
&lt;p&gt;for loop 에 대해서 알아보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;case class Person(name: String, age: Int)

// 20살 이상인 사람만 가져오고 싶을때
for (p &amp;lt;- persons if p.age &amp;gt; 20) yield p.name

// 아래와 같음
persons filter (p =&amp;gt; p.age &amp;gt; 20) map (p = &amp;gt; p.name)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;기본적인 for loop 동작은 비슷하지만 결정적인 차이가 하나 있다. 보통 절차적 언어의 for loop 는 어떤 요소가 변할 수 있는 side effect 가 존재하지만 스칼라에서는 yield 키워드를 이용해서 iterable 객체를 생성한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;for (s) yield e&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;for-expression 을 위와같이 단순화 시킬 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;s is a sequence of generators and filters
e is an expression whose value is returned by an iteration&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;generator 의 p &amp;#x3C;- e 에서 p 는 하나의 패턴이고, e 는 컬렉션의 값이다.&lt;/li&gt;
&lt;li&gt;filter 의 f 는 boolean expression 이다.&lt;/li&gt;
&lt;li&gt;몇개의 generator 가 있을때는 마지막이 처음보다 빠르다. why?&lt;/li&gt;
&lt;li&gt;( s )는 { s }처럼 사용할 수도 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;example&lt;/h3&gt;
&lt;p&gt;이전에 보았던 문제를 for loop 를 이용해 다시 만들어 보자.
첫번째는 바로 전에 했던 두 수의 합이 prime 넘버인 것의 pair 를 구하는 함수&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;for {
  i &amp;lt;- 1 until n
  j &amp;lt;- 1 until i
  if isPrime(i+j)
} yield (i, j)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;매우 심플해졌다.&lt;/p&gt;
&lt;p&gt;두번째는 scalarProduct&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def scalarProduct(xs: Vector[Double], ys: Vector[Double]): Double =
  (for ((x, y) &amp;lt;- xs zip ys) yield x * y).sum&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;따로 필터링할 조건이 없으므로 모든 요소에 대해서 적용한다.&lt;/p&gt;
&lt;h2&gt;6.3 Combinatorial Search Example&lt;/h2&gt;
&lt;p&gt;이번 챕터에서는 Set 에 대해 알아보자.
Set 도 Seq 와 마찬가지로 Iterable 의 subclass 다. 그래서 Seq 에서 사용하는 대부분의 연산(map, filter 등)을 Set 에서도 동일하게 사용할 수 있다.&lt;/p&gt;
&lt;h3&gt;Sets vs Sequences&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Set 은 unordered 하다.&lt;/li&gt;
&lt;li&gt;Set 은 중복되는 element 를 가질 수 없다.&lt;/li&gt;
&lt;li&gt;Set 의 fundamental operation 은 요소가 해당 Set 에 포함되는지 확인하는 contains 다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Example: N-Queens&lt;/h3&gt;
&lt;p&gt;예제를 살펴보자.
체스보드에 서로 위협이 되지 않는 8 개의 퀸을 놓는 방법을 찾는 문제이다. 다르게 말하면 같은 row, column, diagonal 에 둘 수 없는 문제와 같다.&lt;/p&gt;
&lt;p&gt;알고리즘을 살펴보자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;사이즈 n 인 보드에 k-1 개의 퀸이 놓여진 모든 솔루션 추출&lt;/li&gt;
&lt;li&gt;각 솔루션을 0 에서 n-1 까지의 columns 숫자로 구성된 리스트로 변환&lt;/li&gt;
&lt;li&gt;리스트의 첫번째 요소는 k-1 번째 row 가 될 것이고, k-2, k-3 …의 퀸을 붙여나간다.&lt;/li&gt;
&lt;li&gt;각 솔루션의 하나의 element 와 함께 set of lists 로 만들어진다.&lt;/li&gt;
&lt;li&gt;kth 퀸을 놓아 가능한 모든 솔루션을 만들어낸다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def queens(n: Int): Set[List[Int]] = {
  def placeQueens(k: Int): Set[List[Int]] =
    if (k == 0) Set(List())
     else
      for {
        queens &amp;lt;- placeQueens(k - 1)
        col &amp;lt;- 0 until n
        if isSafe(col, queens)
      } yield col :: queens

  placeQueens(n)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;기본적인 뼈대는 위와 같다. placeQueens 함수를 재귀호출하여, 이전 단계의 퀸 리스트들을 이용해 다음 퀸들을 배치하는 형태다. 한 depth 씩 내려가다보면 마지막에는 빈 셋에 0 에서 n 까지 각각 배치될것이다. 그리고 1 개의 퀸이 배치된 list 들에다 하나씩 추가해가면 마지막에는 모든 퀸이 놓인 체스판이 완성될 것이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def isSafe(col: Int, queens: List[Int]): Boolean = {
  val row = queens.length
  val queensWithRow = (row -1 to 0 by -1) zip queens
  queensWithRow forall {
    case (r, c) =&amp;gt; col != c &amp;amp;&amp;amp; math.abs(col - c) != row - r
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;기존 퀸 리스트에 새로운 퀸을 추가할 때 안전한지 검사하는 isSafe 함수다. case 부분만 유심히 보면 되는데, 각은 column 에 속하지 않으면서 대각선에 위치하지 않으면 safe 하다고 판단하고 퀸을 추가한다. 대각선상에 있는지는 컬럼의 차이와 행의 차이로 판단한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def show(queens: List[Int]) = {
  val lines =
    for (col &amp;lt;- queens)
    yield Vector.fill(queens.length)(&amp;quot;* &amp;quot;).updated(col, &amp;quot;X &amp;quot;).mkString
  &amp;quot;\n&amp;quot; + (lines mkString &amp;quot;\n&amp;quot;)
}

(queens(8) take 3 map show) mkString &amp;quot;\n&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;마지막은 리스트들로 되어 있는 퀸들을 실제 체스판에 올려놓은 것 처럼 출력해주는 show 함수를 이용한다.
결과는 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;res0: String =
* * X * * * * *
X * * * * * * *
* * * * * * X *
* * * * X * * *
* * * * * * * X
* X * * * * * *
* * * X * * * *
* * * * * X * *

* * * * * X * *
* * X * * * * *
X * * * * * * *
* * * * * * * X
* * * X * * * *
* X * * * * * *
* * * * * * X *
* * * * X * * *

* * * * X * * *
* X * * * * * *
* * * * * * * X
X * * * * * * *
* * * X * * * *
* * * * * * X *
* * X * * * * *
* * * * * X * *&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;6.4 Maps&lt;/h2&gt;
&lt;p&gt;Map 에 대해서 알아보자.
Map 은 다른 언어에서와 동일하게 Map[Key, Value]의 쌍으로 이루어져있다. 이때 Key, Value 는 숫자나 문자 등 어떤 타입이든 가능하다.
또한 Map[Key, Value]는 Key =&gt; Value 의 함수 타입으로 확장 가능하다. 즉, Key 파라미터를 이용하면 Value 를 구할 수 있다는 말과 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// key를 이용해 value를 가져올때
capitalOfCountry(&amp;quot;andorra&amp;quot;)   // exception 발생

// 대신에 get을 사용한다.
capitalOfCountry get &amp;quot;andorra&amp;quot;  // None&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Option Type&lt;/h3&gt;
&lt;p&gt;Option 은 covariant 하기 때문에 Option[A] &gt; Option[Nothing]이다. 즉 None&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;trait Option[+A]
case class Some[+A](value: A) extend Option[A]
object None extend Option[Nothing]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;패턴 매칭을 이용하면 아래와 같이 나타낼 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def showCapital(country: String) = capitalOfCountry.get(country) match {
  case Some(capital) =&amp;gt; capital
  case None =&amp;gt; &amp;quot;missing data&amp;quot;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Sorted and GroupBy&lt;/h3&gt;
&lt;p&gt;sql 쿼리의 opertaion 을 사용해보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// sorted
val fruit = List(&amp;quot;apple&amp;quot;, &amp;quot;pear&amp;quot;, &amp;quot;orange&amp;quot;, &amp;quot;pineapple&amp;quot;)
fruit.sortWith (_.length &amp;lt; _.length)  // List(&amp;quot;pear&amp;quot;, &amp;quot;apple&amp;quot;, &amp;quot;orange&amp;quot;, &amp;quot;pineapple&amp;quot;)
fruit.sorted    // List(&amp;quot;apple&amp;quot;, &amp;quot;orange&amp;quot;, &amp;quot;pear&amp;quot;, &amp;quot;pineapple&amp;quot;)

// groupBy
fruit groupBy (_.head)
// Map(p -&amp;gt; List(pear, pineapple)),
//     a -&amp;gt; List(apple),
//     o -&amp;gt; List(orange))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;groubBy 명령은 식별 함수 f 에 따라 collection 의 map 을 만든다.&lt;/p&gt;
&lt;h3&gt;Polynoial Example&lt;/h3&gt;
&lt;p&gt;from exponents to coefficient 방식으로 map 을 만든다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;class Poly(val terms: Map[Int, Double]) {
  def + (other: Poly) = new Poly(terms ++ other.terms)
  override def toString =
    (for ((exp, coeff) &amp;lt;- terms.toList.sorted.reverse) yield coeff+&amp;quot;x^&amp;quot;+exp) mkString &amp;quot; + &amp;quot;
}

val p1 = new Poly(Map(1 -&amp;gt; 2.0, 3 -&amp;gt; 4.0, 5 -&amp;gt; 6.2))
val p2 = new Poly(Map(0 -&amp;gt; 3.0, 3 -&amp;gt; 7.0))
p1 + p2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;두 다항식을 더하는 함수를 작성해보자. 양쪽 다항식에 exponents 가 같은 coefficient 끼리 더해주고 나머지 exponents 들을 합쳐주면 두 다항식의 합이 완성된다. 일단 말은 어렵지 않다.
하지만 위의 식은 아래처럼 잘못된 결과가 도출된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;p1: Poly = 6.2x^5 + 4.0x^3 + 2.0x^1
p2: Poly = 7.0x^3 + 3.0x^0
res0: Poly = 6.2x^5 + 7.0x^3 + 2.0x^1 + 3.0x^0&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;왜 그럴까??
맵끼리 concatenating 할때는 아마 같은 키의 value 를 합치는게 아니라 뒤에 나오는 map 의 key 의 value 로 대체하기 때문에 이렇게 나오는 것이다.
다음과 같이 바꿔보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def + (other: Poly) = new Poly(terms ++ (other.terms map adjust))
def adjust(term: (Int, Double)): (Int, Double) = {
  val (exp, coeff) = term
  terms get exp match {
    case Some(coeff1) =&amp;gt; exp -&amp;gt; (coeff + coeff1)
    case None =&amp;gt; exp -&amp;gt; coeff
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;뒤에 오는 other 에 adjust 함수를 매핑해보자.
adjust 함수는 other 의 term 하나를 뽑아다가 terms 에 해당 exponent 가 있는지 확인하고 있으면 terms 와 other(term)의 coefficient 를 더해준다. 만약 없다면, othe 의 coeff 를 그대로 리턴한다.
결과를 보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;p1: Poly = 6.2x^5 + 4.0x^3 + 2.0x^1
p2: Poly = 7.0x^3 + 3.0x^0
res0: Poly = 6.2x^5 + 11.0x^3 + 2.0x^1 + 3.0x^0&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Default Values&lt;/h3&gt;
&lt;p&gt;심플한 방법이 있었다.
withDefaultValue operation 을 이용하면 위의 함수를 좀더 간단하게 만들 수 있다.
withDefaultValue 를 이용해 좀더 개선해보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;class Poly(terms0: Map[Int, Double]) {
  def this(bindings: (Int, Double)*) = this(bindings.toMap)
  val terms = terms0 withDefaultValue 0.0
  def + (other: Poly) = new Poly(terms ++ (other.terms map adjust))
  def adjust(term: (Int, Double)): (Int, Double) = {
    val (exp, coeff) = term
    exp -&amp;gt; (coeff + terms(exp))
  }

  override def toString =
    (for ((exp, coeff) &amp;lt;- terms.toList.sorted.reverse) yield coeff+&amp;quot;x^&amp;quot;+exp) mkString &amp;quot; + &amp;quot;
}

val p1 = new Poly(1 -&amp;gt; 2.0, 3 -&amp;gt; 4.0, 5 -&amp;gt; 6.2)
val p2 = new Poly(0 -&amp;gt; 3.0, 3 -&amp;gt; 7.0)
p1 + p2
p1.terms(8)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;크게 두가지가 바뀌었다.
첫째는 Poly 클래스의 parameter 에 default value 를 적용해주어 adjust 에서 패턴매칭하는 수고로움을 줄여 주었다. (exp -&gt; (coeff + terms(exp)))
그리고 둘째는 새로운 Poly 를 생성할 때, Map 타입을 지정해 주지 않아도, 생성자에서 (Int, Double)이 sequencial 하게 들어오면 이를 Map 으로 바꿔주도록 하였다.&lt;/p&gt;
&lt;h3&gt;Exercise&lt;/h3&gt;
&lt;p&gt;위에서 보았던 ’++’ 연산과 foldLeft 를 이용한 연산중 어느것이 더 효율적일까?&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def + (other: Poly) =
  new Poly((other.terms foldLeft terms)(addTerm))

def addTerm(terms: Map[Int, Double], term: (Int, Double)): Map[Int, Double] = {
  val (exp, coeff) = term
  terms + (exp -&amp;gt; (coeff + terms(exp)))
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;fold 를 이용하면 위에서처럼 Map 을 생성하여 각 exponent 를 비교해서 값을 넣는게 아니라 기존부터 있던 terms 에다 즉각적으로 추가하기 때문에 ++보다 더 효율적이라 할 수 있다.&lt;/p&gt;
&lt;h2&gt;6.5 Putting the Pieces Together&lt;/h2&gt;
&lt;p&gt;전화번호를 문자로 바꾸는 예제를 살펴보자.
참고로 해당 예제는 파이썬과 같은 스크립트 언어에서는 100 라인 정도, 그외에 일반적 목적의 프로그래밍 언어에서는 200~300 라인정도의 코드가 나왔다고 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;val mnemonics = Map(
       &amp;#39;2&amp;#39; -&amp;gt; &amp;quot;ABC&amp;quot;, &amp;#39;3&amp;#39; -&amp;gt; &amp;quot;DEF&amp;quot;, &amp;#39;4&amp;#39; =&amp;gt; &amp;quot;GHI&amp;quot;, &amp;#39;5&amp;#39; -&amp;gt; &amp;quot;JKL&amp;quot;,
       &amp;#39;6&amp;#39; -&amp;gt; &amp;quot;MNO&amp;quot;, &amp;#39;7&amp;#39; -&amp;gt; &amp;quot;PQRS&amp;quot;, &amp;#39;8&amp;#39; -&amp;gt; &amp;quot;TUV&amp;quot;, &amp;#39;9&amp;#39; -&amp;gt; &amp;quot;WXYZ&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위와 같이 각 번호가 몇개의 문자열로 매핑되어 있다. 해당 숫자가 나왔을때 매핑된 문자열 중에 하나의 문자를 선택해서 출력해준다는 얘기다.&lt;/p&gt;
&lt;p&gt;예를 들어 “7225247386”를 convert 해보면 그 중 하나가 “SCALAISFUN”(Scala is fun)이 된다.&lt;/p&gt;
&lt;p&gt;전체코드는 다음과 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;val in = Source.fromURL(&amp;quot;http://lamp.epfl.ch/files/content/sites/lamp/files/teaching/progfun/linuxwords.txt&amp;quot;)
val words = in.getLines.toList filter (word =&amp;gt; word forall (chr =&amp;gt; chr.isLetter))

val mnem = Map(
  &amp;#39;2&amp;#39; -&amp;gt; &amp;quot;ABC&amp;quot;, &amp;#39;3&amp;#39; -&amp;gt; &amp;quot;DEF&amp;quot;, &amp;#39;4&amp;#39; -&amp;gt; &amp;quot;GHI&amp;quot;, &amp;#39;5&amp;#39; -&amp;gt; &amp;quot;JKL&amp;quot;,
  &amp;#39;6&amp;#39; -&amp;gt; &amp;quot;MNO&amp;quot;, &amp;#39;7&amp;#39; -&amp;gt; &amp;quot;PQRS&amp;quot;, &amp;#39;8&amp;#39; -&amp;gt; &amp;quot;TUV&amp;quot;, &amp;#39;9&amp;#39; -&amp;gt; &amp;quot;WXYZ&amp;quot;)

val charCode: Map[Char, Char] =
  for ((digit, str) &amp;lt;- mnem; ltr &amp;lt;- str) yield ltr -&amp;gt; digit

/**
 * 파라미터로 들어온 문자열을 charCode로 변경함
 * @param word
 * @return
 */
def wordCode(word: String): String =
  word.toUpperCase map charCode

  wordCode(&amp;quot;Java&amp;quot;)  // res0: String = 5282

/**
 * A map form digit strings to the words that represent them,
 * e,g. &amp;quot;5282&amp;quot; -&amp;gt; List(&amp;quot;Java&amp;quot;, &amp;quot;Kata&amp;quot;, &amp;quot;Lava&amp;quot;, ...)
 * Note: A missing number should map to the empty set, e,g. &amp;quot;11111&amp;quot; -&amp;gt; List()
 */
val wordsForNum: Map[String, Seq[String]] =
  words groupBy wordCode withDefaultValue Seq()

/**
 * Return all ways to encode a number as a list of words
 */
def encode(number: String): Set[List[String]] =
  if (number.isEmpty) Set(List())
  // 1 to number.length는 IndexedReq 타입이므로 Set 타입으로 변경해준다
  else {
    for {
      split &amp;lt;- 1 to number.length
      word &amp;lt;- wordsForNum(number take split)
      rest &amp;lt;- encode(number drop split)
    } yield word :: rest
  }.toSet

encode(&amp;quot;7225247386&amp;quot;)

def translate(number: String): Set[String] =
  encode(number) map(_ mkString &amp;quot; &amp;quot;)

translate(&amp;quot;7225247386&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;지금까지 살펴본 스칼라 collection 은 아래와 같이 정리 할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;easy to use: few steps to do the job.&lt;/li&gt;
&lt;li&gt;concise: one word replaces a whole loop.&lt;/li&gt;
&lt;li&gt;safe: type checker is really good at catching errors.&lt;/li&gt;
&lt;li&gt;fast: collection ops art tuned, can be parallelized.&lt;/li&gt;
&lt;li&gt;universal: one vocabulary to work on all kinds of collections.&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Functional Programming in Scala week 5]]></title><description><![CDATA[5.1 More Functions on Lists 이번 챕터에서는 스칼라 List 의 다른 메서드 들을 알아본다.
xs 는 list 의 object 를 뜻한다. Sublists and element access xs.length xs 의 길이 xs…]]></description><link>https://blueshw.github.io/2016/07/26/functional-programming-in-scala-week5/</link><guid isPermaLink="false">https://blueshw.github.io/2016/07/26/functional-programming-in-scala-week5/</guid><pubDate>Tue, 26 Jul 2016 23:28:50 GMT</pubDate><content:encoded>&lt;h2&gt;5.1 More Functions on Lists&lt;/h2&gt;
&lt;p&gt;이번 챕터에서는 스칼라 List 의 다른 메서드 들을 알아본다.
xs 는 list 의 object 를 뜻한다.&lt;/p&gt;
&lt;h3&gt;Sublists and element access&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;xs.length xs 의 길이&lt;/li&gt;
&lt;li&gt;xs.last xs 의 마지막 item return, xs 가 비어있으면 exception 발생&lt;/li&gt;
&lt;li&gt;xs.init 마지막 item 을 제외한 list reutnr, xs 가 비어있으면 exception 발생&lt;/li&gt;
&lt;li&gt;xs take n 처음부터 n 개의 element 의 list 리턴, n 이 xs 의 length 보다 크면 n 개만 리턴&lt;/li&gt;
&lt;li&gt;xs drop n n 개를 제외한 나머지 리스트 리턴&lt;/li&gt;
&lt;li&gt;xs(n) n 번째 item 리턴&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Creating new lists&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;xs ++ ys 두 list 더하기, :::와 같은 기능을 함&lt;/li&gt;
&lt;li&gt;xs.reverse 역순의 리스트 생성&lt;/li&gt;
&lt;li&gt;xs updated (n, x) n 번째 item 만 x 로 바뀐 list 생성&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Finding elements&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;xs indexOf x x 와 같은 첫번째 element 의 index 값 리턴, 없으면 -1&lt;/li&gt;
&lt;li&gt;xs contains x indexOf x &gt;= 0 과 같음&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;last 가 과연 필요한지 모르겠지만(tail 을 recursive 하게 반복하면 찾을 수 있음), 유용하게 쓰일 수 있다면 last 의 복잡도는 어떻게 될까?&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def last[T](xs: List[T]): T = xs match {
  case List() =&amp;gt; throw new Error(&amp;quot;last of empty list&amp;quot;)
  case List(x) =&amp;gt; x
  case y :: ys =&amp;gt; lsat(ys)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위와 같이 list 의 길이와 같으므로, 복잡도는 O(n)이 되겠다.
init 메서드는 어떨까?&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def init[T](xs: List[T]): List[T] = xs match {
  case List() =&amp;gt; throw new Error(&amp;quot;init of empty list&amp;quot;)
  case List(x) =&amp;gt; List()
  case y :: ys =&amp;gt; y :: init(ys)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;마찬가지로 O(n)
그다음은 concat(Same as :::)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def concat[T](xs: List[T], ys: List[T]) = xs match {
  case List() =&amp;gt; ys
  case z :: zs =&amp;gt; z :: concat(zs, ys)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;복잡도는 |xs|, 즉 xs 의 길이가 된다.
다음은 reverse&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def reverse[T](xs: List[T]): List[T] = xs match {
  case List() =&amp;gt; xs
  case y :: ys =&amp;gt; reverse(ys) ++ List(y)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;reverse(ys) :: y 가 아니라 reverse(ys) ++ List(y)인 이유는 ::의 마지막엔 Nil 이 와야하니깐 y 가 Nil 이 아니기 때문이 아닐까 생각한다.
복잡도는 각 요소마다 concatenating 을 해주고 list 의 length 만큼 reverse 를 해야하므로 O(n2)이 되겠다. reverse 는 다소 실망스러운 성능을 보여주는데, 앞으로 더 개선해보도록 하겠다.&lt;/p&gt;
&lt;p&gt;마지막으로 removeAt&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def removeAt[T](n: Int, xs: List[T]) = (xs take n) ::: (xs drop n+1)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5.2 Paires and Tuples&lt;/h2&gt;
&lt;p&gt;앞서 살펴보앗던 insertion sort 보다 더 개선된 merge sort 알고리즘에 대해서 살펴보자. 기본적인 개념은 zero or one element 리스트는 이미 sorted 하다는 것.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def msort(xs: List[Int]): List[Int] = {
  val n = xs.length/2
  if (n == 0) xs
  else {
    // merge 메서드는 앞으로 더 개선해 나갈 예정임
    def merge(xs: List[Int], ys: List[Int]) =
      xs mathch {
        case Nil =&amp;gt; ys
        case x :: xs1 =&amp;gt;
          ys match {
            case Nil =&amp;gt; xs
            case y :: ys1 =&amp;gt;
              if (x &amp;lt; y) x :: merge(xs1, ys)
              else y :: merge(xs, ys1)
          }
      }

    val (fst, snd) = xs splitAt n
    merge(msort(fst), msort(snd))
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;밑에서 나오는 splitAt 함수는 index n 을 기준으로 리스트를 두개로 쪼개서 리턴한다. 여기서 리턴된 val 의 모양을 보자. fst 와 snd 두개의 타입으로 묶여져 있다. 이를 Pair 라고 한다. 예를 들면&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;val pair = (&amp;quot;answer&amp;quot;, 42) &amp;gt; pair: (String, Int) = (answer,42)

val (label, value) = pare &amp;gt; label: String = answer | value : Int = 42&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위와 같이 타입으로도 쓰일 수 있고, 패턴으로도 사용될 수 있다. 이때 2 개 이상의 요소를 가지면 Tuples 라 한다. Tuples 는 다양하게 사용될 수 있는데, parameterized type 으로 사용될 경우, function applictaion 으로 사용될 경우, constructor 패턴으로 사용될 경우 각각&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;scala.Tuplen[T1, ..., Tn]
scala.Tuplen(e1, ..., en)
scala.Tuplen(p1, ..., pn)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;과 같이 사용할 수 있다. (여기서 Tuplen 의 n 은 파라미터 개수 ex. Tuple2)
튜플의 각 element 는 _1, _2 와 같이 접근할 수 있다.
이제 merge 메소드를 개선해보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def merge(xs: List[Int], ys: List[Int]): List[Int] = (xs, ys) match {
  case (Nil, ys) =&amp;gt; ys
  case (xs, Nil) =&amp;gt; xs
  case (x :: xs1, y :: ys1) =&amp;gt;
    if (x &amp;lt; y) x :: merge(xs1, ys)
    else y :: merge(xs, ys1)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;훨씬 깔끔해졌다.&lt;/p&gt;
&lt;h2&gt;5.3 Implicit Parameters&lt;/h2&gt;
&lt;p&gt;이전 장에서 보았던 msort 는 List[Int] 타입으로 지정되어 있는데 parameterize 를 통해서 Int 말고도 다른 타입이 들어올 수 있도록 임의의 타입 T 로 변경해보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;object mergesort {
  def msort[T](xs: List[T]): List[T] = {
    val n = xs.length/2
    if (n == 0) xs
    else {
      def merge(xs: List[T], ys: List[T]): List[T] = (xs, ys) match {
        case (Nil, ys) =&amp;gt; ys
        case (xs, Nil) =&amp;gt; xs
        case (x :: xs1, y :: ys1) =&amp;gt;
          if (x &amp;lt; y) x :: merge(xs1, ys)
          else y :: merge(xs, ys1)
      }

      val (fst, snd) = xs splitAt n
      merge(msort(fst), msort(snd))
    }
  }

  val nums = List(2, -4, 5, 7, 1)
  msort(nums)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;x &amp;#x3C; y 부분에서 에러가 발생한다. 왜냐하면 comparison ’&amp;#x3C;‘가 임의의 타입 T 에 정의되어 있지 않기 때문이란다…
그래서 우리는 comparison 함수가 필요하다. 이 때 가장 유연한 방법은 msort 함수에 comparison operation 을 추가적인 파라미터로 붙이는 것이다. 아래처럼&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def msort[T](xs: List[T])(lt: (T, T) =&amp;gt; Boolean) = {
  ...
  merge(msort(fst)(lt), msort(snd)(lt))
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그래서 원래 mergesort 에 적용하면 다음과 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;object mergesort {
  def msort[T](xs: List[T])(lt: (T, T) =&amp;gt; Boolean): List[T] = {
    val n = xs.length/2
    if (n == 0) xs
    else {
      def merge(xs: List[T], ys: List[T]): List[T] = (xs, ys) match {
        case (Nil, ys) =&amp;gt; ys
        case (xs, Nil) =&amp;gt; xs
        case (x :: xs1, y :: ys1) =&amp;gt;
          if (lt(x, y)) x :: merge(xs1, ys)
          else y :: merge(xs, ys1)
      }

      val (fst, snd) = xs splitAt n
      merge(msort(fst)(lt), msort(snd)(lt))
    }
  }

  val nums = List(2, -4, 5, 7, 1)
  msort(nums)((x, y) =&amp;gt; x &amp;lt; y)

  val fruits = List(&amp;quot;apple&amp;quot;, &amp;quot;pineapple&amp;quot;, &amp;quot;banana&amp;quot;, &amp;quot;orange&amp;quot;)
  msort(fruits)((x, y) =&amp;gt; x.compareTo(y) &amp;lt; 0)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이제 Int 타입 뿐만 아니라 String 과 같은 다른 타입도 정렬이 가능해졌다. 이 때 lt 에 들어오는 함수 파라미터에 타입 붙이는 걸 생략해도 되는데, 컴파일러가 앞에 있는 리스트의 타입을 보고 유추할 수 있기 때문이란다. 즉 파라미터 셋의 마지막에 function value 가 들어오게 되면, 컴파일러가 타입 체크를 미뤄버린다.&lt;/p&gt;
&lt;h3&gt;scala.math.Ordering[T]&lt;/h3&gt;
&lt;p&gt;사실 ordering 을 위한 스탠다드 라이브러리 클래스가 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;scala.math.Ordering[T]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;그래서 lt 명령어를 parameterizing 하는 대신 Orderging 클래스로 parameterize 할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def msort[T](xs: List[T])(ord: Ordering) =

  def merge(xs: List[T], ys: List[T]) =
    ... if (ord.lt(x, y)) ...

  ... merge(msort(fst)(ord), msort(snd)(ord)) ...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;implicit&lt;/h3&gt;
&lt;p&gt;대체로 완성된 느낌이 나지만, Ordering 함수가 처음 콜 될때부터 계속 전달되는게 좀 비효율적으로 보인다. 그래서 여기에다가 또하나를 추가해보자.
ord 파라미터에 implicit(절대적인이란 뜻) 키워드를 앞에 붙여보자. 그러면, 함수를 실제로 호출하는 부분에서 실제 파라미터를 넣어줄 필요가 없다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def msort[T](xs: List[T])(implicit ord: Ordering) =

  def merge(xs: List[T], ys: List[T]) =
    ... if (ord.lt(x, y)) ...

  ... merge(msort(fst), msort(snd)) ...

val nums = List(2, -4, 5, 7, 1)
msort(nums)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;더 간결해졌다.&lt;/p&gt;
&lt;h3&gt;Rules for Implicit Parameters&lt;/h3&gt;
&lt;p&gt;타입이 T 인 implicit 파라미터가 있을때, 컴파일러는&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(1) implicit 이 쓰인 파라미터에 (2) T 와 호환되는 타입을 가지고 (3) function call 에서 보이거나 T 와 관련된 companion 오브젝트(클래스와 객체 이름이 같은 오브젝트)에서
single implicit definition 을 찾는다. 즉, Ordering[Int]가 함수 call 의 파라미터로 존재하지 않지만, implicit 으로 처리되어 어딘가에 존재하게 된다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;5.4 Higher-Order List Functions&lt;/h2&gt;
&lt;p&gt;위에서 보았던 예제들은 종종 비슷한 구조를 보여준다. 요약해보면&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;리스트의 각 element 를 변경하는 것&lt;/li&gt;
&lt;li&gt;어떤 조건을 만족하는 모든 element 의 리스트를 구하는 것&lt;/li&gt;
&lt;li&gt;연산자를 사용하여 element 들을 결합하는 것&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;함수형 언어는 higer-order functinos 패턴을 이용하는 generic function 을 만들 수 있다.&lt;/p&gt;
&lt;p&gt;첫번째 예제는 각 요소를 multiply 하는 것이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def scaleList(xs: List[Double], factor: Double): List[Double] = xs match {
  case Nil =&amp;gt; xs
  case y :: ys =&amp;gt; y * factor :: scaleList(ys, factor)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Map&lt;/h3&gt;
&lt;p&gt;위 예제는 list 의 map 메서드를 이용하여 만들 수 있다.
map 메서드의 구조를 살펴보면 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;abstract class List[T] { ...
  def map[U](f: T =&amp;gt; U): List[U] = this match {
    case Nil =&amp;gt; this
    case x :: xs =&amp;gt; f(x) :: xs.map(f)
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;파라미터로 들어온 함수 f 가 각 element 에 적용되어서 새로운 리스트를 만들어 내는 함수가 바로 map 이다. map 메서드를 이용하면 훨씬 간단하게 작성할 수 있다&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def scaleList(xs: List[Double], factor: Double) =
  xs.map(x =&amp;gt; x * factor)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;또하나의 예제를 살펴보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def squareList(xs: List[Int]): List[Int] = xs match {
  case Nil =&amp;gt; Nil
  case y :: ys =&amp;gt; y * y :: squareList(ys)
}

def squareList(xs: List[Int]): List[Int] =
  xs map (y =&amp;gt; y * y)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Filtering&lt;/h3&gt;
&lt;p&gt;필터링은 어떤 조건에 맞는 element 를 모아 새로운 리스트를 만들어 내는 메서드이다.
0 보다 큰수만 필터링 하는 다음의 함수를 보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def posElems(xs: List[Int]): List[Int] = xs match {
  case Nil =&amp;gt; xs
  case y :: ys =&amp;gt; if (y &amp;gt; 0) y :: posElems(ys) else posElems(ys)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;필터를 이용하면 간단하게 해결할 수 있다. 우선은 filter 메서드가 어떻게 생겼는지부터 살펴보도록 하자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;abstract class List[T] {
  ...
  def filter(p: T =&amp;gt; Boolean): List[T] = this match {
    case Nil =&amp;gt; this
    case x :: xs =&amp;gt; if (p(x)) x :: xs.filter(p) else xs.filter(p)
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;필터는 특정조건함수(p)가 true 이면 :: 연산자를 이용하여 리스트에 붙이고 false 이면 제외하는 방식으로 새로운 리스트를 만들어간다.
그럼 위에서 보았던 posElems 를 filter 를 이용해 재구성해보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def posElems(xs: List[Int]): List[Int] =
  xs filter(x =&amp;gt; x &amp;gt; 0)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그외에 유용한 메서드 목록은 아래와 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;xs filterNot p xs filter (x =&gt; !p(x))와 같다.&lt;/li&gt;
&lt;li&gt;xs partition p (xs filter p, xs filterNot) 튜플&lt;/li&gt;
&lt;li&gt;xs takeWhile p p 를 만족하는 요소들의 가장 긴 리스트&lt;/li&gt;
&lt;li&gt;xs dropWhile p p 를 만족하는 요소들의 나머지&lt;/li&gt;
&lt;li&gt;xs span p (xs takeWhile p, xs dropWhile p) 튜플&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예를 들어보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;scala&amp;gt; val nums = List(2, -4, 5, 7, 1)
nums: List[Int] = List(2, -4, 5, 7, 1)

scala&amp;gt; nums filter (x =&amp;gt; x &amp;gt; 0)
res0: List[Int] = List(2, 5, 7, 1)

scala&amp;gt; nums filterNot (x =&amp;gt; x &amp;gt; 0)
res1: List[Int] = List(-4)

scala&amp;gt; nums partition (x =&amp;gt; x &amp;gt; 0)
res2: (List[Int], List[Int]) = (List(2, 5, 7, 1),List(-4))

scala&amp;gt; nums takeWhile (x =&amp;gt; x &amp;gt; 0)
res3: List[Int] = List(2)

scala&amp;gt; nums dropWhile (x =&amp;gt; x &amp;gt; 0)
res4: List[Int] = List(-4, 5, 7, 1)

scala&amp;gt; nums span (x =&amp;gt; x &amp;gt; 0)
res5: (List[Int], List[Int]) = (List(2),List(-4, 5, 7, 1))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5.5 Reductino of Lists&lt;/h2&gt;
&lt;p&gt;5.4 절에 이어 higr-order Function 패턴을 이용한 List 메서드에 대해서 계속 알아보도록 하자. 5.4 에서 보았던 세가지 패턴 중에 마지막인 element 를 결합하는 방법들에 대한 내용들이 되겠다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;sum(List(x1, ..., xn))      = 0 + x1 + ... + xn
product(List(x1, ..., xn))  = 1 * x1 * ... * xn&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;ReduceLeft&lt;/h3&gt;
&lt;p&gt;각 요소를 더하거나 곱하는 sum 과 product 메서드가 있다. 이를 ReduceLeft 메서드를 이용하여 구현해보도록하자. ReduceLeft 메서드는 아래와 같은 구조를 가진다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;List(x1, ..., xn) reduceLeft op = (...(x1 op x2) op ... ) op xn

// 위의 구조를 이용하면 sum과 product는 아래와 같이 구현가능하다.
def sum(xs: List[Int]) = (0 :: xs) reduceLeft ((x, y) =&amp;gt; x + y) // or (_ + _)
def product(xs: List[Int]) = (1 :: xs) reduceLeft ((x, y) =&amp;gt; x * y) // or (_ * _)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;FoldLeft&lt;/h3&gt;
&lt;p&gt;foldLeft 함수는 reduceLeft 함수에 비해 좀더 일반적인 형태이다. foldLeft 가 reduceLeft 와 비슷하지만, foldLeft 는 하나의 accumulator(z)를 가진다.
구조는 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;(List(x1, ..., xn) foldLeft z)(op) = (...(z op x1) op ...) op xn&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;foldLeft 로 sum 과 product 를 구현해보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def sum(xs: List[Int]) = (xs foldLeft 0) (_ + _)
def product(xs: List[Int]) = (xs foldLeft 1) (_ * _)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;foldLeft 와 reduceLeft 는 List class 에서 다음과 같이 구현된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;abstract class List[T] { ...
  def reduceLeft(op: (T, T) =&amp;gt; T): T = this match {
    case Nil =&amp;gt; throw new Error(&amp;quot;Nil.reduceLeft&amp;quot;)
    case x :: xs =&amp;gt; (xs foldLeft x)(op)
  }
  def foldLeft[U](z: U)(op: (U, T) =&amp;gt; U): U = this match {
    case Nil =&amp;gt; z
    case x :: xs =&amp;gt; (xs foldLeft op(z, x))(op)
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;reduceLeft 도 내부적으로는 foldLeft 메서드를 이용한다.
그리고 reduceRight 와 foldRight 도 위의 두 메서드와 비슷한 구조로 동작한다. 대신 좌측이 아닌 우측(뒤)부터 reduce 한다.&lt;/p&gt;
&lt;h3&gt;Difference between FoldLeft and FoldRight&lt;/h3&gt;
&lt;p&gt;foldLeft 와 foldRight 는 무엇이 다를까? 기본적으로 sum 을 가지고 생각했을때, 왼쪽부터 더하는 것이나 오른쪽부터 더하는 것이나 결과는 동일하다. 하지만 어떤 경우에는 둘 중 하나만 적절할 때도 있다. 아래의 예제를 보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def concat[T](xs: List[T], ys: List[T]): List[T] = (xs foldRight ys) (_ :: _)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 함수에서 foldRight 를 foldLeft 로 변경하면, 타입에러가 발생한다.
1 :: List(2)는 가능하지만 List(1) :: 2 는 불가능한 연산이기 때문이다.&lt;/p&gt;
&lt;h2&gt;5.6 Reasoning About Concat&lt;/h2&gt;
&lt;p&gt;이번 챕터에서는 어떤 연산자(or 함수)가 정확히 참임을 증명할 수 있는지에 대해 알아보도록 한다.
일반적으로 natural induction(자연 귀납?)에 의해 증명하는 방법의 예는 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;P(n)이 모든 n &gt;= b 에대해서&lt;/li&gt;
&lt;li&gt;P(b)가 참이다. (base case)&lt;/li&gt;
&lt;li&gt;이때, 모든 n &gt;= b 에 대해서 P(n)이 참이면, P(n + 1)도 참이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Referential Transparency (참조 투명성)&lt;/h3&gt;
&lt;p&gt;순수한 함수형 프로그램에서는 사이드 이펙트가 없기 때문에, reduction steps 가 어떤 부분에 대해서도 동일하게 적용된다. 이를 Referential Transparency(참조 투명성)이라 한다.&lt;/p&gt;
&lt;p&gt;structural induction 은 natural induction 과 비슷하다.
structural induction 은 다음과 같이 동작한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;P(xs)이 모든 리스트 xs 에 대해서&lt;/li&gt;
&lt;li&gt;P(Nil)이 hold 된다면&lt;/li&gt;
&lt;li&gt;리스트 xs 와 어떤 element x 에 대해서 P(xs)가 hold 되다면, P(x :: xs) 또한 hold 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이제 concat 함수를 다시 살펴보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def concat[T](xs: List[T], ys: List[T]) = xs match {
  case List() =&amp;gt; ys
  case x :: xs1 =&amp;gt; x :: concat(xs1, ys)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그리고 다음의 수식을 structural induction 으로 증명해보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;(xs ++ ys) ++ zs = xs ++ (ys ++ zs)
// ++(concat) 연산자의 두가지 정리를 참고한다
// Nil ++ ys = ys
// (x :: xs1) ++ ys = x :: (xs1 ++ ys)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;우선 xs 에 Nil 이 들어갈 때인 P(Nil)을 살펴보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// left
(Nil ++ ys) ++ zs
= ys ++ zs      // by 1st clause of ++

// right
Nil ++ (ys ++ zs)
= ys ++ zs      // by 1st clause of ++&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;다음은 xs 대신에 induction step 인 ‘x :: xs’를 넣어보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// left
((x :: xs) ++ ys) + zs
= (x :: (xs ++ ys)) ++ zs      // by 2st clause of ++
= x :: ((xs ++ ys) ++ zs)      // by 2st clause of ++
= x :: (xs ++ (ys ++ zs))    // by induction hypothesis
// right
(x :: xs) ++ (ys ++ zs)
= x :: (xs ++ (ys ++ zs))    // by 2st clause of ++&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;좌변과 우변이 같으므로 함수 P 는 증명됨&lt;/p&gt;
&lt;h2&gt;5.7 A Larger Equational Proof on Lists&lt;/h2&gt;
&lt;p&gt;좀더 까다로운 function 인 reverse 에 대해서 알아보자
다음의 두가지 amenable 한 사실을 가지고 그 아래의 식을 증명해보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;(1) Nil.reverse = Nil               // 1st clause
(2) (x :: xs).reverse = xs.reverse ++ List(x)   // 2nd clause

// 다음을 증명
xs.reverse.reverse = xs&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;base case 는 단순하다&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Nil.reverse.reverse
= Nil.reverse
= Nil&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이번엔 reduction step 이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// left
(x :: xs).reverse.reverse
= (xs.reverse ++ List(x)).reverse     // by 2nd clause of reverse

// right
x :: xs
= x :: xs.reverse.reverse       // by induction hypothesis (가설에 의해)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;두 개를 합쳐보면,&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;(xs.reverse ++ List(x)).reverse = x :: xs.reverse.reverse&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;직접적으로 induction 이 불가하므로, 동일한 연산을 일반화 시켜보자
여기서는 xs.reverse 를 ys 로 치환하도록 하자. 그럼 수식이 아래와 같이 바뀐다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;(ys ++ List(x)).reverse = x :: ys.reverse&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그럼 이제 두번째 induction 인 ys 를 증명하면 동일함을 입증할 수 있겠다.
우선 base case 부터 살펴보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// left
(Nil ++ List(x)).reverse
= List(x).reverse       // by 1st clause of ++
= (x :: Nil).reverse    // by definition of List
= Nil.reverse ++ List(x)
= Nil ++ (x :: Nil)     // by 2nd clause of reverse
= x :: Nil          // by 1st clause of ++
= x :: Nil.reverse      // by 1st clause of reverse&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;결과는 우변의 ys 에 Nil 을 집어넣었을 때와 동일한 결과과 도출되었으므로 base case 를 증명되었다. 이제 reduction step 으로 가보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// left
((y :: ys) ++ List(x)).reverse
= (y :: (ys ++ List(x))).reverse    // by 2nd clause of ++
= (ys ++ List(x)).reverse ++ List(y)  // by 2nd clause reverse
= (x :: ys.reverse) ++ List(y)      // by the induction hypothesis
= x :: (ys.reverse ++ List(y))      // by 1st clause of ++
= x :: (y :: ys).reverse        // by 2nd clause of reverse

// right
x :: (y :: ys).reverse&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;좌변과 우변이 동일하므로 증명되었다.&lt;/p&gt;
&lt;h3&gt;Exercise&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;(xs ++ ys) map f = (xs map f) ++ (ys map f)

Nil map f = Nil
(x :: xs) map f = f(x) :: (xs map f)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;base case..&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// left
(Nil ++ ys) map f
= ys map f

// right
(Nil map f) ++ (ys map f)
= Nil ++ (ys map f)
= ys map f&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;reduction step&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// left
((x :: xs) ++ ys) map f
= (x :: (xs ++ ys)) map f
= f(x) :: ((xs ++ ys) map f)
= f(x) :: ((xs map f) ++ (ys map f))

// right
((x :: xs) map f) ++ (ys map f)
= (f(x) :: (xs map f)) ++ (ys map f)
= f(x) :: ((xs map f) ++ (ys map f))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;base case, reduction step 모두 좌변과 우변이 같으므로 같음이 증명되었다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Functional Programming in Scala week 4]]></title><description><![CDATA[4.1 Objects Everywhere 퓨어 object-oriented 언어란 모든 value 가 object 라는 말인데, 그렇다면 스칼라가 퓨어 object-oriented language 인가? 스칼라의 모든 값은 object…]]></description><link>https://blueshw.github.io/2016/07/26/functional-programming-in-scala-week4/</link><guid isPermaLink="false">https://blueshw.github.io/2016/07/26/functional-programming-in-scala-week4/</guid><pubDate>Tue, 26 Jul 2016 23:27:50 GMT</pubDate><content:encoded>&lt;h2&gt;4.1 Objects Everywhere&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;퓨어 object-oriented 언어란 모든 value 가 object 라는 말인데, 그렇다면 스칼라가 퓨어 object-oriented language 인가?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;스칼라의 모든 값은 object 로 표현되기 때문에 퓨어하다 할 수 있다. 예로 scala.Boolean 대신 커스텀으로 Boolean 클래스를 정의한다(자바의 래핑클래스(Integer 등)처럼)&lt;/p&gt;
&lt;p&gt;Boolean 클래스에서는 실제 스칼라 Boolean 으로 사용할 수 있었던 연산을 모두 재정의해준다.
ifThenElse 는 if(cond) f1 else f2 과 같다(여기서 f1, f2 는 ifThenElse 의 파라미터)
아래는 ’&amp;#x3C;’ 함수를 정의한 예제이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;claass Boolean {
  ...
  def &amp;lt; (x: Boolean): Boolean = ifThenElse(false, x)
 }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4.2 Functions as Objects&lt;/h2&gt;
&lt;p&gt;스칼라에서는 function values 는 오브젝트로 취급된다. 사실 function type A =&gt; B 는 scala.Function1[A, B]의 축약 형태와 같다고 할수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;package scala
trait Function1[A, B] {
  def aaply(x: A): B
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;즉, 함수는 apply 메소드를 가진 오브젝트와 같다.
익명함수의 경우에는 다음과 같이 확장될 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;(x: Int) =&amp;gt; x * x

// is expanded to
{ class AnonFun extends Function1[Int, Int] {
  def apply(x: Int) = x * x
  }
  new AnonFun
}

// shorter
new FUnctino1[Int, Int] {
  def apply(x: Int) = x * x
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그러니까 실제로 f(a, b) 라는 함수를 call 했을 때, f.apply(a, b)가 불리는 것과 같다는 말이다.
예를 들면,&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;val f = (x: Int) =&amp;gt; x * x
f(7)

val f = new Function[Int. Int] {
  def apply(x: Int) = x * x
}
f.apply(7)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위에서 본것처럼 apply 메소드는 오브젝트 안에 있을 때 오브젝트 이름 그대로 호출할 수 있다. 지난번에 봤던 List 를 예로 들어보면 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;trait List[T] {
  def isEmpty: Boolean
  def head: T
  def tail: List[T]
}

class Cons[T](val head: T, val tail: List[T]) extends List[T] {
  def isEmpty = false
}

class Nil[T] extends List[T] {
  def isEmpty: Boolean = true
  def head: Nothing = throw new NoSuchElementException(&amp;quot;Nil.head&amp;quot;)
  def tail: Nothing = throw new NoSuchElementException(&amp;quot;Nil.tail&amp;quot;)
}

// List()
object List {
  def apply[T]: List[T] = new Nil
  def apply[T](x: T): List[T] = new Cons(x, new Nil)
  def apply[T](x1: T, x2: T): List[T] = new Cons(x1, new Cons(x2, new Nil))

  // objectd 이름 그대로 호출 가능, 파라미터가 맞는 apply 메소드를 알아서 찾아감
  val a = List()
  val b = List(1)
  val c = List(2, 3)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4.3 Subtyping and Generics&lt;/h2&gt;
&lt;p&gt;스칼라 언어에서 다형성을 표현하는 두가지 방법은 subtyping 과 generic 이다.&lt;/p&gt;
&lt;h3&gt;Type Bounds&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;takes an IntSet
returns the IntSet itself if all this elements are positive
throws an exception otherwise&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;위의 세가지 조건을 충족시킬 수 있는 함수를 생각해보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def assertAllPos(s: IntSet): IntSet&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;대부분의 경우는 위의 함수로 충분하지만 정확히 하자면 다음과 같이 쓸수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def assertAllPos[S &amp;lt;: IntSet](r: S): S = ...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;“S &amp;#x3C;: IntSet”을 type parameter S 의 upper bound 라고 한다. 이것은 S 가 반드시 IntSet 의 subType(또는 자신)이어야 한다는 말과 같다.
반대로 “S :&gt; T”는 S 가 T 의 superType 이거나 T 가 S 의 subType 이라는 말이다. 이를 lower Bounds 라고 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;[S &amp;gt;: NonEmpty]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위에서 말했듯이 위의 의미는 S 가 NonEmpty 클래스의 supertype 인데, S 는 NonEmpty 의 모든 base 클래스(자신 포함)가 해당된다. 여기서 S 는 NonEmpty, IntSet, AnyRef, Any 가 될 수 있다.&lt;/p&gt;
&lt;p&gt;마지막은 Mixed Bound&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;[S &amp;gt;: NonEmpty &amp;lt;: IntSet]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이것의 의미는 S 가 NonEmtpy 와 IntSet 타입 사이의 모든 타입이 될 수 있다는 말과 같다.&lt;/p&gt;
&lt;h3&gt;Covariance&lt;/h3&gt;
&lt;p&gt;서브클래스의 인스턴스 컬렉션을 상위클래스의 컬렉션으로 보내는 것을 Covariance(공변성)라고 한다. 왜냐하면 subtyping 관계가 컬렉션에서도 그대로 적용되었기 때문이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;NonEmpty &amp;lt;: IntSet
// 위가 성립된다면 아래도 성립
List[NonEmpty] &amp;lt;: List[IntSet]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Arrays in Scala&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;T[]     // Java
Array[T]  // Scala

// Covariance에 의해 아래가 성립
NonEmpty[] &amp;lt;: IntSet[]        // Java
Array[NonEmpty] &amp;lt;: Array[IntSet]  // Scala&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;자바의 Array Typing 에는 타입과 관련된 아래의 문제가 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;NonEmpty[] a = new NonEmpty[]{new NonEmpty(1, Empty, Empty)}
IntSet[] b = a
b[0] = Empty
NonEmpty s = a[0]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;a 는 NonEmpty 타입의 Array 를 가리키는 포인터이다. 두번째 줄에서 IntSet Array b 에 a 를 대입하였다. b 가 실제로 카리키는 대상은 NonEmpty List 지만, covariance 규칙에 의해 상위 타입의 컬렉션이 하위 타입의 컬렉션을 대신할 수 있다. 세번째 줄에서 b 의 첫번째 item 에 Empty 클래스를 대입하였다. 마지막으로 a 의 첫번째 item 을 NonEmpty 타입의 s 에 대입하였다. b 와 a 는 실제로 가리키는 대상이 같기 때문에 세번째 줄에서 b[0]에 들어간 Empty 는 a[0]에서도 동일하게 작동한다. 그런데 마지막 줄에서 Empty 타입의 item 을 NonEmpty 타입에 할당하기 때문에 런타임 에러가 발생한다.&lt;/p&gt;
&lt;h3&gt;Liskov Substitution Principle&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;If A &amp;#x3C;: B, then everything one can to do with a value of type B one should also be able to do with a value of type A
리스코프 치환원칙은 타입 A 와 B 가 있을때 하나의 타입이 다른 하나의 서브타입이 될 수 있는 조건에 대해 말해준다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// in scala
val a: Array[NonEmpty] = Array(new NonEmpty(1, Empty, Empty))
val b: Array[IntSet] = a
b(0) = Empty
val s: NonEmpty = a(0)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;스칼라의 경우에는 두번째 줄에서 컴파일 에러가 난다. 그 이유는 스칼라의 Array 는 covariant 하지 않기 때문이다. (NonEmpty )&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;NonEmpty &amp;lt;: IntSet
not Array[NonEmpty] &amp;lt;: Array[IntSet]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4.4 Variance&lt;/h2&gt;
&lt;p&gt;스칼라에서 List 는 covariant, Array 는 성립하지 않는다. 그 이유는 list 의 경우에는 immutable 한 컬렉션이고, Array 는 mutable 하기 때문이다. 보통 mutation 을 허용하는 타입은 covariant 하지 않다.&lt;/p&gt;
&lt;p&gt;C[T]에서 A &amp;#x3C;: B 인 경우 다음이 성립한다.
B 가 A 의 수퍼타입이면서 C[B]가 C[A]의 수퍼타입인 경우에는 covariant, C[A]가 C[B]의 수퍼타입이면 contravariant&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C[A] &amp;#x3C;: C[B] 이면 C 는 covariant (class C[+A])&lt;/li&gt;
&lt;li&gt;C[A] &gt;: C[B] 이면 C 는 contravariant (class C[-A])&lt;/li&gt;
&lt;li&gt;C[A]와 C[B] 둘다 다른것의 서브타입이 아니면 C 는 nonvariant (class C[A])&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;다음의 두 타입중 어떤 타입이 수퍼타입이고, 어떤 타입이 서브타입인가?
함수의 파라미터가 더 구체적인(서브타입) 타입이 들어 갔을때는 반드시 그 타입으로 인자가 넘어와야한다. type B 를 보면 파라미터 타입이 IntSet 의 서브타입인 NonEmpty 이므로 인자가 반드시 NonEmpty 타입이어야 한다. 반면에 type A 를 보면, 파라미터 타입이 IntSet 이라 NonEmpty 포함 IntSet 의 모든 서브타입이 들어 올 수 있다. 리턴타입은 NonEmpty 이므로 IntSet 이라 할 수 있다. 즉, A 는 B 의 규칙을 만족시킨다. 게다가 A 는 파라미터에 추가로 Empty 같은 타입이 들어 올 수 있으므로, A 가 B 보다 더 확장된 형태이다.
그러므로, B 가 A 의 수퍼타입이다. 함수의 파라미터는 contravariant 하고 함수의 리턴값은 covariant 하기 때문에 A &amp;#x3C;: B 가 참이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;type A = IntSet =&amp;gt; NonEmpty
type B = NonEmpty =&amp;gt; IntSet&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 내용을 요약하면 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;If A2 &amp;lt;: A1 and B1 &amp;lt;: B2, then
  A1 =&amp;gt; B1  &amp;lt;:  A2 =&amp;gt; B2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;Functions are contravariant in their argument type(s) and covariant in their result type.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Variance Checks&lt;/h3&gt;
&lt;p&gt;위에서 Array 는 mutable 한 속성 때문에 covariant 하지 못하다는 문제를 살펴봤었다. mutable 한 속성이라는 것은 update 가능하다는 말과 같은데, Array 클래스에서 update 함수의 파라미터의 타입이 어떤 문제를 가지고 있는지 살펴보자. 앞서서 covariant 타입은 함수의 result 타입에만 나타날 수 있다고 말했다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;class Array[+T] {
  def update(x: T) ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그런데 위의 Array 클래스의 update 함수를 보면, covariant 타입 T 가 파라미터에 쓰여졌기 때문에 Array 는 covariant 하지 못
한 컨테이너라 할 수 있겠다.&lt;/p&gt;
&lt;p&gt;그래서 앞서서 보았던(4.2) Function1 은 사실 아래와 같은 형태이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;package scala
trait Function1[-T, +U] {
  def apply(x: T): U
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그렇다면 List 의 경우는 어떨까?
Nil, Cons 클래스의 경우로 살펴보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;package week4

trait List[+T] {
  def isEmpty: Boolean
  def head: T
  def tail: List[T]
}

class Cons[T](val head: T, val tail: List[T]) extends List[T] {
  def isEmpty = false
}

object Nil extends List[Nothing] {
  def isEmpty: Boolean = true
  def head: Nothing = throw new NoSuchElementException(&amp;quot;Nil.head&amp;quot;)
  def tail: Nothing = throw new NoSuchElementException(&amp;quot;Nil.tail&amp;quot;)
}

// val x의 return 타입이 List[Nothing]을 상속받는 Nil object 이므로,
// covariant 규칙에 의해 List[String]으로 리턴 타입을 지정할 수 있다.
// List[Nothing] &amp;lt;: List[String]
object test {
  val x: List[String] = Nil
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Nil 이 List[Nothing]을 상속하게 만들면 모든 리스트의 서브타입이 된다. 그리고 trait List[T]를 trait List[+T]로 바꿔서 covariant 하게 만들어 준다. val x: List[String] = Nil 을 입력하게 되면, Nil 이 List[Nothing]을 상속받으므로 covariant 하게 바뀐 List 속성에 의해서 Nothing 보다 상위 클래스인 String 타입으로 리턴 할 수 있게 되었다.&lt;/p&gt;
&lt;p&gt;List 클래스에 다음과 같은 prepend 메서드를 추가해보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def prepend(elem: T): List[T] = new Cons(eleml, this)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;컴파일 에러가 난다. 그 이유는 타입 T 가 covariant 하기 때문에 파라미터에 사용하면 안된다. prepend 메서드가 새로운 리스트를 생성함해도 불구하고 문제가 생기는 이유는 prepend 메서드에 elem 의 타입이 T 이기 때문이다. 타입 T 가 covariant 하다면 반드시 result type 에만 사용해야 한다.&lt;/p&gt;
&lt;h3&gt;Prepend Violates LSP&lt;/h3&gt;
&lt;p&gt;prepend 메서드가 왜 Liskov Substitution Principle 을 위반했는지 알아보자
xs 의 타입이 List[IntSet]인 경우에는 문제가 없다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;xs.prepend(Empty)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;하지만 ys 의 타입이 List[NonEmpty]라고 했을 때는 문제가 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;ys.prepend(Empty)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;NonEmpty 타입이 들어와야 할 자리에 Empty 타입이 들어왔으므로 타입에러가 발생한다. 그래서 이 경우에는 List[NonEmpty]는 List[IntSet]의 서브타입이 될 수 없다.&lt;/p&gt;
&lt;p&gt;하지만 prepend 메서드는 immutable list 에 실제로 존재한다. 어떻게 이게 가능할까? 답은 lower bound 에 있다. U &gt;: T 는 U 가 T 의 부모 타입이라는 말이다. 이렇게 되면, elem 이 T 보다 상위 타입이 오더라도 문제가 되지 않는다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def prepend[U &amp;gt;: T](elem: U): List[U] = new Cons(elem, list)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4.5 Decomposition&lt;/h2&gt;
&lt;p&gt;다음과 같은 class 구조가 있다고 하자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;trait Expr {
  // classification
  def isNumber: Boolean
  def isSum: Boolean
  // accessor
  def numValue: Int
  def leftOp: Expr
  def rightOp: Expr
}

class Number(n: Int) extends Expr {
  def isNumber: Boolean = true
  def isSum: Boolean = false
  def numValue: Int = n
  def leftOp: Expr = throw new Error(&amp;quot;Number.leftOp&amp;quot;)
  def rightOp: Expr = throw new Error(&amp;quot;Number.rightOp&amp;quot;)
}

class Sum(e1: Expr, e2: Expr) extends Expr {
  def isNumber: Boolean = false
  def isSum: Boolean = true
  def numValue: Int = throw new Error(&amp;quot;Sum.numValue&amp;quot;)
  def rightOp: Expr = e1
  def leftOp: Expr = e2
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;무척 쓸모 없어 보이는 메서드들이 여럿 보인다. 일단은 더 나은 코드를 설명하기 위한 단계이므로 참고 살펴보자.
그리고 위의 클래스 구조를 evaluation 하는 간단한 인터프리터 함수인 eval 이 다음과 같다&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def eval(e: Expr): Int = {
  if (e.isNumber) e.numValue
  else if (e.isSum) eval(e.leftOp) + eval(e.rightOp)
  else throw new Error(&amp;quot;Unknown expression &amp;quot; + e)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이때 다음과 같은 코드가 있다면, 우선 eval 함수가 실행되면서 e 가 어떤 타입인지 찾기 위해 classification method 인 isSum 으로 Sum 타입인지 찾을 것이다. 그리고 그 안의 두 인자가 각각 Number 이므로 또다시 eval 함수 내에서 isNumber 에 의해 Number 타입인지 찾을 수 있을 것이다. 뭔가 비효율적으로 보인다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;eval(Sum(Number(1), Number(2))) = 3&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;여기서 만약에 아래와 같은 두개의 클래스가 추가 된다면 어떨까?&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;class Prod(e1: Expr, e2: Expr) extends Expr   // e1 * e2
class Var(x: String) extends Expr         // Variable &amp;#39;x&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 두 클래스는 Number 나 Sum 과 마찬가지로 Expr 을 상속받으므로 trait Expr 의 메서드를 모두 구현해야한다. 그리고 isNum, isSum 과 같은 클래스 타입을 찾기 위한 메서드를 2 개(isVar, isProd)더 추가해야 할 것이다. 또 var 값을 가져오기 위한 name 메서드도 추가되서 총 3 개가 추가된다. 위의 구조에서만 15 개의 메서드가 있는데, 단 2 개의 클래스만 추가하더라도 더 필요한 메서드가 25 개(Expr 에 3 개, Number 에 3 개, Sum 에 3 개, 그리고 새로운 클래스에 각각 8 개)나 된다. 이건좀 아닌거 같다.&lt;/p&gt;
&lt;p&gt;메서드를 좀 줄여보자
자바에서 사용하는 type test, type cast 메서드를 이용한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Scala           Java
x.isInstanceOf[T]     x instanceof T    // type test
x.asInstanceOf[T]     (T) x       // type cast&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;평가함수인 eval 을 조금 고쳐보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def eval(e: Expr): Int = {
  if (e.isInstanceOf[Number])
    e.asInstanceOf[Number].numValue
  else if (e.isInstanceOf[Sum])
    eval(e.asInstanceOf[Sum].leftOp) + eval(e.asInstanceOf[Sum].rightOp)
  else throw new Error(&amp;quot;Unknown expression &amp;quot; + e)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;자바에서 사용하는 타입 test 함수인 instanceof 와 타입 캐스팅 하는 방법을 적용하였다. 스칼라에서는 각각의 방법을 함수로 만들어 두었다. 이 방법을 사용하면 위에서 보았던 classification 메서드(isNum, inSum)를 사용할 필요가 없다. 대신에 타입 체크 및 캐스팅 함수가 low-level 함수이기 때문에 불안정한다는 단점이 있다.&lt;/p&gt;
&lt;p&gt;Object-Oriented Decomposition 을 이용한 또다른 해법을 살펴보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;trait Expr {
  def eval: Int
}

class Number(n: Int) extends Expr {
  def eval: Int = n
}

class Sum(e1: Expr, e2: Expr) extends Expr {
  def eval: Int = e1.eval + e2.eval
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;각각의 클래스에 eval 함수를 구현하였다. 각 클래스에 맞게 구현되기 때문에 accessor 함수들도 불필요하다. 이제 많이 깔끔해졌다. 하지만 문제는 여전히 있다. rait 에 하나의 메서드가 추가된다면, 나머지 클래스에 모두 구현해야한다는 점이다. 또다른 문제가 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;a * b + a * c = a * (b + 3)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위와 같이 축약하기 어렵다. 왜냐하면 이것은 non-local simplification 이기 때문이다. 이것은 single object 의 메서드로 캡슐화 할 수 없다. sub-tree 를 모두 테스트하고 접근해야하는 문제가 있다.&lt;/p&gt;
&lt;h2&gt;4.6 Pattern Matching&lt;/h2&gt;
&lt;p&gt;이전챕터에서 Decomposition 을 시도한 몇가지 방법은 아래와 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Classification and access methods: quadratic explosion&lt;/li&gt;
&lt;li&gt;Type tests and casts: unsafe, low-level&lt;/li&gt;
&lt;li&gt;Object-oriented decomposition: does not always work, need to touch all classes to add a new method.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;classification 과 accessor 의 주 목적은 아래와 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Which subclass was used?&lt;/li&gt;
&lt;li&gt;What were the arguments of the constructor?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;보통 사용되는 new Sum(e1, e2)와 같은 형태의 생성자를 스칼라는 case class 라는 문법을 통해서 자동으로 Pattern Matching 시켜준다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// 두개의 case class
trait Expr
case class Number(n: Int) extends Expr
case class Sum(e1:
Expr, e2: Expr) extends Expr

// 실제 apply 메서드의 형태
// Number(1), Sum(2, 3)과 같이 호출될꺼다
object Number {
  def apply(n: Int) = new Number(n)
}
object Sum {
  def apply(e1: Expr, e2: Expr) = new Sum(e1, e2)
}

// eval 함수를 이용해서 패턴매칭,
// 파라미터 e가 Number냐 Sum이냐에 따라서 자동으로 선택되어 처리
def eval(e: Expr): Int = e match {
  case Number(n) =&amp;gt; n
  case Sum(e1, e2) =&amp;gt; eval(e1) + eval(e2)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Match Syntax rules&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;match is followed by a sequence of cases, pat =&gt; expr.&lt;/li&gt;
&lt;li&gt;Each case associates an expression expr with a pattern pat.&lt;/li&gt;
&lt;li&gt;A matchError exception is thrown if no pattern matches the value of the selector.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;패턴은 Number, Sum 과 같은 contructor 로 만들어지며, 인자(variables)는 반드시 소문자로 시작해야한다. 그리고 한 pattern 안에 같은 파라미터 문자를 쓰면 안된다. 상수는 null, true, false 를 제외하고는 반드시 대문자로 시작해야한다. 마지막으로 wildcard pattern 인 ’&lt;em&gt;‘은 해당 파라미터를 신경쓰지 않겠다는 것이다. 대체로 해당 case 에서 사용되지 않는 파라미터에 ’&lt;/em&gt;‘를 사용한다.&lt;/p&gt;
&lt;p&gt;eval 함수를 trait Expr 에 넣어보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;trait Expr {
  def eval: Int = this match {
    case Number(n) =&amp;gt; n
    case Sum(e1, e2) =&amp;gt; e1.eval + e2.eval
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4.7 Lists&lt;/h2&gt;
&lt;p&gt;가장 기본적인 리스트 형태는 아래와 같이 정의할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// List(X1, ..., Xn)
val fruit: List[String] = List(&amp;quot;Apples&amp;quot;, &amp;quot;oranges&amp;quot;, &amp;quot;pears&amp;quot;)
val nums: List[Int] = List(1, 2, 3, 4)
val diag3: List[List[Int]] = List(List(1, 0, 0), List(0, 1, 0), List(0, 0, 1))
val empty: List[Nothing] = List()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;스칼라에서 List 와 Array 는 중요한 두가지 차이가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;List are immutable - the elements of a list cannot be changed&lt;/li&gt;
&lt;li&gt;Lists are recursive, while arrays are flat&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;또한 스칼라에서는 construction operation 인 ::(cons 라 부름, 지난주의 prepend 함수랑 동일하다)를 이용하여 좀더 간단하게 리스트를 만들 수 있다. cons 는 right-associative 연산이기 때문에 우측에서부터 왼쪽으로 하나씩 붙여 나간다는 생각으로 사용하면 된다. 위의 리스트 들을 cons 를 이용해서 작성해보면 다음과 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;fruit = &amp;quot;apples&amp;quot; :: (&amp;quot;oranges&amp;quot; :: (&amp;quot;pears&amp;quot; :: Nil))
fruit = &amp;quot;apples&amp;quot; :: &amp;quot;oranges&amp;quot; :: &amp;quot;pears&amp;quot; :: Nil

nums = 1 :: (2 :: (3 :: (4 :: Nil)))
nums = 1 :: 2 :: 3 :: 4 :: Nil

empty = Nil&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;right-associative 연산이기 때문에 실제 컴파일러는 위의 연산(nums)을 다음과 같이 해석한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;nums = 1 :: 2 :: 3 :: 4 :: Nil
Nils.::(4).::(3).::(2).::(1)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;sorting Lists&lt;/h3&gt;
&lt;p&gt;재귀를 이용한 Insertion Sort&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def isort(xs: List[Int]): List[Int] = {
  xs match {
    case Nil =&amp;gt; List()
    case y :: ys =&amp;gt; insert(y, isort(ys))
  }
}

def insert(x: Int, xs: List[Int]): List[Int] = {
  xs match {
    case Nil =&amp;gt; List(x)
    case y :: ys =&amp;gt; {
      if (x &amp;lt; y)  x :: xs
      else y :: insert(x, ys)
    }
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[Functional Programming in Scala week 3]]></title><description><![CDATA[3.1 Class Hierachies abstract class (추상 클래스) 추상 클래스는 abstract 키워드를 class 앞에 붙임으로써 정의할 수 있다. 추상 클래스는 구현체가 없는 추상함수를…]]></description><link>https://blueshw.github.io/2016/07/26/functional-programming-in-scala-week3/</link><guid isPermaLink="false">https://blueshw.github.io/2016/07/26/functional-programming-in-scala-week3/</guid><pubDate>Tue, 26 Jul 2016 23:26:50 GMT</pubDate><content:encoded>&lt;h2&gt;3.1 Class Hierachies&lt;/h2&gt;
&lt;h3&gt;abstract class (추상 클래스)&lt;/h3&gt;
&lt;p&gt;추상 클래스는 abstract 키워드를 class 앞에 붙임으로써 정의할 수 있다. 추상 클래스는 구현체가 없는 추상함수를 1 개 이상 멤버로 가진다. 스칼라의 추상클래스는 자바의 그것과는 달리 new 로 선언할 수가 없다(자바의 추상클래스는 new 할당 가능, 대신 인터페이스는 new 할당이 불가함).&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;abstract class IntSet {
  def incl(x: Int): IntSet
  def contains(x: Int): Boolean
}

class Empty extends IntSet {
  def incl(x: Int): IntSet = new NonEmpty(x, new Empty, new Empty)
  def contains(x: Int): Boolean = false
  override def toString = &amp;quot;.&amp;quot;
}

class NonEmpty(elem: Int, left: IntSet, right: IntSet) extends IntSet {
  def incl(x: Int): IntSet =
    if (x &amp;lt; elem) new NonEmpty(elem, left incl x, right)
    else if (x &amp;gt; elem) new NonEmpty(elem, left, right incl x)
    else this

  def contains(x: Int): Boolean =
    if (x &amp;lt; elem) left contains x
    else if (x &amp;gt; elem) right contains x
    else true

  override def toString = &amp;quot;{&amp;quot; + left + elem + right + &amp;quot;}&amp;quot;
}

val t1 = new NonEmpty(3, new Empty, new Empty)
// t1: NonEmpty = {.3.}
val t2 = t1 incl 4
//t1: NonEmpty = {.3.}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위에서 IntSet 은 Empty 와 NonEmpty 클래스의 base class 이다. 구현체가 없는 incl 메소드와 contains 메소드는 각각 Empty 와 NonEmpty 클래스에서 구현하게 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;abstract class Base {
  def foo = 1
  def bar: Int
}

class Sub extends Base {
  override def foo = 2
  def bar = 3
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Base 클래스의 foo 메서드는 구현체가 있고 bar 메서드는 구현체가 없다. 구현체가 없는 bar 메서드 같은 경우에는 Sub 클래스에서 바로 구현해주면 되지만, 구현체가 없는 foo 메서드는 반드시 메서드 앞에 override 키워드를 붙여서 재정의 해야한다.(참고로 bar 메서드 앞에 override 키워드를 붙이는 것은 optional)
자바같은 경우 메소드 오버라이드 할때는 별도의 modifier 를 지정해주지 않는다. scala 에서 이렇게 하는 이유는 override 키워드가 없는 경우에는 실제로 어떤 메서드가 오버라이드되는지 모르기 때문에 잘못된 오버라이드로 인해 Base 클래스의 메서드가 영향을 받을 수도 있기 때문이다.&lt;/p&gt;
&lt;h3&gt;object&lt;/h3&gt;
&lt;p&gt;여러개의 instance 를 만들 필요 없는 클래스 같은 경우에는 간단히 object 를 이용한다. object 정의는 class 정의와 동일하지만 new 키워드로 여러개의 instance 를 만들 수 없고 단지 하나의 object 로 작동한다(singleton object).
오직 Empty 클래스에만 object 를 쓸 수 있는데, 그 이유는 NonEmpty 클래스는 몇개의 파라미터를 가지고 있다. object 는 value 라 했으므로, object 가 정의됨과 동시에 모두 평가되어야하므로 파라미터로 인한 값의 변화를 취할수 없다.
evaluation 측면에서 보자면, 위에서도 얘기 했듯이 object 자체는 이미 value 기 때문에 아래와 같이 Empty 로 바뀐 부분이 별도의 evalutaion 과정이 불필요하다.&lt;/p&gt;
&lt;h3&gt;exercise - union 함수 구현&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;abstract class IntSet {
  def incl(x: Int): IntSet
  def contains(x: Int): Boolean
  def union(other: IntSet): IntSet
}

object Empty extends IntSet {
  ...
  def union(other: IntSet) = other
}

class NonEmpty(elem: Int, left: IntSet, right: IntSet) extends IntSet {
  ...
  def union(other: IntSet) =
    ((left union right) union other) incl elem
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;으아… 어렵다
대략 짐작해보자면, (left union right) 부분이 실행되면 left 가 현재 node 가 되고 right 가 other 가 된다. 계속해서 깊게 내려가다 보면, 언젠가 leaf node 가 나오게 되는데 leaf node 의 left 와 right 는 모두 Empty 이므로 결국 incl elem 에 의해 자기자신이 리턴된다. 그리고 한칸씩 올라오면서 left 의 elem 을 떼다가 right 트리에 include 를 시도하는 과정을 거친다. 그 과정이 계속되면, 결국은 하나의 binary tree 가 만들어진다.&lt;/p&gt;
&lt;h3&gt;동적 바인딩&lt;/h3&gt;
&lt;p&gt;메소드를 포함하는 object 타입은 런타임에 메소드가 실행된다.&lt;/p&gt;
&lt;h2&gt;3.2 How Classes Are Organized&lt;/h2&gt;
&lt;h3&gt;Package&lt;/h3&gt;
&lt;p&gt;자바의 패키지 지정 방식과 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;package progfun.examples

object Hello { ... }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위와 같은 패키지와 object 가 있다면, progfun.examples.Hello 와 같은 full qualified name 으로 Hello 오브젝트에 접근 가능하다&lt;/p&gt;
&lt;h3&gt;import&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import week3.Rational           // imports just Rational
import week3.{Rational, Hello}  // imports both Rational and Hello
import week3._                  // import everything in package week3&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;import 하는 방법은 자바와 거의 비슷한데 몇가지 다른점이 있다면, 첫째로는 한줄에 여러개의 class or object 를 호출하기 위해서 중괄호를 사용하는 방법이 있다. 그리고 특정 패키지의 모든 class 와 object 를 가져오기 위해 ’_‘를 이용할 수 있다.&lt;/p&gt;
&lt;p&gt;스칼라 프로그램에서 자동으로 import 되는 패키지 또는 obejct
All members of package scala
All members of package java.lang
All members of the singleton object scala.Predef&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;require       scala.Predef.require
assert        scala.Predef.assert&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Traits&lt;/h3&gt;
&lt;p&gt;스칼라도 자바처럼 상속을 하나의 클래스에서만 받을 수 있다. 그렇기 때문에 자바와 동일하게 여러개의 슈퍼타입이 필요한 경우 traits 키워드를 이용하여 구현할 수 있다. 참고로 trait 키워드는 abstract class 와 동일하다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;trait Planar {
  def height: Int
  def width: Int
  def surface = height  width
}

class Square extends Shape with Planar with Movable ...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;클래스와 오브젝트 traits 셋다 traits 를 상속받을 수 있다. 그리고 interface 처럼 하나의 클래스가 여러개의 traits 상속이 가능하다. traits 가 자바의 interface 와 비슷해보이지만 field 를 가질 수 있는 점과, 실제 구현 메서드를 가질 수 있는 점에서 더 강력하다 할 수 있다. 자바에도 추상클래스(abstract class)가 있지만, 추상클래스는 말그대로 클래스이기 때문에 인터페이스처럼 여러개를 구현하지는 못한다. 그렇기 때문에 스칼라의 trait 가 좀 더 유연하게 사용될 수 있다. 대신 traits 는 파라미터를 가질 수 없다는 단점이 있다.&lt;/p&gt;
&lt;h3&gt;스칼라 타입 클래스 구조 (Scala’s Class Hierarchy)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://docs.scala-lang.org/resources/images/classhierarchy.img_assist_custom.png&quot; alt=&quot;스칼라 타입 클래스 구조&quot;&gt;&lt;/p&gt;
&lt;p&gt;출처 : &lt;a href=&quot;http://docs.scala-lang.org/tutorials/tour/unified-types.html&quot;&gt;http://docs.scala-lang.org/tutorials/tour/unified-types.html&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;Any&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;모든 타입의 가장 상위 타입, ’==’, ’!=‘,&lt;/li&gt;
&lt;li&gt;‘equals’, ‘hashCode’, ‘toString’&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;AnyRef&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Any 클래스를 상속받는다.&lt;/li&gt;
&lt;li&gt;모든 레퍼런스 타입(ex. List, String)의 기본 타입이다.&lt;/li&gt;
&lt;li&gt;java.lang.Object 의 별칭이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;AnyVal&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Any 클래스를 상속받는다.&lt;/li&gt;
&lt;li&gt;모든 primitive types(Int, Float, Char 등)의 베이스 타입이다&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Scala.Nothing&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;모든 다른 AnyVal 타입의 subType 이다.&lt;/li&gt;
&lt;li&gt;값을 가지지 않는다.&lt;/li&gt;
&lt;li&gt;함수가 비정상적으로 종료되거나 예외가 발생할 경우 Nothing 을 리턴할 수 있다.&lt;/li&gt;
&lt;li&gt;비어있는 collection 을 요소 타입으로서 존재 (ex. Set[Nothing])&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Null&lt;/h3&gt;
&lt;p&gt;The type of null is Null, null 의 타입은 Null 이라는 말
모든 다른 AnyRef 타입의 subType 이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;val x = null          // x: Null
val y: String = null  // y: String
val z: Int = null     // error: type mismatch, 레퍼런스 타입만 적용&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.3 Polymorphism&lt;/h2&gt;
&lt;p&gt;아래 두 Cons 클래스는 동일한 표현이다.
클래스 파라미터에 value 를 사용하는 것은, implementaion 해야할 함수를 파라미터에 직접 구현하는 것과 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;class Cons(val head: Int, val tail: IntList) extends IntList { ... }

// 즉, _head, _tail 은 쓰지 않는 이름
class Cons(_head: Int, _tail: IntList) extends IntList {
  val head = _head
  val tail = _tail
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Cons 클래스와 List trait 를 generic 하게 구현한다&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;trait List[T] {
  def isEmpty: Boolean
  def head: T
  def tail: List[T]
}

class Cons[T](val head: T, val tail: List[T]) extends List[T] {
  def isEmpty = false
}

class Nil[T] extends List[T] {
  def isEmpty: Boolean = true
  def head: Nothing = throw new NoSuchElementException(&amp;quot;Nil.head&amp;quot;)
  def tail: Nothing = throw new NoSuchElementException(&amp;quot;Nil.tail&amp;quot;)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;함수도 제네릭하게 구현할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def singleton[T](elem: T) = new Cons(elem, new Nil[T])

singleton[Int](1)
singleton[Boolean](true)

// 아래와 같이 호출가능
singleton(1)
singleton(true)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;마지막 두 줄과 같이 호출 가능한 이유는 스칼라 컴파일러가 함수 call 이 발생하면 해당 함수의 파라미터 타입을 추론할 수 있기 때문이다.&lt;/p&gt;
&lt;h3&gt;Polymorphism&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Polymorphism means that a function type comes “in many forms”.
프로그램 측면에서 보면, 함수의 파라미터가 여러 타입으로 적용할 수 있고, 타입은 다양한 타입의 인스턴스를 가질 수 있다는 말이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;다형성의 두가지 주요개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;subtyping : instance of a subclass can be passed to a base class&lt;/li&gt;
&lt;li&gt;generics : instances of a function or class are created by type parameterization&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Functional Programming in Scala week 2]]></title><description><![CDATA[2.1 Higher-Order Functions 함수형 언어에서는 function 이 first-class value 이다. 이 말은 특정 함수가 다른 함수의 파라미터나 결과로써 return 될 수 있다는 것이다(higher order…]]></description><link>https://blueshw.github.io/2016/07/26/functional-programming-in-scala-week2/</link><guid isPermaLink="false">https://blueshw.github.io/2016/07/26/functional-programming-in-scala-week2/</guid><pubDate>Tue, 26 Jul 2016 23:25:50 GMT</pubDate><content:encoded>&lt;h2&gt;2.1 Higher-Order Functions&lt;/h2&gt;
&lt;p&gt;함수형 언어에서는 function 이 first-class value 이다. 이 말은 특정 함수가 다른 함수의 파라미터나 결과로써 return 될 수 있다는 것이다(higher order functions).&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def sum(f: Int =&amp;gt; Int, a: Int, b: Int): Int =
  if (a &amp;gt; b) 0
  else f(a) + sum(f, a+1, b)

def sumInts(a: Int, b: Int)       = sum(id, a, b)
def sumCubes(a: Int, b: Int)      = sum(cube, a, b)
def sumFactorials(a: Int, b: Int) = sum(fact, a, b)

def id(x: Int): Int = x
def cube(x: Int): Int = x * x * x
def fact(x: Int): Int = if (x == 0) 1 else x * fact(x -1)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;sum() 함수의 첫번째 파라미터로 f 라는 임의의 함수가 들어가 있다.
이는 Int 파라미터를 받아서 Int 타입을 리턴하는 함수라면 이 파라미터 위치에 적합하다라는 뜻이다. 즉, 어떠한 함수가 됐든간에 저 유형만 유지하면 된다. 재사용 가능하다는 말이다. 실제로 sumInts(), sumCubes(), sumFactorials() 함수는 모두 sum()함수를 호출한다. sum()함수의 첫번째 파라미터는 각각 id(), cube(), fact()함수를 호출하게 되는데 세 함수 모두 파라미터와 리턴 타입이 Int 이므로 sum()함수의 파라미터로 적합하다.&lt;/p&gt;
&lt;h3&gt;익명함수&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;(x: Int, y:Int) =&amp;gt; x + y&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;익명함수는 보통 함수를 선언하는 방식과는 달리 이름이 없다.
대신 파라미터 타입과 body 만 존재한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def sumCubes(a: Int, b: Int) = sum(x =&amp;gt; x * x * x, a, b)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위에서 보았던 sumCubes 의 익명함수 버전이다.
cube() 함수가 재사용되지 않는다고 가정한다면 매우 심플하기 때문에 따로 함수를 선언하기 보다는 sum() 파라미터에 익명함수로 직접 선언할수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// linear recursion, a와 b의 차이가 커지면 stackOverFlow 익셉션이 발생할 수 있다.
def sum(f: Int =&amp;gt; Int, a: Int, b: Int): Int =
  if (a &amp;gt; b) 0
  else f(a) + sum(f, a+1, b)

// tail-recursive version
def sum(f: Int =&amp;gt; Int, a: Int, b: Int): Int = {
  def loop(a: Int, acc: Int): Int = {
    if(a &amp;gt; b) acc
    else loop(a+1, f(a)+acc)
  }
  loop(a, 0)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.2 Currying&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def sumInts(a: Int, b: Int)       = sum(x =&amp;gt; x, a, b)
def sumCubes(a: Int, b: Int)      = sum(x =&amp;gt; x*x*x, a, b)
def sumFactorials(a: Int, b: Int) = sum(fact, a, b)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 함수들에서 a, b 파라미터는 sumInts(), sum()에서 반복된다. 이를 제거하여 함수를 더 간소하게 만드는 방법은 무엇일까?
우선 아래의 함수를 살펴보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def sum(f: Int =&amp;gt; Int): (Int, Int) =&amp;gt; Int = {
  def sumF(a: Int, b: Int): Int = {
    if (a &amp;gt; b) 0
    else f(a) + sumF(a+1, b)
  }
  sumF
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;기존에 봤던 sum() 함수와 조금 다르게 생겼다. 우선 sum() 함수의 파라미터가 f() 하나로 줄었고, sum() 함수는 (Int, Int) =&gt; Int 와 같은 타입의 익명함수를 리턴하고 있다.
sumF 를 호출하는 부분이 조금 이해하기 어려운데, 위의 내부함수 sumF()를 자세히 보면 익명함수를 설명했을 때의 형태와 같다는 것을 알 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;(x: Int, y: Int): Int =&amp;gt; x * y
// 이 익명함수는 아래와 같이 표현가능하다.
def f(x: Int): Int = x * y; f&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위에서 썼던 sumInts(), sumCubes(), sumFactorials() 함수들을 가져오자. 조금 다르다. sum() 함수의 파라미터가 f 하나로 줄면서 아래의 각 함수들도 sum() 호출부의 인자가 익명함수 하나만 남았다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def sumInts(a: Int, b: Int) = sum(x =&amp;gt; x)
def sumCubes(a: Int, b: Int) = sum(x =&amp;gt; x*x*x)
def sumFactorials(a: Int, b: Int) = sum(fact)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이제 sum() 함수는 함수를 리턴하고 있으므로, sumCubes(1, 10)를 호출하면&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;sumCubes(1, 10)
// res0: (Int, Int) =&amp;gt; Int = &amp;lt;function2&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이는 또한 이렇게 바꿔 쓸수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;sum (cube) (1, 10) // multiple parameters
(sum (cube)) (1, 10)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 multiple parameters 를 적용하면 sum() 함수를 더 짧게 작성할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def sum(f: Int =&amp;gt; Int)(a: Int, b: Int): Int =
  if (a &amp;gt; b) 0 else f(a) + sum(f)(a+1, b)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;여러개의 파라미터 list 를 가진 함수 f 에서 파라미터 list 의 개수가 1 보다 큰 경우 마지막 파라미터 list 를 f 함수에서 제거하면 이 마지막 파라미터 list 를 파라미터로 가지는 또다른 함수 g 를 만들 수 있다. 물론 이 g 함수는 f 함수의 리턴함수가 된다. 식으로 나타내면 다음과 같다. 참고로 각각의 식은 모두 동일하다&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def f(arg1)(arg2)(arg3)(arg4) = E
def f(arg1)(arg2)(arg3) = {def g(arg4) = E;g} // arg4를 이용해 g함수 생성
def f(arg1)(arg2)(arg3) = (arg4 =&amp;gt; E) // g를 익명함수로 변경
def f = (arg1 =&amp;gt; (arg2 =&amp;gt; (arg3 =&amp;gt; (arg4 =&amp;gt; E)))) // 파라미터를 하나씩 우측으로 전달함&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이와같은 형태의 함수정의를 curring 이라 부른다.&lt;/p&gt;
&lt;h3&gt;Excercise&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Write a product function that calculates the product of the values of a function for the points on a given interval&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def product(f: Int =&amp;gt; Int)(a: Int, b: Int): Int = {
  if (a &amp;gt; b) 1 else f(a) * product (f)(a+1, b)
}
product(x =&amp;gt; x*x)(3,4)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;Write factorial in terms of product.&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def fact(n: Int): Int = product(x =&amp;gt; x)(1, n)
fact(4)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;Can you write a more general funciton, which generalizes both sum and product?&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def mapReduce(f: Int =&amp;gt; Int, combine: (Int, Int) =&amp;gt; Int, zero: Int)(a: Int, b: Int): Int = {
  if (a &amp;gt; b) zero
  else combine(f(a), mapReduce(f, combine, zero)(a+1, b))
}

def productForMapReduce(f: Int =&amp;gt; Int)(a: Int, b: Int): Int = mapReduce(f, (x, y) =&amp;gt; x*y, 1)(a, b)
productForMapReduce(x =&amp;gt; x*x)(3, 4)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.3 Example: Finding Fixed Point&lt;/h2&gt;
&lt;p&gt;부동점 구하기, Fixed Point 라 함은 어떤 함수에서 고정적인 값을 갖는 point 를 말한다. 다음의 함수에서 2 는 부동점(고정점)이다.
기하학적으로(?) 함수 f 의 부동점은 y = x 와 주어진 함수와의 교점이다. 즉, x 와 f(x) 값이 동일한 값을 뜻한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;f(x) = x^2 -3x + 4
// 2 = 4 - 6 + 4
// 2 = 2, 부동점&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;어떤 함수에 대해서 부동점을 구하는 함수 fixedPoint 는 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;object ex {
  val tolerance = 0.0001
  def isCloseEnough(x: Double, y: Double) =
    abs((x - y) / x) / x &amp;lt; tolerance

  def fixedPoint(f: Double =&amp;gt; Double)(firstGuess: Double) = {
    def iterate(guess: Double): Double = {
      println(&amp;quot;guess = &amp;quot; + guess)
      val next = f(guess)
      if (isCloseEnough(guess, next)) next
      else iterate(next)
    }
    iterate(firstGuess)
  }
  fixedPoint(x =&amp;gt; 1 + x/2)(1)

  def sqrt(x: Double) = fixedPoint(y =&amp;gt; x / y)(1)
  sqrt(2)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;fixedPoint 를 응용해보면, 첫번째 인자인 f 함수에 어떤 수식을 넣어 반복적으로 적용하면서 고정값을 찾아 가는 과정에 맞게 넣을 수 있겠다.
마지막에 있는 것은 sqrt 를 구하는 함수는 바로 위에서 말한 반복을 통한 고정값 추론에 적합하다.
sqrt y 를 구하려면 y * y = x 가 되기 때문에 함수 y = x / y 를 fixedPoint 함수에 반복적으로 적용하다보면 고정값 sqrt 의 근사치를 구할 수 있다.
하지만, 실제로 위와같이 y =&gt; x / y 를 fixedPoint 의 함수 인자로 넣게 되면, 원하는 값을 얻지 못한다.
왜냐하면, guess 값이 너무 심하게 변하기 때문에 발생하는 문제다. fixedPoint 의 내부함수 iterate 는 guess 와 next 가 교차하는 구조인데, 처음 sqrt(2)에서 2 는 x 이다.
그리고 y 는 firstGuess 인 1 이되는데, 이 두 값이 f(x) = x / y 에 대입되면, f(x)는 2 가 된다. 다시 y 가 2 가 되고 x 가 2 이므로 iterate 함수를 한번 돌면 y 는 1 이된다.
즉, 1,2,1,2 반복하기 때문에 무한루프에 빠지게 된다.
이를 해결하기 위해서는 연속하는 두개의 값 즉 1 과 2 의 평균값(1.5)를 구함으로써 해결할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;y =&amp;gt; x / y
// 아래와 같이 바꿔 쓴다.
y =&amp;gt; (y + x/y) / 2

// 코드에 적용해보면
def sqrt(x: Double) = fixedPoint(y =&amp;gt; (y + x / y) / 2)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위와 같이 평균을 내어서 안정화 시키는 기법을 AverageDamp 라고 한다.&lt;/p&gt;
&lt;h2&gt;2.4 Scala Syntax Summary&lt;/h2&gt;
&lt;p&gt;강의 참고&lt;/p&gt;
&lt;h2&gt;2.5 Functions and Data&lt;/h2&gt;
&lt;p&gt;유리수의 여러가지 연산을 바탕으로 함수를 만드는 방법과 데이터를 캡슐화하기 위해 클래스를 사용하는 방법을 알아 본다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// class
class Rational(x: Int, y: Int) {
  def numer = x
  def denom = y

  def add(that: Rational) =
    new Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom)
}

// object
val x = new Rational(1, 2)
x.numer  // 1
y.denom  // 2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위에서 Rational 클래스를 정의하였다. 클래스를 정의하면 두가지 요소가 정의되는데, 첫번째는 Rational 이라는 type 이 만들어진다는 것이고, 두번째는 x 와 y 를 인자로 가지는 Rational 이라는 생성자가 만들어진다는 것이다.
object 를 만드는 법은 Java 의 object 만드는 법과 동일하게 new 키워드를 사용해서 만들 수 있다.&lt;/p&gt;
&lt;h3&gt;Method&lt;/h3&gt;
&lt;p&gt;스칼라에서 함수(funciton)과 메소드(method)는 다른 의미로 사용되는데, 일반적으로 함수는 독립적인 객체로서 클래스처럼 인스턴스화 가능한 형태로 동작하는 반면, 메소드는 클래스내에 속하는 멤버로써 클래스 내의 데이터를 연산하는 역할을 한다. 실제 컴파일 해보면 차이를 알 수 있는데, 함수같은 경우에는 클래스로 변경되어 있지만(내부 함수인 경우에는 내부 클래스로 컴파일), 메소드는 컴파일 내에 멤버로만 존재하기 때문에 별도의 class 로 컴파일 되지 않는다.&lt;/p&gt;
&lt;h3&gt;Exerxise&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;In your worksheet, add a method neg to class Rational that is used like this: x.neg&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Add a method sub to subtract two rational numbers.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;With the values of x, y, z as given in the previous slide, what is the result of x - y - z&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;class Rational(x: Int, y: Int) {
  def numer = x
  def denom = y

  def add(that: Rational) =
    new Rational(
      numer * that.denom + denom * that.numer,
      denom * that.denom)

  def neg: Rational = new Rational(numer * -1, denom)
  def sub(that: Rational): Rational = add(that.neg)
  override def toString = numer + &amp;quot;/&amp;quot; + denom
}

val x = new Rational(1, 3)
val y = new Rational(5, 7)
val z = new Rational(3, 2)

x.sub(y).sub(z) // res0: Rational = -79/42&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.6 More Fun With Rationals&lt;/h2&gt;
&lt;p&gt;2.5 에서 구현한 Rational 클래스는 분모와 분자를 나누어진 형태로 출력하지 않는 문제가 있다. 그래서 이전에 사용했었던 최대 공약수를 구하는 함수인 gcd 를 메서드 형태로 Rational 클래스에 추가해준다.
그리고 클래스의 인수인 x 와 y 에 두 변수의 gcd 값을 나누어준다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;class Rational(x: Int, y: Int) {
  private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)

  // ex 1) g를 재사용하는 방법
  private val g = gcd(x, y)
  def numer = x / g
  def denom = y / g

  // ex 2) numer와 denom이 자주 호출되지 않을때는 gcd를 직접 넣어줌
  def numer = x / gcd(x, y)
  def denom = y / gcd(x, y)

  // ex3) 이 두 변수는 한번만 연산하도록 하기 위해 메서드를 value로 변경, numer와 denom이 자주 call 되는 경우에 적합
  val numer = x / gcd(x, y)
  val denom = y / gcd(x, y)

  ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;this&lt;/h3&gt;
&lt;p&gt;this 키워드는 java 와 동일하게 사용된다. this 는 현재 메소드가 실행되고있는 object 를 말한다. second 생성자를 만들때에도&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def this(x: Int) = this(x, 1)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;과 같이 사용한다.&lt;/p&gt;
&lt;h3&gt;require 키워드&lt;/h3&gt;
&lt;p&gt;require 키워드를 사용하면 클래스의 인자값 등에 대한 제약을 만들 수 있다. 아래의 클래스가 있는 상태에서 만약에 new Rational(1, 0)과 같은 instance 를 생성하게 되면 예외가 발생하게 된다. require 와 같이 객체가 생성될때 강제로 호출하는 역할을 하는 함수를 predefined funciton 이라고 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;class Rational(x: Int, y: Int) {
  require(y != 0, &amp;quot; denominator must be positive&amp;quot;)
  ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.7 Evaluation and Operators&lt;/h2&gt;
&lt;p&gt;클래스와 메소드의 evalutaion 과정&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;class C(x1, ..., xm) {... def f(y1, ..., yn) = b ...}
new C(v1, ..., vm).f(w1, ..., wn)

// substitution
[w1/y1, ... wn/yn][v1/x1, ..., vm/xm][new C(v1, ..., vm)/this]b&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;과정을 간단히 요약하면&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;f 메서드의 formal parameters(y1, …, yn)이 arguments(w1, …, wn)으로 치환&lt;/li&gt;
&lt;li&gt;클래스의 formal parameters(x1, …, xm)이 arguments(v1, …, vm)으로 치환&lt;/li&gt;
&lt;li&gt;self reference this 가 new C(v1, …, vm)으로 치환&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;만약 f 함수 내부에서 this 가 사용된다고 가정한다면, 이 this 는 이미 new C(v1, …, vm)으로 치환된 value 이므로, 해당 object 자체를 참조하는 값이 된다.&lt;/p&gt;
&lt;h3&gt;Operators&lt;/h3&gt;
&lt;p&gt;일반적인 언어에서는 r.add(s)와 같은 함수가 호출될때 자연수인 경우에는 r + s 와 같이 바꿔 쓸 수 있지만, 유리수의 경우에는 불가하다.
하지만 스칼라에서는 오퍼레이터 기호를 함수 이름으로 사용가능하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;step 1 : r.add(s) ==&gt; r add s&lt;/li&gt;
&lt;li&gt;step 2 : def + (that: Rational) = { … }&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;하지만 위와 같이 함수 이름을 오퍼레이터로 사용하게 되면, 우선순위 문제가 발생할 수 있다.
그래서 스칼라에서는 precedence rules 을 별도로 만들어 두었다.
우선순위는 아래가 제일 높고 위로 갈수록 낮아진다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;(all letters)
|
^
&amp;amp;
&amp;lt; &amp;gt;
= !
:
+ -
* / %
(all other special characters)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[Functional Programming in Scala week 1]]></title><description><![CDATA[1.1 Programming Paradigms 세 가지 프로그래밍 언어 패러다임 Inperative Programming Language (절차지향 프로그래밍 언어) Functional Programming Language…]]></description><link>https://blueshw.github.io/2016/07/26/functional-programming-in-scala-week1/</link><guid isPermaLink="false">https://blueshw.github.io/2016/07/26/functional-programming-in-scala-week1/</guid><pubDate>Tue, 26 Jul 2016 00:43:50 GMT</pubDate><content:encoded>&lt;h2&gt;1.1 Programming Paradigms&lt;/h2&gt;
&lt;p&gt;세 가지 프로그래밍 언어 패러다임&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Inperative Programming Language (절차지향 프로그래밍 언어)&lt;/li&gt;
&lt;li&gt;Functional Programming Language (함수형 프로그래밍 언어)&lt;/li&gt;
&lt;li&gt;Logical Programming Language (논리형 프로그래밍 언어)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;튜터는 OOP 는 세가지 언어에 직교하는 성질을 가지고 있기 때문에 새로운 패러다임이라 할 수 없다고 생각함
절차적 프로그램은 폰 노이만 구조랑 비슷함
절차적 프로그램은 규모가 커졌을 경우 word by word 로 처리되는 문제 때문에 폰 노이만처럼 병목현상이 발생할 수 있다.
그래서 collections, 다항식, strings 등과 같이 고수준의 추상화를 정의하는 진화된 다른 방법(theory)이 필요&lt;/p&gt;
&lt;h3&gt;What is Theory?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;one or more data types&lt;/li&gt;
&lt;li&gt;operations on thes types&lt;/li&gt;
&lt;li&gt;laws that describe the relationships between values and operations
즉, 여러개의 데이터 타입과 연산과 그 관계에 대한 규칙의 정의라 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;절차적 언어는 함수나 특정 코드에 의해 상태값이 바뀔 수 있기 때문에 theory 가 손상될수 있다. 이러한 문제를 해결하기 위해 함수형 언어가 등장하였다. 함수형 언어는 아래와 같은 특징을 가진다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;concentrate on defining theories for operators expressed as functions&lt;/li&gt;
&lt;li&gt;avoid mutations&lt;/li&gt;
&lt;li&gt;have powerful ways to abstract and compose functions&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;1.2 Elements of Programming&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;call by value : 인자가 먼저 평가되는 방식&lt;/li&gt;
&lt;li&gt;call by name : 인자가 나중에 평가 되는 방식&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;sumOfSquares(3, 2+2)

sumOfSquares(3, 4) // call by value
sumOfSquares(3, 2+2) // call by name&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위와 같은 함수가 있을때, 2+2 가 먼저 계산되어 인자가 4 로 evaluation 된 후 reduce 되면 call by value, 2+2 가 이름(name) 그대로 reduce 되면 call by name 이라 할 수 있다. call by value 의 장점은 모든 함수의 인자가 한번만 해석된다는 것이다. 반면에 call by name has the advantage that a function argument is not evaluated if the corresponding parameter is unused in the evaluation of the function body.&lt;/p&gt;
&lt;p&gt;다음의 예를 보면 이해가 간다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;call by name
test(3+4,2*4)
// (3+4) * (3+4)
// 7 * (3+4)
// 7 * 7
// 49

call by value
test(3+4,2*4)
// test(7,2*4)
// test(7,8)
// 7 * 7
// 49&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1.3 Evaluation Strategies and Termination&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def first(x: Int, y: Int) = x
first(1, loop)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;first 함수를 호출하게 되면 CBN 같은 경우는 인자를 해석하지 않고 바로 1 을 출력하겠지만, CBV 인 경우에는 loop 인자를 해석하기 위해서 무한루프에 빠지게 된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;스칼라는 기본적으로 CBV 를 사용&lt;/li&gt;
&lt;li&gt;함수 파라미터가 =&gt;로 시작하면 CBN 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;1.4 Conditionals and Value Definitions&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def loop: Boolean = loop
def x = loop
val x = loop // infinite loop&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;def 는 우측의 loop 가 해석되지 않는다. 반면에 val(value)는 우측의 코드를 해석하기 때문에 위와 같은 코드의 경우 무한루프에 빠지게 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;and(x,y) == x &amp;amp;&amp;amp; y
def and(x: Boolean, y: Boolean)
  if (x) y else false
// and(x, loop)와 같은 문제가 발생할 수 있으므로, 아래와 같이 변경
def and(x: Boolean, y: =&amp;gt; Boolean)
  if (x) y else false&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;그런데 왜 y 만 CBN 으로 변경해 줬을까? and(loop, b)하면 어떻게될까?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;1.5 Example: square roots with Newton’s method&lt;/h2&gt;
&lt;p&gt;뉴튼 메소드를 이용해서 제곱근을 구하는 예제를 작성해본다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;한가지 주의할점은 스칼라에서 recursive(재귀) 함수인 경우에는 반드시 return 타입을 정해주어야 한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def abs(x: Double) = if (x &amp;lt; 0) -x else x

def sqrtIter(guess: Double, x: Double): Double =
  if (isGoodEnough(guess, x)) guess
  else sqrtIter(improve(guess, x), x)

def isGoodEnough(guess: Double, x: Double) =
  abs(guess * guess - x) / x &amp;lt; 0.001

def improve(guess: Double, x: Double) =
  (guess + x / guess) / 2

def sqrt(x: Double) = sqrtIter(1.0, x)

sqrt(2) // res1: Double = 1.4142156862745097&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1.6 Bolcks and Lexical Scope&lt;/h2&gt;
&lt;p&gt;block 을 잘 이용하면 불필요한 인자값을 호출하는 메서드에 넘길 필요가 없다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def abs(x: Double) = if (x &amp;lt; 0) -x else x

def sqrt(x: Double) = {
  def sqrtIter(guess: Double): Double =
    if (isGoodEnough(guess)) guess
    else sqrtIter(improve(guess))

  def isGoodEnough(guess: Double) =
    abs(guess * guess - x) / x &amp;lt; 0.001

  def improve(guess: Double) =
    (guess + x / guess) / 2

  sqrtIter(1.0)
}

sqrt(2) // 동일한 결과값&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 예제를 보면, sqrt(x)에서 호출된 이후 내부적으로 sqrIter, isGoodEnough, improve 를 호출하는데 모두 x 파라미터를 인자값으로 전달해준다. x 파라미터는 각 함수에서 불변하는 값이므로 위 세함수를 sqrt 함수의 내부함수로 재작성 한뒤 블록으로 감싸주면 x 파라미터는 블록 범위내에서 동일하게 적용되는 값이 되므로 각 함수에서 파라미터를 제거할 수 있다.&lt;/p&gt;
&lt;h3&gt;세미콜론 문제&lt;/h3&gt;
&lt;p&gt;스칼라에서 세미콜론은 optional
그래서 아래와 같은 코드가 작성되면 한 줄로 인식되어야 할 코드를 스칼라 인터프리터가 두줄로 인식해버리는 문제가 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;someLongExpression
+ someOtherExpression&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;해결 방법은 두가지가 있는데, 첫째는 괄호로 묶어주는 방법이고 두번째는 ’+’ 기호를 윗줄의 끝에 기입해주는 방법이다(아직 문장이 안끝났다는 표시).&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// solution 1
(someLongExpression
+ someOtherExpression)

// solution 2
someLongExpression +
someOtherExpression&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1.7 Tail Recursion&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def gcd(x: Int, y: Int): Int =
  if (y == 0) x else gcd(y, x % y)

def factorial(n: Int): Long =
  if (n == 0) 1 else n * factorial(n-1)

// 강의와 조금 다름
def fac_tail_recursive(n: Int): Int = {
  def loop(r: Int, i: Int): Int =
    if (n == i) r*i
    else
      loop(r*i, i+1)
  loop(1, 1)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;gcd 함수의 계산과정을 살펴보면, gcd 함수 자체가 다시 불리는 형태로 진행한다. 반면에 fatorial 함수는 4 _ 3 _ factorial(2)와 같이 계속해서 길어지므로, 저장해야 할 지역변수가 늘어나 stack frame 을 재사용할 수 없다. 그래서 factorial 을 fac&lt;em&gt;tail&lt;/em&gt;recursive 함수처럼 함수 자신이 마지막으로 호출되는 형태로 변경해줄 필요가있다. 이를 Tail Recursion 이라 부른다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[[django] Mixin을 이용한 View 확장하기]]></title><description><![CDATA[장고 프로젝트는 다양한 방법으로 구현이 가능합니다.
그 중에서 view…]]></description><link>https://blueshw.github.io/2016/03/08/django-extend-view-using-mixin/</link><guid isPermaLink="false">https://blueshw.github.io/2016/03/08/django-extend-view-using-mixin/</guid><pubDate>Tue, 08 Mar 2016 23:17:30 GMT</pubDate><content:encoded>&lt;p&gt;장고 프로젝트는 다양한 방법으로 구현이 가능합니다.
그 중에서 view 에서 처리할 수 있는 방법으로 크게 두 가지가 있는데,
하나는 함수를 기반으로 만드는 방법, 그리고 또 한가지는 클래스를 기반으로 만드는 방법입니다.&lt;/p&gt;
&lt;p&gt;지금까지 장고를 사용하면서 느꼈던 두 방법의 차이점은(지극히 개인적인 견해입니다),
함수를 기반으로 만드는 방법은 쉽고 빠르게 만들 수 있지만 확장성이 떨어지고,
클래스를 기반으로 만드는 방법은 함수를 기반으로 만드는 방법에 비해서 시간이 좀 더 필요하지만 확장성 면에서는 훨씬 뛰어나다는 것입니다.
그 중 클래스 기반의 방법의 확장성을 극대화 시켜주는 녀석이 바로 Mixin 이라는 놈입니다.
Mixin 이라는 개념은 루비와 같은 타 언어에서도 많이 쓰이고 있는데, 클래스에 부가적인 기능이나 정보를 추가해주기 위한 모듈을 뜻합니다.
함수 기반으로 만든 앱 같은 경우에 추가적인 기능이 필요하면 코드를 직접 구현하거나, 함수를 덧붙이는 형태가 되야할 것입니다.
반면에 클래스의 경우에는 추가적인 기능이 필요하때 Mixin 을 추가하면 간단히 해결됩니다.
몇 개를 추가해도 상관없으며 클래스에 의존적이지 않기 때문에 확장성 면에서 굉장히 자유롭다 할 수 있습니다.&lt;/p&gt;
&lt;p&gt;루비 언어에서의 믹스인은 다중 상속이 지원되지 않아 이를 해결하기 위한 방안으로 등장했다고 볼 수 있는데요.
파이썬처럼 다중상속이 지원되는 언어에서 굳이 Mixin(실제로는 다중상속)이라는 개념이 따로 있는 이유는,
다중상속이 주는 모호함을 피하기 위함이라는 생각이듭니다.
명확하게 기능을 암시하는 이름(mixin)을 줌으로써 상속받는 클래스와 혼동하지 않도록 하는 것이죠.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;class FirstMixin(object):
    def test1(self):
        print(&amp;quot;first mixin!!!&amp;quot;)


class SecondMixin(object):
    def test2(self):
        print(&amp;quot;second mixin!!!&amp;quot;)


class TestClass(ParentClass, FirstMixin, SecondMixin):
    pass&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 코드에서도 알 수 있듯이 믹스인이라는 것은 상속받는 ParentClass 와 다를 것 없는 클래스입니다.
이렇게 TestClass 는 실제로 ParentClass, FirstMixin, SecondMixin 이라는 세가지 클래스를 상속하는 것이지만,
ParentClass 를 상속하고 FirstMixin 과 SecondMixin 의 기능을 추가로 확장한 것이라 말할 수 있습니다.&lt;/p&gt;
&lt;p&gt;그렇다면, 장고(django)에서는 믹스인을 어떻게 사용하고 있을까요?
대표적으로 View 같은 경우가 믹스인을 많이 사용하고 있는데요.
예를 한번 살펴보겠습니다.&lt;/p&gt;
&lt;h3&gt;views.py&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;from django.views.generic import TemplateView


class TestTemplateView(TemplateView):
    template_name = &amp;quot;test.html&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;views.py 는 urls.py 에서 호출되는 url 에 매핑된 클래스(또는 메서드)를 모아놓은 파일입니다
(기본파일일뿐 반드시 views.py 에 있을 필요는 없습니다.)
보통 클래스들은 View 를 상속받아서 나머지 코드를 구현하지만,
장고는 개발자들의 편의를 위해 몇가지 유용한 View 를 만들어 두었습니다.&lt;/p&gt;
&lt;p&gt;가장 쉬운 예로 TemplateView 라는 클래스가 있습니다.
이 클래스는 template_name 이라는 변수에 template 파일명(또는 패스)만 넣어주면,
클라이언트로부터 호출된 요청을 처리할 수 있습니다.
별다른 로직은 없고 다만, 해당 temlate 으로 화면을 이동하는 역할을 할 뿐입니다.&lt;/p&gt;
&lt;p&gt;어떻게 이런게 가능한지를 보기위해 TemplateView 를 열어봅니다.&lt;/p&gt;
&lt;h3&gt;generic/base.py&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;class TemplateView(TemplateResponseMixin, ContextMixin, View):
    &amp;quot;&amp;quot;&amp;quot;
    A view that renders a template.  This view will also pass into the context
    any keyword arguments passed by the url conf.
    &amp;quot;&amp;quot;&amp;quot;
    def get(self, request, *args, **kwargs):
        context = self.get_context_data(**kwargs)
        return self.render_to_response(context)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;주석을 대충 해석해보면,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;template 을 그려주는 view 이다. 또한 이 view 는 url conf 를 통해서 kwargs 에 어떠한 값이라도 context 를 추가해줄수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;TemplateView 는 위와 같이 세가지 클래스를 상속받고 있습니다.
TempalteResponseMixin, ContextMixin 그리고 View 입니다.
여기에 바로 우리가 찾고 있던 mixin 이 있습니다!!&lt;/p&gt;
&lt;p&gt;기본적으로 사용되는 View 에다가 기능을 확장하기 위해 두가지 mixin 을 덧붙였습니다.
그럼 각 믹스인이 어떤 역할을 하는지 살펴보겠습니다.&lt;/p&gt;
&lt;h3&gt;TemplateResponseMixin&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;class TemplateResponseMixin(object):
    template_name = None
    template_engine = None
    response_class = TemplateResponse
    content_type = None

    def render_to_response(self, context, **response_kwargs):
        response_kwargs.setdefault(&amp;#39;content_type&amp;#39;, self.content_type)
        return self.response_class(
            request=self.request,
            template=self.get_template_names(),
            context=context,
            using=self.template_engine,
            **response_kwargs
        )

    def get_template_names(self):
        if self.template_name is None:
            raise ImproperlyConfigured(
                &amp;quot;TemplateResponseMixin requires either a definition of &amp;quot;
                &amp;quot;&amp;#39;template_name&amp;#39; or an implementation of &amp;#39;get_template_names()&amp;#39;&amp;quot;)
        else:
            return [self.template_name]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;TemplateView 에서&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;return self.render&lt;em&gt;to&lt;/em&gt;response(context)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;위의 부분이 호출하면, 실제로 TemplateResponseMixin 클래스의 render&lt;em&gt;to&lt;/em&gt;response(context)가 호출됩니다.
이 메서드는 request, template, context 등을 세팅한 다음 TemplateResponse 클래스를 리턴하게 됩니다.
TemplateResponse 클래스에 대해서 자세히 설명하진 않겠지만,
간략히 설명하면 get 메서드에서 리턴할때 template 과 context 를 실어서 클라이언트에 응답을 보내는 역할을 합니다.&lt;/p&gt;
&lt;p&gt;결과적으로 TemplateView 에서는 template 변수만 설정하면(request 는 get 메서드에서 가져옴, context 는 ContextMixin 에서 가져옴)
응답에 필요한 모든 값을 설정하여 클라이언트에 응답을 보낼수 있게 되는 것입니다.&lt;/p&gt;
&lt;h3&gt;ContextMixin&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;class ContextMixin(object):
    def get_context_data(self, **kwargs):
        if &amp;#39;view&amp;#39; not in kwargs:
            kwargs[&amp;#39;view&amp;#39;] = self
        return kwargs&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;TemplateResponseMixin 에서 설명했듯이 context 를 가져오기 위한 역할을 하는것이 ContextMixin 입니다.
context 는, 클라이언트에 응답을 보낼 때 keyword argument(dict)로 값을 실어서 보낼 수 있는 역할을 하는 변수입니다(이름도 바꿀 수 있음).
TemplateView 의 구현부분을 살펴보면,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;context = self.get&lt;em&gt;context&lt;/em&gt;data(**kwargs)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;바로 이 부분을 통해서 context 를 생성하여 클라이언트에 보낼 수 있게 됩니다.
만약 views.py 구현부에서 추가적으로 context 에 추가할 필요가 있을때는
아래처럼 오버라이딩하여 context 를 추가해주면 됩니다.&lt;/p&gt;
&lt;h3&gt;views.py - 2&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;from django.views.generic import TemplateView


class TestTemplateView(TemplateView):
    template_name = &amp;quot;test.html&amp;quot;

    def get_context_data(self, **kwargs):
        context = super(TestTemplateView, self).get_context_data(**kwargs)
        context[&amp;#39;extra_value&amp;#39;] = 100
        return context&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;믹스인은 사용함에 따라서 거의 무한하게 확장할 수 있습니다.
TemplateView 와 같이 기능이 단순한 경우에는 두개 정도의 믹스인만 사용되었지만,
ListView 같은 View 들은 TemplateView 보다 다양하고 복잡한 믹스인을 사용하여 기능을 확장시켰습니다.
검색해보면, ListView 외에도 대부분의 확장된 View 들이 믹스인을 확장하여 다양한 기능을 가지는 View 를 만들어 내고 있습니다.&lt;/p&gt;
&lt;p&gt;이처럼 믹스인을 잘 이용하면 자기 입맛에 딱 맞는 CustomView 를 만드는데 큰 도움이 될 수 있습니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[[django] 테스트DB 없이 유닛테스트(unit test)하기]]></title><description><![CDATA[…]]></description><link>https://blueshw.github.io/2016/03/06/django-unit-test-without-testdb/</link><guid isPermaLink="false">https://blueshw.github.io/2016/03/06/django-unit-test-without-testdb/</guid><pubDate>Sun, 06 Mar 2016 23:33:43 GMT</pubDate><content:encoded>&lt;p&gt;장고 프로젝트 역시 다른 웹 프레임워크와 마찬가지로 모듈의 로직을 검증하기 위한 유닛테스트가 존재합니다.
테스트를 위한 추가적인 모듈을 설치해서 좀더 편리하게 유닛테스트를 진행할 수도 있지만,
일단은 장고에서 기본적으로 지원하는 테스트 기능을 이용해서 테스트 해보았습니다.&lt;/p&gt;
&lt;p&gt;그런데, 장고에서 유닛테스트를 진행해보면, 한가지 문제가 발생합니다.
바로 검증 데이터를 저장하기 위한 테스트 DB 를 생성한다는 점인데요.&lt;/p&gt;
&lt;p&gt;저도 사실 이 테스트 DB 가 생성되는 이유는 잘 모르겠습니다.
테스트 DB 가 새로운 테스트를 실행될 때마다 매번 지워졌다 새로 생성 되기 때문이죠.
만약 테스트 데이터를 보존해서 테스트 결과를 누적하기 위함이라면 몰라도 실행할 때마다 사라지는 테스트 DB 를 굳이 만들어 내는 이유가 무엇인지 궁금하네요.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;proj/
	app/
		migrations/
		__init__.py
		admin.py
		models.py
		tests.py
		views.py&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;앱을 새로 만들게 되면 위와 같이 다섯 개의 파일과 migrations 라는 폴더가 생성됩니다.
그 중에서 tests.py 파일이 바로 테스트 코드를 작성할 파일입니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import unittest

class UnitTest(unittest.TestCase):
def test(self):

	...

	self.assertEqual(x, y)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위와 같이 테스트 코드를 작성한 후 테스트를 실행해봅니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;python managy.py test&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그러면, 아래와 같은 결과 화면을 볼 수 있습니다.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/1-8c7e393cf5d050c3e995b37c984ac4ec-57246.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 29.651162790697672%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAGABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAIDBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAcaAVg//xAAXEAADAQAAAAAAAAAAAAAAAAAAAREQ/9oACAEBAAEFAox3P//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABUQAQEAAAAAAAAAAAAAAAAAABAx/9oACAEBAAY/Aq//xAAXEAADAQAAAAAAAAAAAAAAAAAAAREh/9oACAEBAAE/IXqEVWlp/9oADAMBAAIAAwAAABDzz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABgQAQEBAQEAAAAAAAAAAAAAAAERAFGh/9oACAEBAAE/EII9Os1hxcpVbv/Z&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;img1&quot;
        title=&quot;&quot;
        src=&quot;/static/1-8c7e393cf5d050c3e995b37c984ac4ec-f8fb9.jpg&quot;
        srcset=&quot;/static/1-8c7e393cf5d050c3e995b37c984ac4ec-e8976.jpg 148w,
/static/1-8c7e393cf5d050c3e995b37c984ac4ec-63df2.jpg 295w,
/static/1-8c7e393cf5d050c3e995b37c984ac4ec-f8fb9.jpg 590w,
/static/1-8c7e393cf5d050c3e995b37c984ac4ec-57246.jpg 860w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;Creating test database 이후, Destroying test database 를 진행합니다.
장고의 모델과 실제 DB 의 sync 가 잘 맞는 경우에는 위처럼 테스트 DB 가 만들어 졌다가 테스트 완료 후 삭제해도 아무 문제가 없지만,
기존 프로젝트를 장고로 마이그레이션 했거나 실제 데이터와 장고 모델을 다르게 사용하는 경우(불필요한 조인 미등록 등)에는
유닛테스트로 만들어진 DB 가 실제 DB 와 차이가 있어 테스트가 실패하는 경우가 발생할 수 있습니다.&lt;/p&gt;
&lt;p&gt;이런 문제 때문에 장고에서도 테스트 DB 가 생성되지 않는 방법으로 유닛테스트를 진행할 필요가 있습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;proj/
	app/
	common/    # 프로젝트 생성시 기본으로 생성되는 폴더
		__init__.py
		settings.py
		urls.py
		wsgi.py
		settings_test.py    # 추가
		test_runner.py    # 추가&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;프로젝트를 만들게 되면, 기본적으로 setting 과 url 등을 다루기 위한 기본 파일들이 생성됩니다.
여기에 DB 생성을 막기 위해서 test&lt;em&gt;runner.py 와 setting&lt;/em&gt;test.py 두 파일을 만들어 줍니다.&lt;/p&gt;
&lt;h3&gt;test_runner.py&lt;/h3&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/2-7a10b14d88622d75bc71e924b3869a63-3f0b4.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 63.53658536585366%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAMCBAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAFCNZRMtB//xAAbEAACAgMBAAAAAAAAAAAAAAACAwABBBITFP/aAAgBAQABBQJrDpnU5imVrPE2LwxKOY//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAgEAACAAUFAQAAAAAAAAAAAAAAAQIREjEyISJRYZGh/9oACAEBAAY/Aot7vyZxejnE3qN136M/hKqZ/8QAGxABAAICAwAAAAAAAAAAAAAAAQARMVFhofH/2gAIAQEAAT8hAAS3ae8iIxu8EG2Flim8CuY3if/aAAwDAQACAAMAAAAQEA//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAcEAEAAgIDAQAAAAAAAAAAAAABABEhQVFh0fH/2gAIAQEAAT8QOVDoVGXcdAQLhECq1B94iaW3zPnfYbnZs10HPU//2Q==&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;img2&quot;
        title=&quot;&quot;
        src=&quot;/static/2-7a10b14d88622d75bc71e924b3869a63-f8fb9.jpg&quot;
        srcset=&quot;/static/2-7a10b14d88622d75bc71e924b3869a63-e8976.jpg 148w,
/static/2-7a10b14d88622d75bc71e924b3869a63-63df2.jpg 295w,
/static/2-7a10b14d88622d75bc71e924b3869a63-f8fb9.jpg 590w,
/static/2-7a10b14d88622d75bc71e924b3869a63-3f0b4.jpg 820w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;test_runner.py 파일에는 장고 유닛테스트에서 사용되는 runner 를 재정의하는 클래스인 TestRunner 를 정의합니다.
TestRunner 클래스가 상속받는 DiscoverRunner 클래스가 바로 테스트 DB 를 생성을 담당하는 클래스입니다.
새롭게 정의한 TestRunner 에서 위의 세 메서드를 재정의하여 비어두면, 테스트 시 테스트 DB 의 생성이 없어도 테스트가 가능해집니다.&lt;/p&gt;
&lt;h3&gt;settings_test.py&lt;/h3&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/3-05d951d17fa93cb459312a3b45a6c37b-3f0b4.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 63.53658536585366%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAMEAgX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAGdHXUbKg//xAAbEAACAgMBAAAAAAAAAAAAAAACAwABBBITFP/aAAgBAQABBQJrDo+rJimVrPE2LwxKOY//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAfEAACAAYDAQAAAAAAAAAAAAAAAQIREjEyUSEikaH/2gAIAQEABj8Ci7O+zOL0c4m+Ruu70Z/CVUz/xAAcEAEAAgIDAQAAAAAAAAAAAAABABExUSFhofH/2gAIAQEAAT8hrI+XqfYRGY3eiDbCxim8CuY3if/aAAwDAQACAAMAAAAQkM//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAeEAEAAgEEAwAAAAAAAAAAAAABABEhQVFhwdHw8f/aAAgBAQABPxALODAdGXM9K7hYIi1WoPvEDRbe8+d8w3OzZroG/E//2Q==&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;img3&quot;
        title=&quot;&quot;
        src=&quot;/static/3-05d951d17fa93cb459312a3b45a6c37b-f8fb9.jpg&quot;
        srcset=&quot;/static/3-05d951d17fa93cb459312a3b45a6c37b-e8976.jpg 148w,
/static/3-05d951d17fa93cb459312a3b45a6c37b-63df2.jpg 295w,
/static/3-05d951d17fa93cb459312a3b45a6c37b-f8fb9.jpg 590w,
/static/3-05d951d17fa93cb459312a3b45a6c37b-3f0b4.jpg 820w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;settings&lt;em&gt;test.py 은 settings.py 의 모든 항목을 가져옴과 동시에,
test&lt;/em&gt;runner.py 파일에서 정의한 TestRunner 클래스를 테스트 러너로 지정하는 파일입니다.&lt;/p&gt;
&lt;p&gt;위의 두 파일을 생성하면 이제 준비는 끝났습니다.
이제 다시한번 테스트를 진행해 보겠습니다.
처음 실행했던 테스트 명령과는 조금 달라졌습니다.
테스트를 진행할 구체적인 앱을 지정해 주었고(test1), TestRunner 를 재지정한 settings_test.py 를 테스트를 위한 환경으로 지정해주었습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;python manage.py test test1 --settings=&amp;#39;unit_test.settings_test&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;아래와 같은 결과를 출력합니다.
위에서 처럼 Creating test database 와 Destroying test database 과정이 없는 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/4-95615a44bce73342a5a28cfe20460940-6bec7.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 15.055079559363524%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAADABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAcKoQD//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAEFAn//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAY/An//xAAXEAEBAQEAAAAAAAAAAAAAAAABABEx/9oACAEBAAE/IWV3tt//2gAMAwEAAgADAAAAEPPP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGhAAAgMBAQAAAAAAAAAAAAAAAAERUZEhMf/aAAgBAQABPxBnb9skOtJW9P/Z&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;img4&quot;
        title=&quot;&quot;
        src=&quot;/static/4-95615a44bce73342a5a28cfe20460940-f8fb9.jpg&quot;
        srcset=&quot;/static/4-95615a44bce73342a5a28cfe20460940-e8976.jpg 148w,
/static/4-95615a44bce73342a5a28cfe20460940-63df2.jpg 295w,
/static/4-95615a44bce73342a5a28cfe20460940-f8fb9.jpg 590w,
/static/4-95615a44bce73342a5a28cfe20460940-6bec7.jpg 817w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;지금까지는 터미널에서 장고 테스트를 진행하는 과정이었습니다.
한가지 팁으로 pycharm 에서 장고 테스트를 진행하기 위한 설정에 대해서 설명드리겠습니다(Pycharm Community 버전 기준).
우선 간단한 메서드를 만들고(생략), tests.py 에 간단한 테스트 코드를 작성합니다.
그리고 실행,&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/5-20e0e94af467efc50489bd7db2816fe6-3f0b4.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 63.53658536585366%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAMCBAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAFCNZZItB//xAAbEAACAwADAAAAAAAAAAAAAAACAwAEEwERFP/aAAgBAQABBQJrD00ZKpFysqnZeKJRmP8A/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAHhAAAQMEAwAAAAAAAAAAAAAAAQACERIxMlEhkaH/2gAIAQEABj8CdDzfazd2jLieUTXc6WfiiqV//8QAGhABAAIDAQAAAAAAAAAAAAAAAQARITFRQf/aAAgBAQABPyEABy9djKKjHbDvxYxXuBU7L1P/2gAMAwEAAgADAAAAEFvP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAHhABAAIBBAMAAAAAAAAAAAAAAQARITFBUdFhcYH/2gAIAQEAAT8QGxBgBWUE4P7l9AAVcUTSZByq33FOr3GYBdmuwc+J/9k=&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;img5&quot;
        title=&quot;&quot;
        src=&quot;/static/5-20e0e94af467efc50489bd7db2816fe6-f8fb9.jpg&quot;
        srcset=&quot;/static/5-20e0e94af467efc50489bd7db2816fe6-e8976.jpg 148w,
/static/5-20e0e94af467efc50489bd7db2816fe6-63df2.jpg 295w,
/static/5-20e0e94af467efc50489bd7db2816fe6-f8fb9.jpg 590w,
/static/5-20e0e94af467efc50489bd7db2816fe6-3f0b4.jpg 820w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;위와 같은 에러를 뱉어내는군요. “Requested setting DEFAULT&lt;em&gt;INDEX&lt;/em&gt;TABLESPLAE…” 와 같은 에러인데요.
유닛테스트 설정에 환경변수를 설정해주지 않아서 생기는 문제 같습니다.
그래서 Run &gt; Edit Configurations.. 를 열어줍니다.
좌측의 메뉴 중 Defaults &gt; Python tests &gt; Unittests 를 선택하면 아래와 같은 화면이 나타납니다.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/6-1598cafe7d9bf8802d4289fbee53668f-3f0b4.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 62.80487804878049%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMEAf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAGXaRGjxf/EABoQAAMAAwEAAAAAAAAAAAAAAAACAwETFBL/2gAIAQEAAQUC20NtCDtleU5SUfK//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGxAAAgIDAQAAAAAAAAAAAAAAADIBAhGRoTH/2gAIAQEABj8Ce2x7bJzafR+D8GP/xAAdEAABBAIDAAAAAAAAAAAAAAABABEhMRDwUdHx/9oACAEBAAE/IQ5FGHC8QeRWnpO37T+JS9L/2gAMAwEAAgADAAAAEK8P/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGxABAAIDAQEAAAAAAAAAAAAAAQAhEUFhkaH/2gAIAQEAAT8QznrJQP0QqeQKtYIvU3JDOdt1dHeT/9k=&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;img6&quot;
        title=&quot;&quot;
        src=&quot;/static/6-1598cafe7d9bf8802d4289fbee53668f-f8fb9.jpg&quot;
        srcset=&quot;/static/6-1598cafe7d9bf8802d4289fbee53668f-e8976.jpg 148w,
/static/6-1598cafe7d9bf8802d4289fbee53668f-63df2.jpg 295w,
/static/6-1598cafe7d9bf8802d4289fbee53668f-f8fb9.jpg 590w,
/static/6-1598cafe7d9bf8802d4289fbee53668f-3f0b4.jpg 820w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;그 중에 Environment variables 항목이 있는데, 여기에 DJANGO&lt;em&gt;SETTINGS&lt;/em&gt;MODULE=unit&lt;em&gt;test.settings&lt;/em&gt;test 를 입력해줍니다.
그리고 파이썬 인터프리터를 자신이 개발하고 있는 파이썬 버전과 가상환경에 맞게 변경해줍니다(잘 모르시는 분은 가상환경 관련 글 참조).
이제 모든 설정이 끝났습니다.&lt;/p&gt;
&lt;p&gt;그럼 테스트 진행!!
아래와 같은 화면이 나타나면 성공한 것입니다.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/7-8633f5941803ba92d41166b17fb53d28-3f0b4.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 63.53658536585366%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAMCBAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAFCNVZMtB//xAAbEAACAwADAAAAAAAAAAAAAAACAwAEEwESFP/aAAgBAQABBQJrD01OVSLlZ0+xeGJRmP8A/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAIBAAAgAFBQEAAAAAAAAAAAAAAAECERIxUSEiMjORof/aAAgBAQAGPwKLe75OyL0c4m9Ruu7wc/hKqZ//xAAbEAEAAgIDAAAAAAAAAAAAAAABABEhUTFBof/aAAgBAQABPyEQA5eppgVGN2BbCxim8Cvcvif/2gAMAwEAAgADAAAAEDPP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAHBABAAMAAgMAAAAAAAAAAAAAAQARIVHRQWHx/9oACAEBAAE/ECVQYWA1ke0ZfQAFXKI2cg6q2+Z873DY7OzXwHPqf//Z&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;img7&quot;
        title=&quot;&quot;
        src=&quot;/static/7-8633f5941803ba92d41166b17fb53d28-f8fb9.jpg&quot;
        srcset=&quot;/static/7-8633f5941803ba92d41166b17fb53d28-e8976.jpg 148w,
/static/7-8633f5941803ba92d41166b17fb53d28-63df2.jpg 295w,
/static/7-8633f5941803ba92d41166b17fb53d28-f8fb9.jpg 590w,
/static/7-8633f5941803ba92d41166b17fb53d28-3f0b4.jpg 820w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;</content:encoded></item><item><title><![CDATA[[django] 커스텀 템플릿태그(templatetags) 활용하기]]></title><description><![CDATA[웹 개발을 하다보면, html 코드 상에서 다양한 연산을 해야하는 경우가 발생합니다.
그래서 php, jsp, asp, jade 등 각 언어별 웹 프레임워크에서 이와 같은 경우를 처리해주기 위한 기능을 제공하고 있습니다.
장고(django…]]></description><link>https://blueshw.github.io/2016/03/03/django-using-custom-templatetags/</link><guid isPermaLink="false">https://blueshw.github.io/2016/03/03/django-using-custom-templatetags/</guid><pubDate>Thu, 03 Mar 2016 00:34:12 GMT</pubDate><content:encoded>&lt;p&gt;웹 개발을 하다보면, html 코드 상에서 다양한 연산을 해야하는 경우가 발생합니다.
그래서 php, jsp, asp, jade 등 각 언어별 웹 프레임워크에서 이와 같은 경우를 처리해주기 위한 기능을 제공하고 있습니다.
장고(django) 템플릿(template)에서도 위와 같은 웹 프레임워크와 같이 동일한 기능을 지원하는 템플릿태그(templatetags)라는 것이 있습니다.
장고의 템플릿태그는 다른 웹 프레임워크와 마찬가지로 기본적으로 개발자가 필요한 기능은 대부분 제공하고 있습니다.&lt;/p&gt;
&lt;p&gt;웹 프레임워크가 기본적인 기능을 대부분 제공하고 있지만, 개발을 하다보면 자신이 원하는 기능이 없는 경우가 간혹 있습니다.
그래서 장고에서는 개발자가 커스텀으로 템플릿태그를 만들수 있는 기능을 제공하고 있습니다.&lt;/p&gt;
&lt;p&gt;우선 아래와 같이 앱(app) 아래에 templatetags 라는 폴더를 만들어 줍니다.
temaplatetags 라는 폴더 이름은 고정값이므로 반드시 동일하게 생성합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;proj/
	app/
		__init__.py
		models.py
		view.py
		templatetags/
			__init__.py
			custom_tags.py    (커스텀 템플릿태그를 저장할 모듈 파일)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이때, app 은 반드시 setting 파일의 INSTALLED_APPS 에 추가가 되어 있어야 합니다.
그리고 한가지 주의할 점은 여러 앱에 각각 templatetags 가 있는 경우, 모듈의 이름이 겹치지 않도록해야 합니다.
이유는, template 에서 커스텀 태그는 앱의 위치와 상관없이 모듈 이름으로 로드되므로 이름이 겹치게 되면 충돌이 발생하게 됩니다.
즉,&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;proj/
	app/
		templatetags/
			custom_tags.py
	common/
		templatetags/
			common_tags.py    (태그모듈 이름이 겹치지 않도록 주의!!!)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;태그 모듈을 사용하는 방법은 간단합니다.
커스텀 태그를 사용하고자하는 템플릿 파일의 상단에 아래와 같이 한줄만 추가해주면 됩니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;{% load custom_tags %}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그렇다면 실제로 커스텀 태그를 만들어서 사용하는 예제를 만들어 보도록 하겠습니다.
custom_tags.py 파일을 열어 사용하려는 태그 이름으로 메서드 이름으로 지정하여 만들어줍니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;@register.filter            # 1
def add_str(left, right):
return left + right

@register.simple_tag            # 2
def today():
return datetime.now().strftime(&amp;quot;%Y-%m-%d %H:%M&amp;quot;)

@register.assignment_tag            # 3
def max_int(a, b):
return max(int(a), int(b))

@register.inclusion_tag(div.html, takes_context=True)            # 4
def include_div(context):
return {
&amp;#39;div_param&amp;#39;: context[&amp;#39;param&amp;#39;]
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;대략 위의 4 가지 태그로 구분할 수 있는데, 각 태그에 따라서 사용법이 조금씩 다릅니다.
이 4 가지 커스텀 태그만 이용하면 웬만한 기능은 다 만들어 낼 수 있습니다.
번호별 사용법은 아래와 같습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# 1.
# filter 태그는 앞의 값(left)에다가 뒤의 값(right)을 연산하는 태그입니다.
# filter이기 때문에 여러개의 필터를 붙여서 사용가능합니다.
# add_str 메서드의 left 파라미터가 prefix에 해당하고, right 파라미터가 url에 해당합니다.
# 결과적으로 prefix + url이 add_str 메서드를 통해 div의 text가 되는 것이지요.

&amp;lt;div&amp;gt;
{{ prefix | add_str: url | add_str: name | add_str: params }}
&amp;lt;/div&amp;gt;

# 2.
# simple_tag는 단순히 어떤 특정값을 출력합니다.
# 아래와 같이 today를 입력하면, &amp;quot;2016-3-2 10:00&amp;quot;과 같이 현재 시간이 출력됩니다.

&amp;lt;div&amp;gt;
{{ today }}
&amp;lt;/div&amp;gt;

# 3.
# assignment_tag는 템플릿에서 사용가능한 변수에 결과를 저장하는 역할을 합니다.
# 어찌보면 with 태그와 유사한 형태라 할 수 있으나, with과는 다르게 {% endwith %} 처럼 끝을 맺어줄 필요가 없습니다.
# 즉, 좀 더 간편하게 변수를 설정해 줄 수 있고, 필요한 기능을 태그 모듈에 별도로 삽입할 수 있다는 장점이 있습니다.

{% max_int first_count second_count as max_count %}

# 4.
# inclusion_tag는 저도 프로젝트에 직접 사용해 보진 않았지만, 테스트는 해보았습니다.
# 간략히 설명해서 inclusion_tag를 사용하면 데코레이터의 첫번째 파라미터인 템플릿을 호출하여 부모 템플릿에 출력합니다.
# 이때, 호출되는 템플릿에 부모 템플릿(호출하는 템플릿)의 각종 파라미터를 전달해 줄 수 있습니다.
# 데코레이터의 takes_context=True로 설정해주면,
# 부모 템플릿의 context의 값을 가져와 호출하는 템플릿으로 전달할 수 있습니다.

parent.html
{{ include_div }}

div.html
&amp;lt;div&amp;gt;{{ div_param }}&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이상 커스텀 태그의 종류와 사용법에 대해서 알아보았습니다.
제가 설명드린 커스텀 태그는 아주 기초적인 부분이라 제작 및 사용법이 아주 간단한데요.
커스텀 태그 파일은 파이썬 모듈이기 때문에 파이썬에서 사용할 수 있는 내장함수와 모든 확장 모듈을 사용할 수 있기 때문에,
얼마든지 복잡하고 파워풀한 기능을 가진 태그를 만들어 낼 수 있습니다.&lt;/p&gt;
&lt;p&gt;하지만, 복잡한 연산을 처리하는 것은 템플릿보다는 웹서버 단에서 처리하는 것이 우선이고,
서버에서 처리가 곤란하거나 불가피한 상황인 경우에 태그를 사용해서 처리하는 것이라 생각합니다.
아마 장고에서도 사용가능한 기본 태그를 최소한으로 만들어 놓은 것도 같은 이유 때문일 거라 생각이 드네요.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[[django] 장고(django) 개발을 위한 파이썬(python) 가상환경 설정(Mac 환경)]]></title><description><![CDATA[가장 먼저 써야할 글을 이제서야 작성하네요.
여러 개발자들과 함께 장고(django)를 개발하기 위해서는 환경이 일치해야 합니다.
특히 python2 와 python…]]></description><link>https://blueshw.github.io/2016/03/01/django-virtual-env-setting-for-mac/</link><guid isPermaLink="false">https://blueshw.github.io/2016/03/01/django-virtual-env-setting-for-mac/</guid><pubDate>Tue, 01 Mar 2016 23:49:35 GMT</pubDate><content:encoded>&lt;p&gt;가장 먼저 써야할 글을 이제서야 작성하네요.
여러 개발자들과 함께 장고(django)를 개발하기 위해서는 환경이 일치해야 합니다.
특히 python2 와 python3 는 서로 문법이 다르기 때문에(이에 대해서도 포스팅해야 겠네요) 개발 환경을 맞추는 것은 반드시 해야하는 작업입니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;brew install pyenv&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;우선, pyenv 를 설치합니다. pyenv 는 로컬 환경에 여러 버전의 파이썬 버전을 설치 할 수 있도록 해줍니다.
기본적으로 설치되어 있는 파이썬 버전이 서로 다른 경우 개발에 제약이 생길 수 있기 때문에 파이썬 버전 의존성을 제거해주기 위해 반드시 pyenv 를 설치해 줍니다.&lt;/p&gt;
&lt;p&gt;이제 실제 개발에 사용할 파이썬 버전을 설치해줍니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;pyenv install 3.4.3  (python 3.4.3 버전 설치)
pyenv install --list  (설치 가능한 python 버전 list 보기)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;파이썬 버전을 설치하고 나면 versions 명령어로 새 버전의 파이썬에 제대로 설치 되었나 확인해봅니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;pyenv versions
   * system
     3.4.3    (새로 설치한 python)

pyenv shell 3.4.3    (3.4.3 버전 설정)
pyenv versions
     system
   * 3.4.3&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 화면처럼 나오면 정상입니다.
system 이란 현재 시스템에(Mac OS 에는 파이썬 2.7 버전이 기본적으로 설치되어 있습니다) 설치된 파이썬을 뜻합니다.
그리고 3.4.3 이 새롭게 설치된 파이썬 버전이겠지요.
별표는 현재 설정된 파이썬 버전을 뜻합니다. (현재는 system 버전이 설정되어 있네요)
그리고 아래 shell 명령어를 입력한다음 다시 versions 명령어를 입력하면 설정된 버전이 바뀐 것을 볼 수 있습니다.&lt;/p&gt;
&lt;p&gt;좀 더 편한 작업을 위해 한가지 패키지를 더 설치해 줍니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;brew install pyenv-virtualenv&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;pyenv-virtualenv 는 하나의 파이썬 버전에 여러개의 가상환경을 설정할 수 있도록 해주는 패키지입니다.
예를들어 파이썬 3.4.3 을 사용하는 django 프로젝트를 진행하는 동시에 다른 python 프로젝트를 진행하게 되었습니다.
이때 파이썬 버전을 동일하게 3.4.3 을 사용하게되면, django 에서만 사용하는 모듈을 다른 프로젝트에서도 불필요하게 설치되어 있게 됩니다.
이렇듯 잠재적인 문제를 야기하는 파이썬 모듈 의존성을 제거하기 위해 pyenv-virtualenv 패키지를 설치해줍니다.
아래와 같은 명령어를 통해서 하나의 파이썬 버전에 여러개의 가상환경을 설정할 수 있게 됩니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;pyenv virtualenv &amp;lt;버전&amp;gt; &amp;lt;가상환경 이름&amp;gt;
pyenv virtualenv 3.4.3 py343
pyenv versions
     system
   * 3.4.3
     py343&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;virtualenv 라는 명령어가 추가되었습니다(그 외 activate 등 몇가지 추가).
첫번째 파라미터는 사용하는 버전을 뜻하고 두번째 파라미터는 가상환경의 이름을 뜻합니다.
다시 versions 명령어를 실행해보면, py343 이라는 새로운 가상환경이 만들어진것을 확인할 수 있습니다.&lt;/p&gt;
&lt;p&gt;만들어진 가상환경을 사용할때 pyenv 의 명령어인 shell 을 사용해도 무방합니다만, 좀더 명시적으로 가상환경을 알 수 있도록 하기 위해서는 pyenv-virtualenv 패키지에서 제공하는 activate 명령어를 사용합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;pyenv activate py343
(py343) User-Macbook-Pro:~ user$

pyenv versions
     system
     3.4.3
   * py343&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;activate 명령어를 수행하게 되면, 쉘 커서 앞에 (py343)이라는 파이썬 가상환경 이름이 붙었네요.
versions 명령어를 수행해보면, py343 환경에 별표가 되어 있는걸 확인할 수 있습니다.
이제부터는 마음껏 모듈을 설치한 후에 다른 프로젝트를 진행할 일이 생기면, 다른 가상환경을 만들어서(예를들면 django343 등) 사용하시면 되겠습니다.&lt;/p&gt;
&lt;p&gt;가상환경에서 빠져나올때는 deactivate 명령어를 사용하면 됩니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;pyenv deactivate&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[[python] set에 관한 두가지 사실]]></title><description><![CDATA[중복이 제거된 자료구조를 만들어야 할 일이 있어 set 을 쓰게 되었는데요.
set 으로 만들어진 자료를 바탕으로 루프를 돌며 set 안의 item 들을 처리하는 작업이었습니다.
item…]]></description><link>https://blueshw.github.io/2016/02/28/python-about-set/</link><guid isPermaLink="false">https://blueshw.github.io/2016/02/28/python-about-set/</guid><pubDate>Sun, 28 Feb 2016 01:47:45 GMT</pubDate><content:encoded>&lt;p&gt;중복이 제거된 자료구조를 만들어야 할 일이 있어 set 을 쓰게 되었는데요.
set 으로 만들어진 자료를 바탕으로 루프를 돌며 set 안의 item 들을 처리하는 작업이었습니다.
item 이 너무 많아지게 되면, 메모리 등의 성능 이슈가 발생할 것을 대비하여 20 만개씩 잘라서 분절해야 했는데요.
이 때 첫번째 문제가 발생했습니다. python 에서 set 은 분절 할 수 없다는 것입니다.
리스트의 경우에는 아래와 같이 분절이 가능합니다만, set 은 리스트 처럼 분절이 불가합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;temp_list = [&amp;#39;a, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;f&amp;#39;]
temp_list[:3]

# [&amp;#39;a, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;] 출력&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;temp_set = {&amp;#39;a, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;f&amp;#39;}
temp_set[:3]

# 아래의 에러 발생
# Traceback (most recent call last):
# File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
# TypeError: &amp;#39;set&amp;#39; object is not subscriptable&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;루프를 돌면서 처리할 수도 있겠지만, 그것보다는 왜 set 이 분절이 안될까라는 고민에 빠져 도대체 set 은 어떻게 만들어진건가 궁금해지더라구요.
구글링을 하다 파이썬 공식 문서에(2.7 버전, 파이썬 3 보다 설명이 괜찮더라구요) set 은 아래와 같은 내용을 찾았습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The sets module provides classes for constructing and manipulating unordered collections of unique elements. Common uses include membership testing, removing duplicates from a sequence, and computing standard math operations on sets such as intersection, union, difference, and symmetric difference.&lt;/p&gt;
&lt;p&gt;Like other collections, sets support x in set, len(set), and for x in set. Being an unordered collection, sets do not record element position or order of insertion. Accordingly, sets do not support indexing, slicing, or other sequence-like behavior.&lt;/p&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;p&gt;The set classes are implemented using dictionaries. Accordingly, the requirements for set elements are the same as those for dictionary keys; namely, that the element defines both &lt;strong&gt;eq&lt;/strong&gt;() and &lt;strong&gt;hash&lt;/strong&gt;(). As a result, sets cannot contain mutable elements such as lists or dictionaries&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;대략적인 내용을 살펴보면(발번역 및 의역),&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;set 은 순서가 없는 중복이 불가능한 collection 자료형이다. 주로 item 테스트, 중복제거 등에 사용되고 교집합, 합집합, 차집합 등을 수학적인 계산이 가능하다. 다른 collection 자료형 처럼 item 검사, 길이, 루프가 가능하다. set 은 삽입된 item 의 위치를 저장하지 않기 때문에 item 간의 순서가 없다. 따라서 indexing 이 불가능하고, 자르기가 안되고, 그외의 sequential 한 작업이 불가하다. set 은 dictionary 를 구현한 클래스인데, dictionary 의 key 가 set 의 item 이 된다. 그렇기 때문에 set 은 dictionary 나 list 처럼 중복되는 요소를 담을 수 없다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;정도가 되겠네요. 위의 번역을 토대로 set 이 분절이 안되는 이유는 item 을 저장할때 순서값을 저장하지 않기 때문이라 할 수 있겠네요.
순서가 없으니 어디서부터 어디까지라는 것을 정할 수 없을 것이고, 그렇기 때문에 분절이 불가능하다 할 수 있겠습니다.&lt;/p&gt;
&lt;p&gt;그리고 두 번째 문제가 있었는데, set 의 루핑 속도에 대한 것이었습니다.
파이썬에서 set 역시 list 와 같이 iterable 한 자료구조이긴 하지만, list 에 비해서 iteration 성능은 떨어지는 것으로 익히 알려져 있습니다.
대신 hash 기반으로 만들어지기 때문에 검색 속도는 list 에 비해 훨씬 뛰어나죠.&lt;/p&gt;
&lt;p&gt;우선 진짜 set 이 list 에 비해 iteration 성능이 떨어지는지 확인해 보았습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;from timeit import timeit

def iter(iterable):
    for i in iterable:
        pass

timeit(&amp;quot;iter(iterable)&amp;quot;, number=1000, setup=&amp;quot;from __main__ import iter; iterable=set(range(1000000))&amp;quot;)
# 결과 : 14.660961047000455 (단위: 초)

timeit(&amp;quot;iter(iterable)&amp;quot;, number=1000, setup=&amp;quot;from __main__ import iter; iterable=list(range(1000000))&amp;quot;)
# 결과 : 11.929272602999845 (단위: 초)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1,000,000(백만, 0~999,999) 까지의 숫자를 담은 set 을 1,000 번 반복한 결과 14.66 초 정도가 걸렸습니다.
반면에 같은 조건으로 list 를 1,000 번 반복한 결과 11.93 초 정도가 걸렸네요.
대략 3 초 정도가 차이납니다.
사실 1,000,000 을 1,000 번 반복하여 총 1,000,000,000(10 억)번 루프를 돌아야만 3 초 정도(14-11)가 차이가 난것이지,
현업에서 사용하는 정도의 크기로 비교해보면 그렇게 큰 차이가 나지는 않는것 같네요.
속도차이가 크게 나지 않기 때문에 특별한 이유가 없다면 set 으로 루프를 돌려도 무방할 것 같습니다.&lt;/p&gt;
&lt;p&gt;글을 쓰고 나니 알맹이는 없고 횡설수설한 느낌입니다.
어찌되었든 위의 두가지(set 은 slice 를 못하는 것, list 보다 iteration 성능이 떨어지는것) 사실로 set 에 대한 궁금증이 완전히 사라진 것은 아닙니다.
set 이라는 자료구조가 머리속에 그림으로 그려져서 더하고 삭제하거나 탐색할때, 또는 set 을 list 로 바꿀 때와 같은 경우를 한번에 떠올릴 수 있으면 참 좋겠습니다만, 아직까지는 더 노력이 필요한 것 같습니다.
너무 많은 내용을 한번에 다루면 포스팅하는 저나 읽는 사람들 모두 피곤할테니 일단은 여기서 글을 마무리 하는게 좋을것 같네요.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[[python] 클래스 이름을 사용한 동적 모듈 import]]></title><description><![CDATA[파이썬에서 모듈을 import 할때, 보통 파일 최상단(but, 메서드 내에서 지역적으로 import…]]></description><link>https://blueshw.github.io/2016/02/24/python-import-by-class-name/</link><guid isPermaLink="false">https://blueshw.github.io/2016/02/24/python-import-by-class-name/</guid><pubDate>Wed, 24 Feb 2016 00:56:51 GMT</pubDate><content:encoded>&lt;p&gt;파이썬에서 모듈을 import 할때, 보통 파일 최상단(but, 메서드 내에서 지역적으로 import 가능)에 정의해서 쓰곤 합니다.
그런데 최근에 작업하면서 여러 클래스를 하나의 메서드에서 처리하면 좋겠다는 부분이 생겼지요.
그래서 생각한 끝에 클래스 이름만으로 동적으로 import 하는 방법이 있지 않을까하는 궁금증이 생겼습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;아마도, 파이썬이라면 가능하다. 아마 누군가 똑같은 고민을 했을 것이다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;라는 생각이 들어 한번 찾아 보았습니다.&lt;/p&gt;
&lt;p&gt;검색결과, 역시나,,,, 파이썬,,,,
동일한 조건의 답을 찾는데 꽤 시간이 걸렸지만 결국에는 딱 맞는 방법을 찾아냈습니다.
현재 조건을 바탕으로 동적으로 import 하는 방법은 아래와 같습니다.&lt;/p&gt;
&lt;h3&gt;조건&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;파일 A, B 가 있고 c 라는 클래스의 이름으로 B 에서 import 해야함
파일 A 에서 B 의 함수를 호출함, 이때 파라미터로 c 클래스의 이름을 전달
파일 A 에는 c 클래스를 import 하고 있음&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;file A&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;from package.temp import TempClass
from package import b

def a_function():
    module_name = TempClass.__module__       # 클래스가 정의된 모듈의 이름(패스)을 불러온다.
    class_name = TempClass.__name__           # 클래스 이름을 string으로 가져온다.
    b_function(module_name, class_name)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;file B&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import importlib          # 모듈을 import 할 수 있는 모듈

def b_function(module_name, class_name):
    mod = importlib.import_module(module_name)          # 모듈을 import하고 모듈을 리턴
    class = getattr(mod, class_name)          # 모듈과 클래스 이름으로 클래스 정보를 가져온다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;정리해보면,
우선 file A 에서 클래스를 import 합니다. 그리고 특수 기능을 가진 private method 인 &lt;strong&gt;module&lt;/strong&gt;과 &lt;strong&gt;name&lt;/strong&gt;을 이용하여 각각 클래스가 정의된 모듈의 이름과 클래스 이름을 text 로 가져옵니다. 두 개의 값을 b_function 의 파라미터로 전달한 뒤, file B 에서 두 파라미터를 이용하여 importlib 모듈을 통해 import 한뒤 클래스 정보를 가져오게 됩니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[[django] pycharm(파이참) community 버전으로 django(장고) 프로젝트 설정]]></title><description><![CDATA[파이썬(python) + 장고(django)로 프로젝트를 진행하려고 하면, 우선 개발도구를 정해야 합니다. 콘솔 + VI 로 작업해도 무관합니다만 장고를 지원해주는 IDE…]]></description><link>https://blueshw.github.io/2016/02/02/django-setting-for-pycharm-community/</link><guid isPermaLink="false">https://blueshw.github.io/2016/02/02/django-setting-for-pycharm-community/</guid><pubDate>Tue, 02 Feb 2016 22:15:06 GMT</pubDate><content:encoded>&lt;p&gt;파이썬(python) + 장고(django)로 프로젝트를 진행하려고 하면, 우선 개발도구를 정해야 합니다. 콘솔 + VI 로 작업해도 무관합니다만 장고를 지원해주는 IDE 가 있다면 그 기능을 이용하는 것이 좋겠죠. 더불어 자동완성 등 다양한 기능을 사용할 수 있으니 작업 능률을 향상 시켜 줄수 있습니다. 몇가지 사용 가능한 IDE 가 있겠지만, 파이썬(또는 장고) 프로젝트로 사용하기에는 Pycharm(Pycharm 다운로드)만한 게 없다고 생각합니다. 그런데 유료죠. 이클립스 처럼 무료면 참 좋을텐데, &lt;a href=&quot;https://www.jetbrains.com/&quot;&gt;JetBrains&lt;/a&gt;에서 만드는 자바 IDE 인 intelliJ 또한 꽤 비싼 편이죠.&lt;/p&gt;
&lt;p&gt;비싸다고 좌절할 필요 없습니다. 저희에게는 무료버전인 파이참 커뮤니티 버전(Pycharm Community Version)이 있기 때문이죠. 비록 자바스크립트 하이라이팅, 다국어 파일 지원, html 파일 링크 등 몇가지 기능을 제외한다면 충분히 이 무료버전으로 장고 프로젝트를 진행 할 수 있습니다. 제가 처음 장고 프로젝트를 시작할때는 무료버전으로 장고 설정하는 방법에 관한 마땅한 자료를 찾지 못해서 꽤나 시간을 보냈기에 저와 같은 분이 없었으면 하는 마음에 글을 남겨봅니다.&lt;/p&gt;
&lt;p&gt;과정은 다음과 같습니다.&lt;/p&gt;
&lt;h3&gt;STEP 1. 장고 프로젝트 생성&lt;/h3&gt;
&lt;p&gt;파이썬 가상환경이 설치(pyenv)되어 있고, 장고가 설치(가상환경 내에서 pip install django)되어 있다 가정합니다.
참고로 pip 는 파이썬 모듈을 설치하는 패키지 관리자입니다.
위 부분이 막힌다면 다른 글들을 찾아보고 오시는게 좋을 것 같네요(나중에 저도 따로 포스팅 하려고 합니다).&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;django-admin.py startproject testproject&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/django-setting-01-6814302319fa5bec7f532b017cc76c89-3f0b4.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 74.02439024390245%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMEBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAYptBBsDA//EABgQAQEBAQEAAAAAAAAAAAAAAAMCBAAU/9oACAEBAAEFAtGhZf0t2C6sHxtbeB+xlQj/AP/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EAB0QAAICAgMBAAAAAAAAAAAAAAECABExkQMSM1H/2gAIAQEABj8CcDkarnq25bMSbjsAKJ+zA3Or5uf/xAAZEAEAAwEBAAAAAAAAAAAAAAABABARIXH/2gAIAQEAAT8hC8DAGtJtSmr5NSQpQTwA1eM//9oADAMBAAIAAwAAABDjD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABoQAQADAQEBAAAAAAAAAAAAAAEAESHxMdH/2gAIAQEAAT8QykLBC/J1EE8NiarEVJUkDSzlYswBLMQ+T//Z&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;setting01&quot;
        title=&quot;&quot;
        src=&quot;/static/django-setting-01-6814302319fa5bec7f532b017cc76c89-f8fb9.jpg&quot;
        srcset=&quot;/static/django-setting-01-6814302319fa5bec7f532b017cc76c89-e8976.jpg 148w,
/static/django-setting-01-6814302319fa5bec7f532b017cc76c89-63df2.jpg 295w,
/static/django-setting-01-6814302319fa5bec7f532b017cc76c89-f8fb9.jpg 590w,
/static/django-setting-01-6814302319fa5bec7f532b017cc76c89-3f0b4.jpg 820w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;이제 프로젝트가 생성되었습니다. 프로젝트 안으로 들어가보면 testproject 라는 기본 앱(장고 프로젝트는 앱의 모임)과 manage.py 가 있군요. manage.py 는 장고 프로젝트에서 사용할 명령어들을 위한 파일이라 생각하시면 됩니다(ex. 서버 실행이 python manage.py runserver).&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/django-setting-02-739e4d85ea9dc192281398a44916f438-3f0b4.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 74.02439024390245%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMEBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAY5dBBsDA//EABgQAQEBAQEAAAAAAAAAAAAAAAMCBAAU/9oACAEBAAEFAtGhZf0t2C6sHxtbeB+xlQj/AP/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABwQAAICAwEBAAAAAAAAAAAAAAECABExUZESM//aAAgBAQAGPwJwHar3Po3ZbMSbjsAKJ3MDs8vm5//EABkQAQADAQEAAAAAAAAAAAAAAAEAEBEhcf/aAAgBAQABPyEB4MAo5NqU1fJqSFKCeAGrxn//2gAMAwEAAgADAAAAEGMP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGhABAAMAAwAAAAAAAAAAAAAAAQARIYHR8f/aAAgBAQABPxBSCwAC4s2HzgnhsTVYipKkgaWeVizAEsxDqf/Z&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;setting02&quot;
        title=&quot;&quot;
        src=&quot;/static/django-setting-02-739e4d85ea9dc192281398a44916f438-f8fb9.jpg&quot;
        srcset=&quot;/static/django-setting-02-739e4d85ea9dc192281398a44916f438-e8976.jpg 148w,
/static/django-setting-02-739e4d85ea9dc192281398a44916f438-63df2.jpg 295w,
/static/django-setting-02-739e4d85ea9dc192281398a44916f438-f8fb9.jpg 590w,
/static/django-setting-02-739e4d85ea9dc192281398a44916f438-3f0b4.jpg 820w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;h3&gt;STEP 2. 파이참에서 장고 프로젝트 열기&lt;/h3&gt;
&lt;p&gt;다운받은 &lt;a href=&quot;https://www.jetbrains.com/pycharm/download/#section=mac&quot;&gt;파이참 커뮤니티 버전&lt;/a&gt;을 실행합니다.
오른쪽 화면의 명령 중 open 을 클릭해서 터미널에서 생성한 testproject 를 클릭합니다.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/django-setting-03-3bb043539be9912d0464f87bc830fc03-3f0b4.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 77.5609756097561%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAQABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIFBP/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHO9CelgUX/xAAcEAACAgIDAAAAAAAAAAAAAAACAwABBBMREhT/2gAIAQEAAQUC3Mm8+MU+6vEMtDKvEEhV/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGxAAAgIDAQAAAAAAAAAAAAAAAAECESEyM5H/2gAIAQEABj8C6SN5emTZjSi6Kkqyf//EABsQAQACAgMAAAAAAAAAAAAAAAEAERAhMcHw/9oACAEBAAE/IW/swEt6VFLWe8jwdtMVoVuZ/9oADAMBAAIAAwAAABD3z//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EAB0QAQEAAgIDAQAAAAAAAAAAAAERADEhQVHB0fH/2gAIAQEAAT8QPJK4C5q3f5wIzbUvfvF29/j4wq+ZDZeHFRlptIZ//9k=&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;setting03&quot;
        title=&quot;&quot;
        src=&quot;/static/django-setting-03-3bb043539be9912d0464f87bc830fc03-f8fb9.jpg&quot;
        srcset=&quot;/static/django-setting-03-3bb043539be9912d0464f87bc830fc03-e8976.jpg 148w,
/static/django-setting-03-3bb043539be9912d0464f87bc830fc03-63df2.jpg 295w,
/static/django-setting-03-3bb043539be9912d0464f87bc830fc03-f8fb9.jpg 590w,
/static/django-setting-03-3bb043539be9912d0464f87bc830fc03-3f0b4.jpg 820w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;폴더 구조는 잠깐 말씀드린대로, testproject 라는 프로젝트 안에 testproject 라는 기본앱이 있구요. manage.py 명령 파일이 있습니다. 앱은 필요한 만큼 얼마든지 추가가 가능하니 앱이 필요한 경우에는 역시 터미널로 가서&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;manage.py startapp 앱이름&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;을 입력해주시면 됩니다.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/django-setting-04-7ade71526b61a64f1a948305dd8f310c-3f0b4.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 63.53658536585366%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAQCAwX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAFdfXrJDYf/xAAbEAACAgMBAAAAAAAAAAAAAAACAwAEARITFP/aAAgBAQABBQJzD36slUyys6mxeHETX5j/AP/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EACAQAAIABQUBAAAAAAAAAAAAAAABAhESMVEhIjIzkaH/2gAIAQEABj8Ci3O+TnF6OcTeo3Xd4Oz4Sqmf/8QAGxABAAICAwAAAAAAAAAAAAAAAQARMWEhUfH/2gAIAQEAAT8hGYdPG09LGxLu6INsOSNiAWyzeJ//2gAMAwEAAgADAAAAECgP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAHhABAQABAwUAAAAAAAAAAAAAAREAIUFRYaHR8PH/2gAIAQEAAT8QFHgKG7Efc74BsIqrMH1YTqlbznyPnCXY0zsHPTP/2Q==&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;setting04&quot;
        title=&quot;&quot;
        src=&quot;/static/django-setting-04-7ade71526b61a64f1a948305dd8f310c-f8fb9.jpg&quot;
        srcset=&quot;/static/django-setting-04-7ade71526b61a64f1a948305dd8f310c-e8976.jpg 148w,
/static/django-setting-04-7ade71526b61a64f1a948305dd8f310c-63df2.jpg 295w,
/static/django-setting-04-7ade71526b61a64f1a948305dd8f310c-f8fb9.jpg 590w,
/static/django-setting-04-7ade71526b61a64f1a948305dd8f310c-3f0b4.jpg 820w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;h3&gt;STEP 3. 서버실행(Run) 설정&lt;/h3&gt;
&lt;p&gt;거의 다 왔습니다. 프로젝트가 만들어 졌으나 바로 실행이 가능한 건 아니고(커뮤니티 버전이니까..) 간단한 실행 설정이 필요합니다.
우선 상단 메뉴를 열어서, 아래 메뉴를 클릭해줍니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Run &gt; Edit Configurations…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/django-setting-05-4968949a125ed8728f21364b477c3510-3f0b4.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 62.4390243902439%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIEAQX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAGOznIMYH//xAAaEAACAgMAAAAAAAAAAAAAAAABAgASBBAR/9oACAEBAAEFAg7WymIW7w65P//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABwQAAIABwAAAAAAAAAAAAAAAAABAhEgIjEykf/aAAgBAQAGPwJXPJDJs2faP//EABwQAAICAgMAAAAAAAAAAAAAAAABESEQMUFRYf/aAAgBAQABPyFvpHJFCt6eLJRHrIH/2gAMAwEAAgADAAAAENAP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAHBABAAEEAwAAAAAAAAAAAAAAAQARITFBcdHx/9oACAEBAAE/EANooJXe8cWbyhqe27hO2Y15Tlgxln//2Q==&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;setting05&quot;
        title=&quot;&quot;
        src=&quot;/static/django-setting-05-4968949a125ed8728f21364b477c3510-f8fb9.jpg&quot;
        srcset=&quot;/static/django-setting-05-4968949a125ed8728f21364b477c3510-e8976.jpg 148w,
/static/django-setting-05-4968949a125ed8728f21364b477c3510-63df2.jpg 295w,
/static/django-setting-05-4968949a125ed8728f21364b477c3510-f8fb9.jpg 590w,
/static/django-setting-05-4968949a125ed8728f21364b477c3510-3f0b4.jpg 820w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;다음과 같은 화면이 나타납니다.
좌측 상단의 ’+’ 버튼을 클릭하고 Python 을 선택합니다.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/django-setting-06-0d662a0bb7633a254bd9453e9c8b8b73-3f0b4.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 62.80487804878049%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAQC/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAZVRNKS//8QAGxAAAwACAwAAAAAAAAAAAAAAAAIDExQBBBL/2gAIAQEAAQUCzUM1DrO3KapqkYeF/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAHRAAAgIBBQAAAAAAAAAAAAAAAAERMqECEjFBkf/aAAgBAQAGPwK79Lsc6nyXwXwRu7P/xAAdEAACAQQDAAAAAAAAAAAAAAAAAREhMfDxUWHB/9oACAEBAAE/IUhUE4/cbzb5Pow2MNydqXWP/9oADAMBAAIAAwAAABDMD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABsQAQACAwEBAAAAAAAAAAAAAAEAESFBUTFh/9oACAEBAAE/EKYPeUyy49wKSYKuKS54ZLRxhsbVsdB35P/Z&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;setting06&quot;
        title=&quot;&quot;
        src=&quot;/static/django-setting-06-0d662a0bb7633a254bd9453e9c8b8b73-f8fb9.jpg&quot;
        srcset=&quot;/static/django-setting-06-0d662a0bb7633a254bd9453e9c8b8b73-e8976.jpg 148w,
/static/django-setting-06-0d662a0bb7633a254bd9453e9c8b8b73-63df2.jpg 295w,
/static/django-setting-06-0d662a0bb7633a254bd9453e9c8b8b73-f8fb9.jpg 590w,
/static/django-setting-06-0d662a0bb7633a254bd9453e9c8b8b73-3f0b4.jpg 820w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;Name 을 적당하게 입력해주고,
Script 부분은 manage.py 의 경로를 입력합니다(우측의 ’…’ 버튼을 이용합시다).
Script parameters 에는 runserver 를 입력합니다.
Python interpreter 에서 자신이 실행하고자 하는 파이썬 버전을 클릭해줍니다.
실제 터미널에서 서버를 실행하는 것과 동일하다 생각하시면 됩니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;manage.py runserver&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이렇게요.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/django-setting-07-a9dc9adf7baf48ecd5e79f6499e8625c-3f0b4.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 62.80487804878049%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAEEAv/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAGV0pNlIv8A/8QAGxAAAwACAwAAAAAAAAAAAAAAAAIDExQBBBL/2gAIAQEAAQUCzUM1DrO3KapqkYeF/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAHRAAAQQCAwAAAAAAAAAAAAAAAAECETISoTFBkf/aAAgBAQAGPwK7vS6iy5eS+i+iMuz/xAAeEAACAQMFAAAAAAAAAAAAAAAAAREhMfBRYcHR8f/aAAgBAQABPyFBHBzjebep7GHolj2TtS6x/9oADAMBAAIAAwAAABDcD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABwQAQADAAIDAAAAAAAAAAAAAAEAESFBUTFhcf/aAAgBAQABPxAqAB9MIzWu8CkmCrlIs8GSxVdhyNq2eA79T//Z&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;setting07&quot;
        title=&quot;&quot;
        src=&quot;/static/django-setting-07-a9dc9adf7baf48ecd5e79f6499e8625c-f8fb9.jpg&quot;
        srcset=&quot;/static/django-setting-07-a9dc9adf7baf48ecd5e79f6499e8625c-e8976.jpg 148w,
/static/django-setting-07-a9dc9adf7baf48ecd5e79f6499e8625c-63df2.jpg 295w,
/static/django-setting-07-a9dc9adf7baf48ecd5e79f6499e8625c-f8fb9.jpg 590w,
/static/django-setting-07-a9dc9adf7baf48ecd5e79f6499e8625c-3f0b4.jpg 820w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;h3&gt;STEP 4. 실행(Run)&lt;/h3&gt;
&lt;p&gt;이제 설정은 끝입니다. 벌써 끝인거야? 라고 생각하실지 모르겠지만 파이썬 가상환경이나 모듈(패키지) 설치 등은 다 건너뛰었기 때문에 막히는 부분이 발생할 수도 있습니다. 가상환경과 모듈 설치에 대한 부분은 따로 포스팅하겠습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Run &gt; Run ‘runserver’(이렇게 바뀌어 있네요)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;를 클릭합니다.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/django-setting-08-f75aca90777f4d002e99e1d92779a6ff-3f0b4.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 62.4390243902439%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAEEAgX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAGOznZGIP/EABoQAAICAwAAAAAAAAAAAAAAAAECABIEEBH/2gAIAQEAAQUCDtbLYhbvDrk//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAHBAAAQMFAAAAAAAAAAAAAAAAAQAQMQIRIjKR/9oACAEBAAY/AhkZVNiQtj1pb//EABsQAQACAgMAAAAAAAAAAAAAAAEAMRARQVGB/9oACAEBAAE/IU9I5lkA04sI7bT7NJ//2gAMAwEAAgADAAAAENAP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGxABAAIDAQEAAAAAAAAAAAAAAQAhETFBUfH/2gAIAQEAAT8QE6UEzu5odLKHJ9tKNpfIONe5QY2z/9k=&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;setting08&quot;
        title=&quot;&quot;
        src=&quot;/static/django-setting-08-f75aca90777f4d002e99e1d92779a6ff-f8fb9.jpg&quot;
        srcset=&quot;/static/django-setting-08-f75aca90777f4d002e99e1d92779a6ff-e8976.jpg 148w,
/static/django-setting-08-f75aca90777f4d002e99e1d92779a6ff-63df2.jpg 295w,
/static/django-setting-08-f75aca90777f4d002e99e1d92779a6ff-f8fb9.jpg 590w,
/static/django-setting-08-f75aca90777f4d002e99e1d92779a6ff-3f0b4.jpg 820w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;아래처럼 파이참 콘솔에 로컬 8000 번 포트로 프로젝트가 실행되었다는 로그가 뜨면 제대로 성공한 것입니다.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/django-setting-09-d26447a49eee13ec5d67e2f0ea0ff109-3f0b4.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 63.53658536585366%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAQCAwX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAFdfYqJDYf/xAAbEAACAgMBAAAAAAAAAAAAAAACAwAEARITFP/aAAgBAQABBQJzD36slUyys6mxeKJr8x//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAgEAABAwIHAAAAAAAAAAAAAAAAAQIREjEhMjNRYZGh/9oACAEBAAY/AnQ5b7md3YsuVcRVrvwanhFUn//EABsQAQACAwEBAAAAAAAAAAAAAAEAETFRYSHx/9oACAEBAAE/IRmOnjqfTRMa3eEHxlliu0Atlm8T/9oADAMBAAIAAwAAABAYD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EAB4QAQACAgEFAAAAAAAAAAAAAAEAESFB0VFhcaHw/9oACAEBAAE/EAQ4AQ2iP1e4RgIFVqFheCZ1b5l/D5gLuNmug69p/9k=&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;setting09&quot;
        title=&quot;&quot;
        src=&quot;/static/django-setting-09-d26447a49eee13ec5d67e2f0ea0ff109-f8fb9.jpg&quot;
        srcset=&quot;/static/django-setting-09-d26447a49eee13ec5d67e2f0ea0ff109-e8976.jpg 148w,
/static/django-setting-09-d26447a49eee13ec5d67e2f0ea0ff109-63df2.jpg 295w,
/static/django-setting-09-d26447a49eee13ec5d67e2f0ea0ff109-f8fb9.jpg 590w,
/static/django-setting-09-d26447a49eee13ec5d67e2f0ea0ff109-3f0b4.jpg 820w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;웹에서 확인해 보시면 아래와 같은 화면이 나타날 겁니다.
만약 이런 화면을 볼 수 없다면 차근차근 다시 해보시거나 가상환경, 패키지 설치법 등을 다시 한번 살펴보시기 바랍니다.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/django-setting-10-f5fe43c830905afccb20844d56e44044-3f0b4.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 63.53658536585366%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe5cig//xAAYEAEBAAMAAAAAAAAAAAAAAAAAERASMf/aAAgBAQABBQKJitnX/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGRAAAgMBAAAAAAAAAAAAAAAAABEBIVFB/9oACAEBAAE/IW0bRLo8UMQP/9oADAMBAAIAAwAAABDzz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABoQAQADAAMAAAAAAAAAAAAAAAEAESExQWH/2gAIAQEAAT8QN057LinEUqsxQ0MyeBEi2jqf/9k=&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;setting10&quot;
        title=&quot;&quot;
        src=&quot;/static/django-setting-10-f5fe43c830905afccb20844d56e44044-f8fb9.jpg&quot;
        srcset=&quot;/static/django-setting-10-f5fe43c830905afccb20844d56e44044-e8976.jpg 148w,
/static/django-setting-10-f5fe43c830905afccb20844d56e44044-63df2.jpg 295w,
/static/django-setting-10-f5fe43c830905afccb20844d56e44044-f8fb9.jpg 590w,
/static/django-setting-10-f5fe43c830905afccb20844d56e44044-3f0b4.jpg 820w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;그럼 재미있는 장고 프로젝트 진행하시길~&lt;/p&gt;</content:encoded></item><item><title><![CDATA[[python] 코루틴(co-routine), 서브루틴(sub-routine)과 비교]]></title><description><![CDATA[코루틴의 개념을 살펴보기 전에 우선, 상반되는(반드시 상반된다고는 할 수 없지만..) 서브루틴에 대해서 한번 짚고 넘어가 보겠습니다.
참고로 서브루틴의 상반되는 개념은 코루틴이 아닌 메인루틴(main-routine…]]></description><link>https://blueshw.github.io/2016/01/25/python-co-routine-vs-sub-routine/</link><guid isPermaLink="false">https://blueshw.github.io/2016/01/25/python-co-routine-vs-sub-routine/</guid><pubDate>Mon, 25 Jan 2016 22:32:26 GMT</pubDate><content:encoded>&lt;p&gt;코루틴의 개념을 살펴보기 전에 우선, 상반되는(반드시 상반된다고는 할 수 없지만..) 서브루틴에 대해서 한번 짚고 넘어가 보겠습니다.
참고로 서브루틴의 상반되는 개념은 코루틴이 아닌 메인루틴(main-routine, 그냥 루틴이라고도 함)이라 할 수 있습니다.&lt;/p&gt;
&lt;h3&gt;서브루틴&lt;/h3&gt;
&lt;p&gt;서브루틴은 반복되는 특정 기능을 모아 별도로 묶어 놓아 이름을 붙여 놓은 것으로 메인루틴을 보조하는 역할을 합니다. 보통 언어에서는 함수나 메소드 등으로 불리며 사용됩니다. 어떤 특정 기능을 모아놓고 이름을 붙였다는 것으로 매크로와 비슷하지만 매크로의 경우 컴파일시에(C 언어에서와 같이) 매크로를 호출하는 부분을 모두 매크로 본문으로 대체해 버리므로 메모리 사용이 비효율적입니다. 반면에 서브루틴은 별도의 메모리에 해당 기능을 모아 놓고 있어, 서브루틴이 호출될 때마다 저장된 메모리로 이동했다가 return 을 통해 원래 호출자의 위치로 돌아오게 됩니다. 호출할 때마다 매번 같은 위치로 이동하기 때문에 여러번 사용될 수 있으므로 매크로에 비해서 훨씬 효율적이라 할 수 있겠지요.&lt;/p&gt;
&lt;h3&gt;코루틴&lt;/h3&gt;
&lt;p&gt;코루틴도 서브루틴처럼 기능들을 별도의 공간에 모아 놓고 있다는 점에서는 동일합니다. 차이점이라 할 수 있는 것은, 서브루틴의 경우에는 메인루틴에서 특정 서브루틴의 공간으로 이동한 후에 리턴에 의해 호출자로 돌아와 다시 프로세스를 진행하는데 반해 코루틴의 경우에는 루틴을 진행하는 중간에 멈추어서 특정 위치로 돌아갔다가 다시 원래 위치로 돌아와 나머지 루틴을 수행할 수 있습니다. 또 한가지 차이점은 서브루틴은 진입점과 반환점이 단 하나밖에 없어 메인루틴에 종속적이지만, 코루틴은 진입지점이 여러개이기 때문에 메인루틴에 종속적이지 않아 대등하게 데이터를 주고 받을 수 있다는 특징이 있습니다. 코루틴은 주로 동시성을 필요로 하는 UNITY 등의 게임프로그래밍에서 많이 사용하는 개념이라고 합니다.&lt;/p&gt;
&lt;p&gt;파이썬에도 코루틴이 있습니다.
코루틴의 특징과 흐름을 살펴보면 다음과 같습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;파이썬에는 yield 문이라는 특수한 구문이 있습니다. return 처럼 동작하지만, 사실은 입력으로 동작합니다.(메인루틴에 종속적이 아니라 대등한 상태이기 때문에)&lt;/li&gt;
&lt;li&gt;next(coroutine)은 coroutine 함수의 첫번째 yield 까지 호출한다음 대기합니다. 두번째 next(coroutine)을 호출하면, 첫번째 yield 다음의 나머지 부분을 수행하고 다시 돌아와 그 다음 yield 까지 호출합니다. iteration 이 가능한곳까지 next 함수가 수행된 뒤에는 StopIteration 에러가 발생하게 됩니다.&lt;/li&gt;
&lt;li&gt;만약 yield 문이 특정 변수에 할당된다면, 만들어진 코루틴 객체에서 coroutine.send(value)를 호출해 주어야 합니다. 첫번째 coroutine 지점(yield)에 멈춰있는 상태에서 변수에 할당 되어야 하는데 아무런 값도 들어오지 않는다면 에러가 발생하게 됩니다. 즉, yield 를 통해서 메인루틴과 서브루틴간에 서로 값이 이동하면서 특정 로직을 수행하게 되는 것입니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;그럼 예를 살펴보도록 하겠습니다.&lt;/p&gt;
&lt;p&gt;첫번째 예제는 yield 값만 리턴하는 경우입니다. 코루틴 객체를 생성한 후 next() 함수를 통해서 첫번째 yield 문에 도달합니다. yield 문을 통해 메인루틴에 값을 전달한 후 코루틴 함수는 대기합니다. 다음 next()함수가 호출되면, 멈춰져 있는 yield 부분 다음의 로직을 수행한 다음 한바퀴 돌아 yield 부분에서 또다시 멈추게 됩니다. 아래의 예제에서는 next()를 무한정 호출할 수 있지만, 특정한 조건을 지정해주면 정해진 만큼만 next()를 호출할 수 있습니다. 더이상 호출할 수 없는 코루틴 함수를 next()로 호출하면 예외가 발생하게 됩니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def test1(i):
    print(&amp;#39;start test1 coroutine&amp;#39;)
    while True:
        yield i
        i += 1

a = test1(5)
next(a)    # start test1 coroutine 출력 후 5출력, yield i 부분에서 멈춰있다.
next(a)    # 멈춰진 yield i 부분 다음줄의 5 += 1(i=6)을 수행한후 다음 6을 출력하고 yield i에서 멈춘다.
next(a)    # 7을 출력하고 yield i에서 멈춘다.
next(a)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;두번째 예제는 코루틴과 메인루틴이 서로 통신하는 형태입니다. 위의 test1()과 다른점은 yield 구문을 특정 변수에 할당합니다. 이렇게 되면 처음 next()를 호출한 뒤 send(value) 함수를 호출하면 전달된 파라미터가 value 에 할당됩니다. 즉, b = test2(5), next(b)를 수행한 뒤 b.send(3)을 호출하면 8 이 출력된다는 말이죠. 그 다음은 next()함수와 마찬가지로 그 다음 yield 에 가서 멈춰 있게 됩니다.
위의 예제와 다른 점은 위 같은 경우에는 코루틴에서 메인루틴으로 일방적으로 값을 전달해줬다면, 아래 예제에서는 메인루틴과 서브루틴이 서로 값을 주고 받는 형태를 이루고 있습니다. 양방향 통신이 가능해진 것이죠. 하지만 실시간으로 서로 주고 받는 형태는 아니므로 반이중 통신이라 할 수 있겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def test2(i):
    print(&amp;#39;start test2 coroutine&amp;#39;)
    while True:
        value = yield i
        i += value

b = test2(5)
next(b)    # start test1 coroutine 출력 후 5출력, yield i 부분에서 멈춰있다.
b.send(3)    # yield를 통해 3을 전달하여 value가 3이 된다. 이후 i += value 줄을 거쳐 i=8이되고 한바퀴 돌아 8을출력, yield에서 멈춘다.
b.send(5)    # 5를 더해 i는 8이되고 8을 출력한다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;아직 저도 코루틴을 실제 프로젝트에서 많이 다뤄보지는 못했기에 활용법에 대해서 잘은 모릅니다. 검색을 통해 찾아 보았던 것은 수많은 파이썬 비동기 모듈에서 대부분 코루틴을 다루고 있다는 것입니다. 양 방향으로 통신이 가능하다는 것은 여러 함수를 동시에 호출하면서 서로간에 통신도 가능하다는 말이니 적절한 사용처가 아닐까 생각합니다. 또 생각해 볼 수 있는 것은 정해진 순서가 아닌 사용자의 입력에 따라서 동작이 바뀌는 기계학습 분야에도 많이 활용될 것 같다는 느낌이 드는군요.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[파이썬 3항 연산자 비교]]></title><description><![CDATA[여느 언어에나 코드 량을 줄이기 위한 다양한 기법들이 존재합니다.
그 중에서 대표적인 것 중 하나인…]]></description><link>https://blueshw.github.io/2016/01/22/python-conditional-ternary-operator/</link><guid isPermaLink="false">https://blueshw.github.io/2016/01/22/python-conditional-ternary-operator/</guid><pubDate>Fri, 22 Jan 2016 23:31:45 GMT</pubDate><content:encoded>&lt;p&gt;여느 언어에나 코드 량을 줄이기 위한 다양한 기법들이 존재합니다.
그 중에서 대표적인 것 중 하나인 3 항 연사자를 파이썬에서도 사용가능 합니다. 파이썬 언어의 장점 중에 하나가 타 언어에 비해 훨씬 적은 분량으로 똑같은 코드를 작성할 수 있는 것이기에, 3 항 연산자가 있는건 당연하다 할 수 있습니다.
3 항연산자는 일반적으로 아래와 같이 사용됩니다. (C, Java 등)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;result = condition ? when True : when False;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그런데, python 의 경우에는 위처럼 보통의 경우와 3 항 연산자가 조금 다릅니다.
다르기만 할뿐 아니라 3 항 연산자를 처리하는 방법이 한 가지가 아니라 두 가지나 있습니다.
예전에는 파이썬에서도 한 가지 방법(and 와 or)만 있었습니다만, 파이썬 2.5 버전부터 새로운 방법(if 와 else)이 나왔습니다.
한가지 형태의 연산만 있으면 될텐데 굳이 새로운 방법을 만든 이유는 뭘까요?
우선 첫번째 방법 부터 살펴보도록 하죠.&lt;/p&gt;
&lt;h3&gt;1. and 와 or 를 이용한 3 항 연산자&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# result = condition and when True or when False;
a = 10
b = 20
result = a == b and a-b or a+b    # 결과는 a+b = 30&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;삼항 연산자의 condition 이 True 면 and 뒤의 연산이 return 되고, condition 이 False 면 or 뒤의 연산이 return 됩니다.
C 나 Java 에서 사용하는 방식과 동일한 형태이지만, 단지 ’?’가 ‘and’가 되고, ’:‘가 ‘or’가 되는 것입니다.
이것이 가능한 이유는 그다지 어렵지 않게 이해할 수 있습니다.&lt;/p&gt;
&lt;p&gt;파이썬에서 a and b or c 라는 연산이 있습니다.
이 연산을 조금 변형시키면 (a and b) or c 로 바꿀 수 있겠습니다.
그런뒤 파이썬 인터프리터가 실행되면, 인터프리터는 우선 (a and b)의 a 를 확인합니다.
a 가 True 면 b 를 확인하고, a 가 False 면 (a and b)가 False 가 되므로 바로 c 를 확인하게 됩니다.
만약 a 가 True 일때 b 가 True 면 c 는 확인할 필요가 없으므로 b 가 리턴됩니다.
반대로 a 가 False 면, 바로 c 를 확인합니다. 이때, c 가 True 든 False 든간에 그 결과값을 무조건 return 하기 때문에 a 가 False 일때는 c 가 리턴된다는 것이죠.
이해가 가실지 모르겠네요(설명이…ㅠㅠ). 파이썬 콘솔로 직접 이것저것 해보시다 보면 아마 이해될거라 생각합니다.&lt;/p&gt;
&lt;p&gt;그런데 위 설명을 잘 뜯어보면 어딘가 문제가 있습니다.
어떤 문제인지 확인하기 위해 아래 예제를 살펴보겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;a = 10
b = 10
result = a == b and a-b or a+b    # 결과는 a+b = 20 ???????&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;a 가 10 이고 b 가 10 일때 a == b 는 True 가 되므로 result 는 당연히 a-b = 10 이 되야 하는데, 결과는 a+b = 20 이 되었습니다.
왜 그런걸까요? 3 항 연산자 공식에 문제는 없어 보이는데 말이죠.&lt;/p&gt;
&lt;p&gt;문제는 a and b or c 에서 b 가 0 일때 발생합니다.
무슨말이냐면, 컴퓨터 과학에서 0 이라는 것은 False 를 의미하기도 하죠. 그래서 a 가 True 라고 해도 b 가 0 이 되면 False 로 인지되기 때문에 결국에는 C 를 리턴하게 되는 것입니다.
왜 이런 문제가 발생하도록 3 항 연산자를 만들었는지 모르겠습니다만, 아마도 이 문제를 보완하기 위해서 파이썬 2.5 버전부터 if 와 else 를 사용한 3 항 연산자를 새로 만들게 된것 같습니다.&lt;/p&gt;
&lt;h3&gt;2. if 와 else 를 이용한 3 항 연산자&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# result = when True if condition else when False;
a = 10
b = 20
result = (a-b) if a == b else (a+b)    # 결과는 a+b = 30&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;if 문을 이용한 3 항 연산자는 파이썬 언어의 특징을 잘 보여줍니다.
결과가 먼저 나와 있고, 그 뒤에 조건(condition)이 있습니다.
만약 이 조건이 참이면 그대로 맨처음 연산을 리턴하고, 거짓이면 마지막 else 뒤의 연산을 리턴하게 됩니다.
이해하기 어렵지는 않습니다만, 처음 파이썬을 접한 사람들에게는 조금 생소한 코드 형태일 수도 있는데요.
일반적으로 사용하는 3 항 연산자와 구조가 달라서 그럴지도 모릅니다.
하지만 파이썬에 익숙해지다 보면, 금방 익숙해 질 수 있습니다.&lt;/p&gt;
&lt;p&gt;이러한 형태의 코드는 for 문을 사용하여 list 를 만들때도 비슷하게 적용할 수 있는데요.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;list = [ idx for idx in range(10)]
# list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;루프의 결과를 맨앞에 나열하고 그 뒤에 조건이나 for 문을 나열하여 여러 줄로 만들어야 할 코드를 한줄로 만들어 버렸습니다.
보통 다른 언어에서는 두줄내지 세줄은 할애해야 할텐데 파이썬에서는 단 1 줄로 쉽게 처리할 수 있습니다.
아마 이러한 코드가 파이썬이 추구하는 형태의 코드 스타일이 아닐까 생각합니다.
이 외에도 튜플을 만들때나 두 변수간의 값을 교환할 때도 다른 언어와는 다르게 훨씬 간단하게 처리할 수 있습니다(직접 찾아보시길).&lt;/p&gt;
&lt;h3&gt;결론 :&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;and 와 or 를 이용한 3 항연산자는 가급적 지양하고, if 와 else 를 이용한 3 항 연산자에 익숙해지자!&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[얕은 복사(shallow copy) vs 깊은 복사(deep copy)]]></title><description><![CDATA[이번에는 객체의 복사에 대해서 알아보려고 합니다. 객체의 복사는 크게 얉은 복사(shallow copy)와 깊은 복사(deep copy…]]></description><link>https://blueshw.github.io/2016/01/20/shallow-copy-deep-copy/</link><guid isPermaLink="false">https://blueshw.github.io/2016/01/20/shallow-copy-deep-copy/</guid><pubDate>Wed, 20 Jan 2016 23:31:45 GMT</pubDate><content:encoded>&lt;p&gt;이번에는 객체의 복사에 대해서 알아보려고 합니다. 객체의 복사는 크게 얉은 복사(shallow copy)와 깊은 복사(deep copy)로 나뉩니다. 얼핏 들으면 단어 자체의 의미가 모호하게 느껴질 수도 있습니다만, 사실은 크게 어려운 개념은 아닙니다. 하지만 주의해서 사용하지 않으면 크나큰 문제를 야기할 수도 있습니다. 이미 잘 알고 있다 하더라도 확실히 짚고 넘어 간다는 생각으로 다시한번 정리해 보시면 좋을것 같네요&lt;/p&gt;
&lt;h3&gt;1. 단순 객체복제&lt;/h3&gt;
&lt;p&gt;변수만 복사하다 보니 바라보는 객체는 당연히 동일하겠죠.
즉, 두개의 변수 중 하나만 변경되어도 나머지 하나도 동일하게 수정되는 현상이 발생하게 됩니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;a = [1, 2, 3, 4]
b = a     # shallow copy
print(b)    # [1, 2, 3, 4]
b[2] = 100   # b의 item 변경
print(b)    # [1, 2, 100, 4]
print(a)    # [1, 2, 100, 4], a의 item도 수정됨!!&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;리스트를 만들어(파이썬에서 대괄호’[ ]‘는 list) 1 에서 4 까지 네개의 숫자를 넣고 a 에 할당했습니다.
그러면 a 는 리스트 객체의 주소를 바라보는 변수가 되는 것이죠.
그런뒤 a 를 b 에 할당해 주었습니다. 그러면 b 는 a 와 같은 객체의 주소를 바라보게 됩니다.&lt;/p&gt;
&lt;p&gt;문제는 a 또는 b 를 수정하게 되면 문제가 발생합니다.
위에서 처럼 b 의 세번째(2) 값을 3 에서 100 으로 바꿔주게 되면, 당연히 b 는 [1, 2, 100, 4] 처럼 출력됩니다.
그런데 변경되지 않을 거라고 예상했던 a 또한 b 와 같이 [1, 2, 100, 4] 로 수정되어버렸습니다.
이는 a 와 b 가 동일한 객체를 참조하기 때문에 발생하는 문제입니다.&lt;/p&gt;
&lt;p&gt;한가지 주의할 점은 위의 경우처럼 복사된 참조 변수를 수정했을때,
처음에 할당한 참조 변수의 값 역시 똑같이 수정되는 것은 리스트와 같은 변경가능(mutable) 객체일 때만 해당한다는 것입니다.
숫자나 문자열과 같은 불변의(immutable) 객체일때는 위의 경우가 해당되지 않습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;a = 10
b = a
print(b)    # 10 출력력
b = &amp;quot;abc&amp;quot;
print(b)    # abc 출력
print(a)    # 10 출력&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위와 같은 결과가 나타나는 이유는, 불변의 객체이기 때문입니다.
말장난 하는것 같아 보이지만, 불변의 객체란 값이 바뀌지 않는 객체를 뜻하죠.
그렇기 때문에 참조변수를 수정한다는 것은 같은 주소의 값(value)이 바뀌는 것이 아니라 그 변수에 새로운 객체가 할당되는 것을 뜻합니다.&lt;/p&gt;
&lt;h3&gt;2. 얉은 복사(shallow copy)&lt;/h3&gt;
&lt;p&gt;얉은 복사의 경우는 어떨까요? 단순 복사와 어떤 차이가 있을까요?
단순 복제와 얉은 복사의 차이점은 복합객체(리스트)는 별도로 생성하지만 그 안에 들어가는 내용은 원래와 같은 객체 객체라는 점입니다.
예제로 살펴보면 아래와 같습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import copy

a = [1, [1, 2, 3]]
b = copy.copy(a)    # shallow copy 발생
print(b)    # [1, [1, 2, 3]] 출력
b[0] = 100
print(b)    # [100, [1, 2, 3]] 출력,
print(a)    # [1, [1, 2, 3]] 출력, shallow copy 가 발생해 복사된 리스트는 별도의 객체이므로 item을 수정하면 복사본만 수정된다. (immutable 객체의 경우)

c = copy.copy(a)
c[1].append(4)    # 리스트의 두번째 item(내부리스트)에 4를 추가
print(c)    # [1, [1, 2, 3, 4]] 출력
print(a)    # [1, [1, 2, 3, 4]] 출력, a가 c와 똑같이 수정된 이유는 리스트의 item 내부의 객체는 동일한 객체이므로 mutable한 리스트를 수정할때는 둘다 값이 변경됨&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;주석에서 잘 설명하고 있지만, 리스트 내에 리스트가 있는 경우에 얉은 복사(b = copy.copy(a))가 이뤄지더라도 리스트 내의 내부 리스트까지 별도의 객체로 복사가 되는것은 아닙니다.&lt;/p&gt;
&lt;p&gt;위의 예제에서 b 에서 첫번째 요소(숫자)를 변경하였을때 a 가 변경되지 않은 것은 그 요소가 immutable 하기 때문입니다.
immutable 하다는 것은, 요소가 수정되는 것이 아니라 그저 다른 값으로 대체된다고 볼 수 있죠.
그렇기 때문에 b 에서 변경된 요소가 a 에는 반영되어 있지 않은 것이죠.(두 리스트는 다른 객체이므로..)&lt;/p&gt;
&lt;p&gt;그러나 c 의 경우는 좀 다릅니다.
a 를 복사하여(c = copy.copy(a)) c 를 만듭니다.
그리고 c 의 두번째 요소(리스트)에 새로운 값을 추가합니다.
출력해보면 a 와 b 의 경우처럼 c 에 값을 수정했을때 a 는 수정되지 않을거라 기대되지만, 실제는 그렇지 않습니다.
c 의 내부리스트를 수정하게 되면 a 의 내부리스트 또한 바뀌게 되는데요.
그 이유는 a 와 c 의 내부리스트는 같은 객체를 참조하기 때문입니다.
b 의 경우에도 같은 객체라 말할 수도 있지만, 이 둘의 중요한 차이는 그 객체가 mutable 하냐 immutable 하냐의 차이입니다.
mutable 한 경우에는 값이 수정될수 있지만, immutable 한 경우에는 값이 수정되는 것이 아니라 아예 새로운 객체로 변경되는 것이죠.
그래서 위와 같은 차이가 나타나게 되는 것입니다.&lt;/p&gt;
&lt;h3&gt;3. 깊은 복사(deep copy)&lt;/h3&gt;
&lt;p&gt;mutable 한 내부객체(내부리스트)의 문제를 해결하기 위해서는 얉은 복사가 아닌 깊은 복사(deep copy)를 해야 합니다.&lt;/p&gt;
&lt;p&gt;얉은 복사가 복합객체(리스트)만 복사되고 그 안의 내용은 동일한 객체를 참조한다면,
깊은 복사의 경우에는 복합객체를 새롭게 생성하고 그 안의 내용까지 재귀적으로 새롭게 생성하게 됩니다.&lt;/p&gt;
&lt;p&gt;그래서 깊은 복사를 하게 되면, 처음에 만들었던 객체와 복사된 객체가 전혀 달라지기 때문에 어느 한쪽을 수정한다고 해서 다른 한쪽이 영향 받는 일은 없게되겠죠.&lt;/p&gt;
&lt;p&gt;파이썬에서는 copy 모듈의 deepcopy()라는 메서드를 통해 깊은 복사를 손쉽게 구현할 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import copy

a = [1, [1, 2, 3]]
b = copy.deepcopy(a)    # deep copy 실행
print(b)    # [1, [1, 2, 3]] 출력
b[0] = 100
b[1].append(4)
print(b)    # [100, [1, 2, 3, 4]] 출력
print(a)    # [1, [1, 2, 3]] 출력&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;정리해보면,&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;단순복제는 완전히 동일한 객체,&lt;/li&gt;
&lt;li&gt;얉은복사(shallow copy)는 복합객체(껍데기)만 복사, 그 내용은 동일한 객체&lt;/li&gt;
&lt;li&gt;깊은복사(deep copy)는 복합객체 복사 + 그 내용도 재귀적으로 복사&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[[django] 장고 트랜잭션 활용]]></title><description><![CDATA[최근에 python + django 로 프로젝트를 진행하고 있습니다. 두달전부터 시작했으니 아직은 python, django…]]></description><link>https://blueshw.github.io/2016/01/16/django-migration/</link><guid isPermaLink="false">https://blueshw.github.io/2016/01/16/django-migration/</guid><pubDate>Sat, 16 Jan 2016 23:31:45 GMT</pubDate><content:encoded>&lt;p&gt;최근에 python + django 로 프로젝트를 진행하고 있습니다. 두달전부터 시작했으니 아직은 python, django 모두 초보라 할 수 있겠죠. 프로젝트를 같이 진행하는 동료들도 저 처럼 거의 저와 비슷한 상황입니다. 그러다보니 프로젝트를 진행하면서 막히는 부분이 생길때마다 검색을 해보거나 파이썬 콘솔을 이용하여 검증, 또는 소스를 뜯어보며 작동원리를 파악하곤 합니다. 이 삽질과도 같은 수많은 과정들이 한순간에 끝나버리는게 아쉬워 블로그에 남겨보기로 결정했습니다. 시간이 남아돌아 글을 쓰는것은 아니지만, 글을 쓰는 행위는 어렴풋이 이해하고 있는 것들을 확실히 나의 지식으로 만드는 최고의 방법이라 생각하기에 시간을 쪼개서 지속해 나갈 생각입니다. 여러가지 부분을 다루겠지만, 체계 따위는 없습니다. 그때 그때 떠오르는 것, 또는 프로젝트 진행중에 특정부분이 막혀 정리가 필요한 시점에는 그 부분을 다루려고 합니다.&lt;/p&gt;
&lt;p&gt;첫번째는 트랜잭션(transaction)입니다. 트랜잭션이 뭐냐고 물었을때 대부분의 프로그래머가 잘 알고 있을거라 생각합니다. 간단히 말해 작업 단위라 할 수 있는데, 여러개의 프로세스가 묶여져 마치 하나처럼 동작하는 방식이라 할 수 있겠습니다. 그렇기 때문에 성공 아니면 실패 두가지 결과밖에 존재하지 않겠죠. 좀더 개발적(?)인 언어로는 이렇게 말할수도 있습니다. 데이터베이스를 저장하고 수정하는 여러 작업을 하나의 쿼리로 처리할 수 없기 때문에 여러개의 쿼리로 나눠서 실행해야 하는데, 그 결과의 원자성을 보장해주기 위해 동일한 DB connection 객체를 사용하는 기술이라 할 수 있습니다. 자세한 내용은 직접 검색해 보시기 바랍니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;django 는 1.8.5 버전을 사용하였고, python 은 3.4.3 버전을 사용하였습니다.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;1. 데코레이터(decorator)를 이용한 python + django 트랜잭션&lt;/h3&gt;
&lt;p&gt;django 에서 트랜잭션을 이용하는 가장 쉬운 방법으로 데코레이터를 이용하는 방법입니다.
데코레이터를 이용하게 되면, 메서드 안에는 코드를 삽입할 필요가 없습니다.
“@transaction.atomic” 이라는 데코레이터를 붙여주기만 하면 끝입니다.
django 에서 기본적으로 제공해주는 데코레이터이므로, 따로 모듈을 설치해줄 필요도 없습니다.&lt;/p&gt;
&lt;p&gt;가장 간단하게 atomic(원자성)한 트랜잭션을 처리하기 위한 손쉬운 방법이죠.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;from django.db import transaction

@transaction.atomic
def transaction_test1(arg1, arg2):
    # start transaction
    a.save()

    b.save()
    # end transaction&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2. with 명령어를 이용한 트랜잭션&lt;/h3&gt;
&lt;p&gt;메서드 전체가 아닌 메서드의 일부분만 트랜잭션으로 묶어줄 필요가 있을 때 사용합니다.
트랜잭션으로 묶일 부분을 직접 지정해줘야 하는 불편함(?)이 있지만, 데코레이터와 마찬가지로 비교적 간단하게 처리가 가능합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;from django.db import transaction

def transaction_test2(arg1, arg2):

    a.save()    # 항상 save 처리됨, 예외가 발생할 경우 에러 발생

    with transaction.atomic():
        # start transaction
        b.save()

        c.save()
        # end transaction&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3. savepoint 를 직접 지정해 주는 트랜잭션&lt;/h3&gt;
&lt;p&gt;1 번과 2 번의 방법의 경우, 메서드 내에서(트랜잭션으로 묶여져있는) exception 이 발생하더라도 저절로 롤백이 되기 때문에 예외처리를 따로 해 줄 필요는 없습니다.
하지만, 3 번의 경우에는 savepoint 및 cummit 지점을 직접 지정해 주기 때문에 예외처리 또한 별도로 처리되어야 합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;from django.db import transaction

def transaction_test3(arg1, arg2):

    a.save()

    sid = transaction.savepoint()
    # start transaction
    try:

        b.save()

        c.save()

        transaction.savepoint_commit(sid)
        # end transaction
    except Exception
        # 트랜잭션 내에서 에러 발생시 롤백처리
        transaction.savepoint_rollback(sid)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 세가지가 django 에서 트랜잭션을 처리하는 방법입니다. 간단한 트랜잭션 함수를 호출할 때는 위의 세가지 중에 알맞은 방법을 선택해서 처리하면 되겠습니다. 좀 더 복잡한 상황을 한번 살펴보도록 하죠.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;from django.db import transaction

def method1():

    with transaction.atomic():

        # 첫번째 트랜잭션 메서드
        first_transaction()

        # 두번째 트랜잭션 메서드
        second_transaction()


@transaction.atomic
def first_transaction():

    a.update()

    b.update()


@transaction.atomic
def second_transaction():

    c.update()

    d.update()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 경우에는 트랜잭션 메서드 두개를 묶어서 또다른 트랜잭션을 구성하였습니다.
각각의 메서드는 독자적읜 트랜잭션이기 때문에 각 메서드 내에서 에러가 발생하더라도 데이터의 원자성은 유지될 것입니다.
문제는 first&lt;em&gt;transaction() 메서드는 아무 문제 없이 commit 되었는데, second&lt;/em&gt;transaction() 메서드에서 예외가 발생했을 때입니다.&lt;/p&gt;
&lt;p&gt;이렇게 되면, 첫번째 트랜잭션만 처리가 되고 두번째는 롤백이 됩니다.
의도된 로직이면 아무 문제 없겠지만, 두 트랜잭션 메서드가 하나의 트랜잭션으로 묶여 있어야 하는 상황이라면 엄청난 문제가 발생할 수도 있습니다.
데이터의 원자성을 유지하기 위해서는 first&lt;em&gt;transaction()과 second&lt;/em&gt;transaction()을 묶어주는 또다른 트랜잭션을 만들어 줘야 합니다. 위에서는 with transaction.atomic(): 으로 묶어 줬지만, 데코레이터를 써도 상관은 없습니다. 다만, 가장 상위의 메서드가 django 의 view 에 해당하는 경우가 많기 때문에 불필요한 부분까지 같이 묶어주고 싶지 않아서 with 구문을 이용한 것입니다.&lt;/p&gt;
&lt;h3&gt;결론:&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;django 트랜잭션은 쉽다.&lt;/li&gt;
&lt;li&gt;트랜잭션을 겹쳐서 사용할 경우, 주의해서 사용해야 한다. (반드시 테스트 해볼것!!)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[난 2년동안 다녔던 방송통신대학에 대한 회고]]></title><description><![CDATA[…]]></description><link>https://blueshw.github.io/2015/06/29/remind-of-knou/</link><guid isPermaLink="false">https://blueshw.github.io/2015/06/29/remind-of-knou/</guid><pubDate>Mon, 29 Jun 2015 23:30:00 GMT</pubDate><content:encoded>&lt;p&gt;저는 비전공자입니다. 그래서인지 소프트웨어 개발일을 하면서 늘 비전공자 딱지를 달고 일을 해왔던거 같습니다. 사실 학위라는게 그 사람의 실력을 말해주는 것도 아니라 큰 의미가 없다는게 평소의 제 생각이기도 합니다만, 막상 일을 하다보면 내가 잘 모르거나 생소한 용어가 나올때마다 비전공자라서 그런건 아닌가라는 생각을 떨쳐낼수 없더군요. 나름대로 컴퓨터 사이언스에 대한 기본적인 지식을 쌓는데 노력도 해보았지만 만족스럽다는 생각이 든적은 한번도 없었습니다. 어떤 문제에 봉착하게 되면, 내가 뭘 모르는지 조차도 모르는 상황이 생겨버려서 쉽게 포기해버리기도 하더라구요. 이건 아무래도 체계적이고 연쇄적인 학습이 이뤄지지 않는 탓이라 생각하고 스스로를 위로할 수 밖에 없었습니다. 이렇게 쉽게 떨어져나가지 않는 비전공자의 족쇄를 영원히 끊어버리기 위해 학위를 따기로 결심했었습니다. 하지만, 현실적으로 오프라인 대학을 선택하는건 무리였기에 온라인으로 학위 취득이 가능한 방법을 찾아보았죠. 결국 선택지는 사이버대학이냐 방송통신대학이냐 였습니다.&lt;/p&gt;
&lt;p&gt;우선 사이버대학의 장점이라면, 소속 학교의 시설을 이용할 수 있고 시험을 집에서 치르기 때문에 학위취득이 수월하다는 것입니다. 하지만 사립이라 학비가 비싸고 학위취득이 수월하다보니 평소에는 공부에 소홀하게 되어 실력향상에 큰 도움이 안된다는 단점이 있죠. 반면에, 방송통신대학은 시험장에서 시험을 보고, 학기당 학교에 나가야하는 출석수업이 며칠 포함되기 때문에 직장인들에게는 조금 부담스럽다는 단점이 있지만, 그만큼 노력에 따라 점수를 얻을 수 있고 실력향상에도 어느정도 도움이 된다는 장점이 있죠. 그리고 무엇보다 학비가 저렴한편입니다. 저는 학위도 중요했지만, 실제로 공부를 하고 싶다는 생각이 강했기에 사이버대학이 아닌 방송통신대학을 선택했습니다. 방송통신대학은 보통 ‘방통대’, ‘방송대’ 등으로 불리곤 합니다(이하 방송대). 인터넷에 떠도는 여러 글이나 커뮤니티를 살펴보면, 방송대를 다닐까 고민하셨던 분들이나 직접 다녀본 사람들이 방송대는 빡빡해서 졸업하기 어렵다고들 하더라구요. 그것도 정규 학기만에 졸업하기는 더더욱 어렵다고들 하죠. 보통 4 년과정일때 5~7 년 정도를 생각한다고 할 정도니까요.&lt;/p&gt;
&lt;p&gt;괜한 말들에 겁먹어 봤자 직접 겪어보지 않으면 모르는법. 과감하게 등록을 했습니다. 방송대를 다녀야겠다고 결심한 것이 재작년 여름이라 가을학기부터 다니기로 했답니다. 나중에 알게 된 사실이지만, 어느정도 수준 소득 아래의 연봉을 받고 계신 분들은 등록한 학기부터 국가장학금을 신청할 수 있답니다. 저는 그것도 모르고 입학금과 수업료를 내고 말았죠. 등록금이라 하기에는 너무 싼 40 만원도 안하는 돈이긴 하지만, 나이가 있고 가족이 있는 사람들에게는 결코 쉽게 쓸 수 있는 돈은 아닙니다. 하지만, 첫 학기라 그랬을까요? 아니면 사이버대학에 비해서 3~4 배 정도 저렴한 학비 때문이었을까요, 학교를 다시 다닌다는 마음에 선뜻 결제를 해버렸습니다. 당시 교재비까지 포함해도 대략 40 만원 안팍이었던걸로 기억합니다. 등록하실때 반드시 주의할점은, 교재비는 결제하지 마시라는 겁니다. 교재비는 해당 학년의 학기의 모든 과목에 대한 교재비입니다. 만약에 미리 등록된 과목이 아닌 다른 학년이나 다른 학과의 수업을 들으려고 하면 미리 결제한 교재는 쓸모없게 되버리겠죠. 그래서 꼭 수강신청을 완료한 후에 자신이 등록한 과목의 교재를 사야합니다.&lt;/p&gt;
&lt;p&gt;방송통신대학의 강의는 이름 그대로 방송과 통신을 통해서 이뤄집니다. 가장 많이 이용하는 매체는 세가지 인데, 웹을 통한 강의, 스마트폰을 이용한 강의, 그리고 TV 를 통한 강의가 있죠. 이 중 TV 에서 나오는 강의는 그 수가 많지 않습니다. 그래서 대다수는 웹을 이용하게 되죠. 하지만, 눈 뜨기 무섭게 만원 지하철을 뚫고 회사에서 전쟁같은 하루를 보내는 직장인들에게 퇴근 후 웹을 이용한 강의를 듣는다는 것은 웬만한 의지를 가진 사람이 아닌 이상 힘들다고 생각합니다. 그래서 저는 지하철을 이용하기로 했습니다. 요즘에는 어딜가든 내 분신처럼 따라다니는 스마트폰이 있기 때문에 내가 어디에 있던지 스마트폰을 이용해서 강의를 들을 수 있습니다. 화면이 작아 조금 보기 힘들지도 모르겠습니다만, 5 인치 정도 되는 크기의 스마트폰이라면 충분히 시청 가능하죠. 그 작은 화면으로 미드와 영화는 충분히 잘 보면서 강의는 화면이 작아서 못듣겠다는건 그냥 핑계꺼리일뿐이겠죠.&lt;/p&gt;
&lt;p&gt;지난 2 년 동안 거의 모든 강의는 지하철을 타고 이동하면서 들었습니다. 출근할때 한개, 퇴근할때 한개 들으면(집이 좀 멀어야겠죠^^ 저는 인천에서 강남으로 출퇴근해서 충분히 가능했죠) 학기 중에 충분히 모든 강의를 듣고도 남습니다. 한 과목이 15 강으로 이뤄져있고, 보통은 6 과목(18 학점)을 듣기 때문에 총 90 개의 강의로 이뤄져있습니다. 하루에 2 개씩 듣고 주중에만 듣는다고 가정하더라도 9 주일이면 충분히 시청할 수 있습니다. 중간, 기말, 대체시험 등 시험기간을 제외하더라도 충분한 시간입니다. 결국 시간 없다는 말은 핑계에 불과하단 얘기죠. 혹시라도 일이 너무 많아 주말에도 철야를 해야할 정도의 회사라면 하루빨리 그만두는게 몸과 정신건강에 좋습니다.&lt;/p&gt;
&lt;p&gt;조금 자랑 섞인 말을 해보려고합니다. 저는 학사편입으로 3 학년부터 시작했습니다. 매 학기마다 듣고 싶은 강의만 골라서 들었고, 다양한 교양수업과 타학과 전공수업(불문과, 미디어학과, 통계학과 등)도 수강하면서 나름대로 의미있는 강의를 들으려고 노력했습니다. 주어진대로만 수강하지 않고 저 자신의 취향과 의지가 들어가다보니 나름의 동기부여도 됐을뿐 아니라 듣고싶었던 과목을 듣는거라 학점을 취득하기도 훨씬 수월했습니다. 그 결과 3 번의 학기(마지막은 아직 안나왔으니)동안 총 2 번의 성적우수 장학금을 받게 되었습니다. 총 평점도 4.3 만점에 4.1 이 넘는답니다.&lt;/p&gt;
&lt;p&gt;사실 방송통신대학에서 점수를 따는건 그리 어려운 일이 아닙니다. 전체 강의를 한번 다 듣고 난뒤에는 지금까지 쌓여있는 기출문제와 워크북의 문제만 풀어봐도 충분히 만점에 가까운 점수를 얻을 수 있습니다. 방송대에서 A 이상의 학점을 받으려면 90 점 이상의 점수를 획득해야하는데, 물론 쉬운 일은 아닙니다. 하지만, 주어진 강의와 기출, 그리고 워크북만 잘 숙지한다면 그리 어렵지도 않습니다. 교수님들이나 조교들도 방송대 문제를 매년 새롭게 만들거나 하지는 않기 때문입니다. 하지만 과목이 신설됐거나 교수님이 바꼈을 때와 같이 상황이 바꼈을 때는 주의할 필요가 있습니다. 출제경향도 알 수 없을 뿐더러 참고할 사항이 없기 때문에 확실한 준비를 하기가 어렵습니다. 이럴때는 들었던 강의를 여러번 다시 돌려보거나, 교재 위주로 공부할 것을 추천 드립니다. 결국에는 강의하시는 교수님들도 자기가 말하지 않은 것에 대한 문제는 출제하지 않으시니까요.&lt;/p&gt;
&lt;p&gt;그리고 방송대에서 큰 문제중 하나는 바로 졸업논문이랍니다. 원격으로 강의를 수강하면서 논문이라뇨. 정말 청천벽력같은 일이었습니다. 시작도 안해보고 그 부담감 때문에 논문이 아닌 다른 방법이 없나 찾아보았습니다. 구하는자에게 길이 있다는 말이 딱 맞는것처럼 논문을 쓰지 않고 졸업할 수 있는 방법이 있더군요. 바로 자격증!!! 제가 다닌 컴퓨터과학과의 경우에는 정보처리기사와 전자계산기조직응용기사라는 이름도 거창하게 긴 두 개의 자격증을 취득하면 논문을 쓰지 않아도 되죠. 정보처리기사를 이전에 취득했기에 다행이다 싶던 찰나, 자세히 살펴보니 2005 년부터는 재학중 취득한 자에게만 허용된다고 하더라구요. 그래서 울며겨자먹기로 듣도보도 못한 전자계산기조직응용기사라는 자격증에 대해 알아봤습니다. 뭐, 정보처리기사와 비슷하긴한데, 문제는 실기!!!! 직접 전자회로를 만들어서 제출하는게 실기!!! 이런…ㅠㅠ 그래도 방법이 있었으니, 실기(필답형 80 + 실기형 20)에서 60 점을 받으면 합격인데, 필답형 80 점중에 60 점을 취득하면 실기형은 출석만해도 된다는 거!! 뭐 이런 자격증이 있나 싶었지만, 논문은 죽어도 쓰기 싫어서 한번 해보기로 했지요. 결과는 한번에 취득!!!&lt;/p&gt;
&lt;p&gt;아직 마지막 학기의 결과는 나오지 않았지만, 가채점 해본 결과 무난하게 졸업 가능할거라 생각합니다. 총 2 년간 4 학기를 다닌다는게 누가 볼 때는 쉬운 일이 아닐 수 있겠습니다만, 궁한 사람에게는 그리 어렵지 않는 길이기도 합니다. 남들이 무언가에 도전하고 내가 생각하기에는 정말 어렵게 보이는 일을 하고 있다고 해서 미리 겁먹을 필요는 없습니다. 무슨 일이든 막상 해보면 생각보다 어렵지 않고 정말로 절실히, 격렬하게 그 일이 되길 원한다면 주위의 모든 것들이 그 일이 되도록 도와줄 것이기 때문입니다. 방송대 2 년은 학위보다는 도전의 시작이라는 느낌입니다. 이제 시작되었고 앞으로 살면서 또다시 수많은 도전에 직면할텐데 그때마다 좌절하지 않고 그 일들을 성공으로 바꿀 수 있는 밑거름이 된 2 년이라 생각할랍니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[건축에서 프로그래머로(7) – 안드로이드 앱을 만들자!!]]></title><description><![CDATA[안드로이드 개발 전문가 과정에 합격했지만, 올레 에코노베이션과 마찬가지로 T 아카데미에서도 선수과목이 필요했습니다. 그것도 에코노베이션과 똑같은…]]></description><link>https://blueshw.github.io/2015/03/28/from-architect-toprogrammer-7/</link><guid isPermaLink="false">https://blueshw.github.io/2015/03/28/from-architect-toprogrammer-7/</guid><pubDate>Sat, 28 Mar 2015 16:19:50 GMT</pubDate><content:encoded>&lt;p&gt;안드로이드 개발 전문가 과정에 합격했지만, 올레 에코노베이션과 마찬가지로 T 아카데미에서도 선수과목이 필요했습니다. 그것도 에코노베이션과 똑같은 3 일짜리 자바 고급강의!! 그 때의 기억이 떠오르면서 합격했다는 뿌듯함과 자신감은 사라지고 또다시 불안감이 저를 휘감았습니다. 하지만 어쩌겠습니까? 또다시 지난번처럼 도망쳐버리기에는 돌아갈 곳도 없는 상황에서 사치에 불과하다는걸 알고 있었습니다. 그래서 일단 부딪혀보자는 마음을 가지고 면접때와 같이 낙성대 역에서 마을버스에 올랐습니다. 도착한 T 아카데미, 배정받은 강의실로 들어가 일단 앞쪽에 자리를 잡았습니다. 그러고는 주위를 둘러봤습니다. 대부분 저보다는 어린 대학생들처럼 보였습니다. 그 친구들을 둘러보면서, 지금 실력이 저 어린 친구들보다 훨씬 떨어진다는 생각에 자신이 더욱 작게 느껴졌습니다. 혼자 감상에 빠져있다가 강의가 시작될 무렵, 강의실 앞으로 형님처럼 보이는 한 분이 헐레벌떡 강의실에 도착했고, 마침 비어있던 제 옆자리에 자리를 잡으셨습니다. 훗날 이 만남은 제게 큰 힘이 되는데요. 좀 과장해서 말하면, 이 형님이 없었다면 아마 저는 안드로이드 전문가 과정에서 중도 하차하지 않았을까 생각할 정도랍니다.&lt;/p&gt;
&lt;p&gt;자바 고급 강의가 시작되었고, 시간이 점점 흐르면서 에코노베이션과는 뭔가 다름을 느꼈습니다. 사실 안드로이드를 위한 자바 고급 강의에서 DAO 와 DTO 와 같은 자바 서블릿에서나 사용하는 개념들이 등장할 필요가 없지요. 안드로이드 앱을 만들때도 DB 를 다루고 쿼리를 다루지만, 그렇게 중요하지는 않다고 생각합니다. 이런 관점에서 T 아카데미에서 진행하는 자바 강의는 정말 딱 필요하다 싶을 정도의 내용들로 이뤄졌습니다. 주로 인터페이스와 상속 구조 및 사용하는 방법이나 각종 자료구조의 응용 등의 내용이었습니다. 학원에서 배웠던 내용, 혼자서 자바 서적을 탐독하면서 익혔던 개념들이 살아나면서 이해가 되기 시작했지요. 물론 완벽하진 못했습니다. TreeMap 이나 TreeSet 등 잘 접해보지 못했던 자료구조를 배울때나 강사님이 내준 과제를 해결하는데는 주변 사람의 도움이 필요했었습니다. 이 때 바로 옆에 앉아 계시던 형님의 역할이 컸습니다. 제가 이해하지 못하고 있거나 과제를 진행하지 못하고 있을때는 친절하게 먼저 문제가 뭔지 물어봐주셨고, 친절하게 설명해주셨지요. 많은 도움이 됐습니다. 이후에는 모르는 문제가 생겨도 의지할곳이 있다고 생각하니 에코노베이션에서 강의를 들을때처럼 당황스럽지도 않았고 마음에는 안정감이 생겼죠.&lt;/p&gt;
&lt;p&gt;그렇게 무사히 3 일의 자바 고급강의를 마치고 돌아오는 월요일부터 본격적으로 안드로이드 강좌에 돌입했습니다. 안드로이드는 완전 처음이었죠. 관련 책을 구매해서 한번 훝어본적은 있지만, 아직까지 완전히 처음이라고 볼수 있는 정도였지요. 개발하시는분들은 다들 아시겠지만, 안드로이드 응용프로그램은 JAVA 를 기반으로 만들어졌습니다. 물론 자바 JVM(자바가상머신) 대신 달빅이라는 모바일에 최적화된 가상머신을 사용하고 있지요. 안드로이드가 자바 기반으로 이뤄져 있지만, 사실상 자바와는 별도로 동작한다고 봐도 무방하다 생각합니다.&lt;/p&gt;
&lt;p&gt;안드로이드 전문가 과정은 두달간 진행되었습니다. 그 중 한달은 안드로이드 이론과 개념에 대한 강의로 진행되었고, 나머지 한달은 실제 프로젝트를 만드는 것으로 진행되었습니다. 안드로이드를 배우는 기간 동안은 학원에서는 절대로 느끼지 못했던 프로그래밍의 재미에 대해서 알게 되었지요. T 아카데미에서는 강의실 공간을 수강생들을 위해 밤늦게까지 개방해서 강의와 프로젝트에 집중하여 작업할 수 있도록 배려해 주었고, 덕분에 이해가지 않는 부분이 발생하거나 문제가 생겼을 때 강의실에 남아있던 형님과 동생들과 함께 문제를 해결해 나갈수 있었죠. 힘들때도 있었습니다. 도무지 개념이 이해가지 않을 때는 내가 프로그래밍과 맞지 않은건 아닌지 고민하기도 했고, 진지하게 중간에 그만둘까 생각해보기도 했습니다. 하지만, 강사님 주변의 강의를 같이 듣던 친구들덕에 꿋꿋하게 버틸수 있었지요.&lt;/p&gt;
&lt;p&gt;그렇게 한달동안 이론강의를 들었지만, 이정도로 과연 내가 앱을 만들 수 있는지 의심이 들긴 했습니다. 아무리 한달내내 안드로이드 강의를 듣고 실습을 했다하더라도 온전한 하나의 프로그램(앱)을 만드는데는 이론의 이해만으로는 부족할거라 생각했지요. 가령 어떤 기능을 만드려면 나름의 설계와 시나리오가 필요합니다. 하지만 이건 이론을 이해했다고 잘 할수 있는건 아닙니다. 댜수의 프로그래밍 경험을 통한 문제해결능력을 키워야지만 가능하지요. 저는 다른 친구들에 비해서 이런 경험이 턱없이 부족했습니다. 부족한게 아니라 아예 없었죠. 그래서 저는 모든게 처음이었습니다.&lt;/p&gt;
&lt;p&gt;우선 어떤 앱을 만들것인지 결정하고 기획서를 작성한 뒤 DB 설계, 클래스 설계 등의 과정을 거치고 드디어 실제로 코딩을 할 시간이 다가왔습니다. 기획서에 작성한것처럼 어떤 기능을 구현해야 하는데 당췌 뭐부터 시작해서 진행해야할지 막막하더군요. 옆에 계신 형님께 이런 고충을 말하니 일단 원하는 기능이 있다면 구글 검색을 해보라는 것이었습니다. 그래서 말 그대로 관련 기능에 대해 검색해봤습니다. 최대한 비슷한 형태로 구글검색을 해보니 대부분은 구글이 답을 주더군요!! 완전 신세계였어요. 검색을 통해서 하나하나 찾아가다보니 어느정도 구색이 맞춰졌습니다. 기본적인 기능에 대해서는 대부분 구글을 통해서 찾아보고 그래도 모르는게 생겨면 옆에 계신 형님께 도움을 구했지요. 사실 그 형님도 배우러 오신거고 본인 프로젝트 진행하기에도 바쁠텐데 저 같은 완전 초보 옆에 앉은 죄(?)로 시간을 많이 뺏기셨지요. 그래도 항상 친절하게 알려주셨습니다.&lt;/p&gt;
&lt;p&gt;위에서 잠깐 언급했지만, T 아카데미 전문가 과정은 정말 알찬 강의입니다. 한달간 이론을 배운 뒤 프로젝트를 진행합니다. 아마 일반 학원이었으면 프로젝트의 완성만을 목표로 삼았을겁니다. 프로젝트의 질이라던가 평가 같은 과정은 생략되거나 간소화했겠죠. 하지만 T 아카데미는 프로젝트 선정과정에서부터 우선 다양한 아이디어를 내고 그 중에 정말 마켓에서 팔릴만한 아이템을 선정합니다. 그리고 그 아이디어가 수강생의 수준에 맞춰서 정말 한달안에 완성할 수 있는지를 판단하고 최종 결정합니다. 아이디어가 결정되면 클래스 다이어그램, DB 설계 등의 과정을 거치게 됩니다. 이런 과정을 모두 수행하는데 꼬박 일주일이 소요됩니다. 한달동안 프로젝트를 진행하는데 일주일이면 아주 긴 시간입니다. 약 1/4 의 시간을 소비하는 것이니까요. 그리고 나머지 3/4 의 시간을 모두 코딩의 시간으로 할애할 수도 없습니다. 마지막 1 주일은 디자인을 입히고 발표준비를 하는 등의 시간으로 할애해야하기 때문에 실제로 코딩 가능한 시간은 약 2 주정도 밖에 안되죠. 그러다보니 큰 규모의 프로젝트를 진행하기는 힘듭니다. 또 서버통신이 필요한 기능은 모두 제외하고 오로지 앱 상에서 모든 기능을 구현해야 했지요. 2 주동안에 실제 코딩을 완료하려고 하다보니 시간이 많이 촉박했습니다. 밤새는건 기본이고 주말도 모두 코딩에 힘을 쏟았습니다.&lt;/p&gt;
&lt;p&gt;어느덧 3 주가 지나고 마지막 1 주가 남았습니다. 그러나 아직도 미완성. 계속해서 코딩에 시간을 할애할 수밖에 없었습니다. 다행인것은 건축학을 전공해서 디자인에 대해서는 전혀 부담이 없었습니다. 다른 친구들은 디자인 때문에 며칠간 골머리를 앓아도 저는 거의 하루 정도만에 디자인을 끝낼 수 있었지요. 그래서 코딩에 시간을 더 할애할 수 있었습니다. 코딩만으로도 시간이 부족했던 저는 코딩에 대해서 다른 친구들에게 물어본 대신 저는 디자인 방법이나 포토샵 다루는 법에 대해서 알려주면서 서로 도움을 주었습니다.&lt;/p&gt;
&lt;p&gt;제가 만든 앱은 ‘좋은습관만들기(Habit Maker)‘라는 이름의 습관 관리 앱이었습니다. 좋은 습관을 들이고 싶은데 항상 신경을 쓰고 살 수는 없는 바쁜 현대인들을 위해서 일정시간 간격을 설정해두면 그 시간이 되서 알림 푸시를 날려주죠. 그러면 사용자는 푸시를 클릭해서 앱에 접속하여 습관을 실행했음을 알리는 체크를 하고 그 결과를 다양한 통계로 보여줍니다.&lt;/p&gt;
&lt;p&gt;한달의 시간이 끝나고 완벽한 수준의 결과물은 아니었지만 드디어 원하는 기능이 동작하는 앱을 완성하게 되었습니다. 감격의 기쁨!! 뭔가 해냈다는 느낌이 들었지요. 덜달아 개발에 대한 자신감도 상승했습니다. 마지막으로 결과물에 대한 발표와 평가의 시간이 남았습니다. 발표는 앱을 만들게 된 배경부터 앱에 대한 시연까지 대략 15 분정도의 시간동안 진행합니다. 그리고 평가는 우리 강사님만 하시는게 아니라, 외부에서 몇분의 심사위원을 초청해서 평가하죠. 그렇다보니 허술하게 대충 준비할 수는 없었습니다. 강사님도 자신이 가르친 수강생들의 결과를 발표시키는 입장이되다 보니 그 어느때보다 많은 신경을 써주셨습니다. 초시계를 들고 발표시간을 조정해주기도 하시고, 발표 과정에 대해서도 조언해 주셨습니다. 저는 나름 아이디어에 자신감이 있었고 발표하는걸 꺼리는 성격은 아니다보니 즐겁게 발표준비를 할 수 있었습니다. 발표전날은 집에도 못가고 밤새 준비했었죠. 다들 그랬습니다. 누구하나 자기 앱에 대해 애정이 없는 친구가 단 한명도 없었기 때문이죠. 그래서 다들 피곤했지만 표정은 밝았습니다.&lt;/p&gt;
&lt;p&gt;긴장되는 마음으로 발표를 시작했고, 시간이 지나가는 것도 모를정도로 빠르게 발표를 무사히 끝냈습니다. 코딩 과정에서 가끔 앱에 버그가 발생했었는데, 시연할 때 나오면 어쩌지 하고 조마조마했었는데, 다행히 잘 작동했습니다. 다음날, 결과가 발표됐는데 결과에 경악할수 밖에 없었습니다. 1 등!!! ‘와~ 내가 일등이라니!!!‘. 말도 안되는 일이 벌어졌습니다. 같이 수강한 20 명 중에서 제가 1 등을 차지한 것입니다. 뿌듯함이나 대견한 마음보다는 같이 고생한 친구들에게 미안한 마음이 먼저 들더라구요. 내가 가장 많은 도움을 받았고, 내 개발 실력이 가장 형편없는데도 제가 1 등을 한것이 미안했습니다. 개발 실력보다는 아이디어가 좋아서 수상을 하게 된거라 생각했습니다. 우리반 친구들 모두 축하를 해주었고, 여러 전문가 과정을 마치는 행사에서 SK 플래닛 대표님 앞에서 시연을 끝으로 2 달간의 과정을 모두 마치게 되었습니다.&lt;/p&gt;
&lt;p&gt;이 두 달은 제 인생의 가장 큰 터닝포인트였습니다. 거의 6~7 년간 건축 하나만을 바라보면서 살아왔던 제가 고작 두 달만에 완전 다른 길로 접어들게 된 것입니다. 학원이나 다른 기관에서 두달을 보냈다면, 이런 성과는 없었을거라 확신합니다. T 아카데미에서의 모든 상황이 저에게 긍정적으로 작용했습니다. 옆에 앉은 형님, 같이 수강했던 친구들, 강사님, T 아카데미 직원분들, 이 모든 요소들이 제 주변에 한꺼번에 일어났기 때문에 이런 성과를 낼 수 있었습니다. T 아카데미를 수료한 뒤로는 이제 저는 개발자가 되어도 좋다는 생각을 했습니다. 이전에는 개발을 오로지 사업을 실현시키기 위한 수단 정도로 시작했었는데, 이 두 달을 통해서 개발자로서의 길을 걸어보기로 결정한 것이죠. 그렇다고 사업을 하겠다는 생각을 완전히 접은것은 아니지만, 단지 개발자로서도 한번 살아봐도 좋을것 같다는 생각이 처음 들었던 것입니다.&lt;/p&gt;
&lt;p&gt;그리고, 한달뒤 어느 회사에 취업하게 되었습니다. 이 이야기는 다음에 이어서~^^&lt;/p&gt;</content:encoded></item><item><title><![CDATA[건축에서 프로그래머로(6) - 프로그래머의 시작]]></title><description><![CDATA[T 아카데미를 알게된건 사실 KT 에서 운영하는  에코노베이션 을 통해서였습니다. 당시에는 창업에 대한 열망이 강하던 시기여서, 창업과 관련된 정보를 얻기 위한 여러곳의 다양한 강좌를 찾아다니고 있었죠. 마침 에코노베이션에서 창업 관련…]]></description><link>https://blueshw.github.io/2015/02/17/from-architect-to-progammer-6/</link><guid isPermaLink="false">https://blueshw.github.io/2015/02/17/from-architect-to-progammer-6/</guid><pubDate>Tue, 17 Feb 2015 12:09:41 GMT</pubDate><content:encoded>&lt;p&gt;T 아카데미를 알게된건 사실 KT 에서 운영하는 &lt;strong&gt;&lt;a href=&quot;http://www.econovation.co.kr/&quot; title=&quot;KT에코노베이션&quot;&gt;에코노베이션&lt;/a&gt;&lt;/strong&gt;을 통해서였습니다. 당시에는 창업에 대한 열망이 강하던 시기여서, 창업과 관련된 정보를 얻기 위한 여러곳의 다양한 강좌를 찾아다니고 있었죠. 마침 에코노베이션에서 창업 관련 2 일짜리 단기 강좌가 있더라구요. 수익창출을 위한 비즈니스 모델을 세우는 연습을 하는 강좌였습니다. 생각보다 강의의 질이 괜찮았고, 강사진 또한 나쁘지 않았습니다.&lt;/p&gt;
&lt;p&gt;이후   에코노베이션 홈페이지를 살펴보던중 에코노베이션 강의 목록에 창업관련 교육만 있는게 아니라는걸 알게되었습니다. 디자인, 기획, 개발 등 다양한 분야에서 교육을 진행하고 있었죠. 게다가 전에 컴퓨터 학원에서 수강하지 못했던 안드로이드 과정도 있는게 아니겠습니까?? 그것도 공짜!! 완전 대박, 이건 꼭 수강해야겠다고 생각했습니다.&lt;/p&gt;
&lt;p&gt;학원에서 안드로이드(대략 3 개월 과정) 과정을 수강하려면 거의 200 만원 정도의 수강료(계좌제로 지원받으면 20 프로인 40 만원만 내면 되겠죠!!)가 필요했는데, 공짜라니… 그리고 KT 같이 큰(?) 기업에서 운영하는 교육과정이 학원처럼 허술하진 않을거란 생각도 들었죠.&lt;/p&gt;
&lt;p&gt;그런데 말입니다. 당장 안드로이드 과정을 수행하려고 했더니 선수과목이 필요하더군요. 당시의 과목명이 정확히 기억나지는 않지만 “안드로이드 개발을 위한 자바 고급과정” 같은 느낌의 이름이었습니다. 고급과정이라.. 완전 초보에 가까운 제가 과연 고급과정을 잘 소화할 수 있을까 걱정이었죠. 괜히 이름에 겁먹은것도 없지 않아 있었지만, 그래도 안드로이드 수강을 하기 위해서라면 반드시 들어야만 했기에 수강하기로 결정했습니다.&lt;/p&gt;
&lt;p&gt;따로 선발 기준이 있는건 아니여서(T 아카데미의 전문과 가정은 인터넷 필기 + 면접) 신청 후 바로 수업에 들어갔었습니다. 또다시 멘붕. 맨 처음으로 강사가 간단한 실습을 시켰는데, VO 가 뭐고 DAO 가 뭐고 어쩌고 저쩌고.. 겨우 자바의 기초만 익혀왔던 제게는 강사가 말하는 말이 외계어와 다를바 없었습니다. 당연히 아무것도 하지 못하고 손놓고 있어야만 햇죠. 멘붕에 빠져 정신을 못차리는 한시간 동안 여기서 나가야겠다는 생각밖에는 들지 않았습니다. 여기서 엉덩이를 붙이고 의자에 앉아 있어본들 정신적으로 더 피폐해질것만 같았기 때문이죠. 결국 쉬는시간을 틈타 짐을 챙기고 찜찜한 마음과 함께 황급히 자리를 뜨게 되었습니다. 강의 내용을 알아듣지 못하는 자신에 대한 무력감과 자괴감이 마음을 불편하게 했지만 도저히 그 자리에 앉아 있을 수가 없었습니다.&lt;/p&gt;
&lt;p&gt;그렇게 첫번째 도전이 실패로 끝난 뒤 한동안 실의에 빠져있었습니다. 프로그래밍은 아예 거들떠보지도 않고 창업 아이템에만 몰두했었지요. 그러던 어느날 인터넷 검색중에 우연히 SK 플래닛에서 운영하는 T 아카데미란게 있다는 것을 알게되었습니다. &lt;a href=&quot;https://oic.skplanet.com/front/tacademy/courseinfo/courseInfoGuide.action&quot; title=&quot;T아카데미&quot;&gt;&lt;strong&gt;T 아카데미&lt;/strong&gt;&lt;/a&gt;란 말하자면 KT 에코노베이션과 비슷한 기관입니다. 일반인을 대상으로 디자인, 개발, 기획등을 교육하고 가능하다면 일자리도 연결해주는 일종의 교육기관이지요. T 아카데미에서 제공하는 강의들을 본 순간 한동안 잠자고 있던 개발에 대한 열망(?)이 또다시 꿈틀거렸습니다. 좌절을 한번 겪어봐서 그런지 몰라도 왠지모르게 다시 도전해볼 용기가 나지 않더라구요. 그때는 개발을 업으로 삼겠다란 생각 자체를 하지 않았던 시기라 그런지 굳이 이걸 꼭 해야겠다는 생각은 들지 않았습니다.&lt;/p&gt;
&lt;p&gt;시간이 어느정도 흘렀을까요? 창업에 열광하던 두 청년은 더 이상은 시간낭비라는 걸 깨달았는지 누가 먼저랄것도 없이 여기서 그만 두는게 좋을것 같다는 결론을 내리게 되었습니다. 8 개월의 시간은 그리 길지는 않았지만 많은 생각과 시도를 했고, 또 창업하기에는 서로의 역량이 많이 부족하다는걸 절실히 깨달은 시간이었습니다. 막상 결정을 내리고 나서 이제는 뭘 해야할까 고민하던 찰나, 잠깐 묵혀두었던 T 아카데미가 생각이 났습니다. 아직 모집 기간이 끝나지 않았는지 급하게 확인을 해보았는데 다행히도 마감되지는 않았더라구요.&lt;/p&gt;
&lt;p&gt;T 아카데미에서 전문가 과정을 등록하려면 총 두가지 관문을 넘어야 합니다. 첫째는 온라인 시험입니다. 다양한 수강과목들은 각각 수준이 다르기 때문에 적절한 기본지식을 갖춘 사람이 수강의 기회를 얻어야 합니다. 만약 아무런 기본 지식도 없는 상태에서 꽤 어려운 과목을 수강하게 된다면, 수강생에게도 시간낭비일뿐 아니라 강의를 개설한 T 아카데미도 적절한 사람에게 적절한 강의를 제공하지 못함으로써 시간과 비용을 낭비하는 꼴이 됩니다. 그래서 최소한의 기본 소양을 확인하는 차원에서 온라인 시험제도를 마련해 둔것 같습니다.&lt;/p&gt;
&lt;p&gt;두번째는 온라인 시험에 통과한 사람들을 대상으로 최종 합격자를 선발하기 위한 면접입니다. 심층면접은 아니고 과정에 얼마나 열정적으로 임해서 최종 결과물을 낼 수 있느냐의 의지를 보는 정도의 면접이에요. 나중에 들은 얘기지만, 면접의 성패는 전공지식이나 코딩 실력보다는 하고자하는 의지가 더 크게 작용한다고 하더라구요~(참고하시길..)&lt;/p&gt;
&lt;p&gt;두근두근하는 마음으로 온라인 시험의 버튼을 힘껏 눌렀습니다. 기회는 총 세번, 그 중에 일정 이상의 점수를 넘으면 통과하는 형식입니다. ‘시험’이라고 해도 기회를 세번이나 주기 때문에 어렵지 않게 통과할 수 있습니다. 혹 풀다가 모르는 문제가 나오더라도, 인터넷에 검색해보거나 직접 코드를 작성해보면 손쉽게 풀 수 있습니다. 제가 등록한 ‘안드로이드 전문가 과정’은 안드로이드의 개발 언어인 자바(JAVA) 기초문제가 20 개 정도 나왔던걸로 기억하는데요. 아무리 쉽고 검색으로 충분히 찾을 수 있다고 해도 저는 기초가 거의 없는 상태였기 때문에 첫번째와 두번째는 간발의 차로 떨어졌었지요. 그러다가 우여곡절 끝에 세번째 만에 겨우 성공했었습니다. 만약 세번째 시험까지 떨어졌으면 지금쯤 인생이 달라졌을 수도 있겠네요.^^&lt;/p&gt;
&lt;p&gt;가까스로 온라인 시험에 통과하고 난뒤 며칠이 지나자 T 아카데미 측에서 면접보러 오라는 연락이 왔습니다. 혹시 프로그래밍 지식에 대해서 물어보면 어쩌지 하는 생각에 불안불안해서 면접을 보기전날까지 제대로 이해하지도 못하고 있던 JAVA 책만 주구장창 보고 있었지요. 아무리 봐도 머리에 들어오지 않더라구요. 그래서 혹 면접시 잘모르는 프로그래밍이나 컴퓨터 관련 지식을 물어보게되면 떨어질 것을 각오하고 솔직하게 잘 모른다고 말하자고 생각하니 마음이 한결 편해지더라구요.&lt;/p&gt;
&lt;p&gt;드디어 기다리고 기다리던 면접날이 다가왔습니다. T 아카데미는 서울대학교 내에 SK 텔레콤 연구동에 위치하고 있습니다. 2 호선 낙성대 역에서 내려 마을버스를 타고 5 분쯤 가면 도착할 수 있습니다. 무거운 마음으로 면접보러왔다고 데스크에 말하니 잠시 기다리라고 하더라구요. 저 말고도 몇명 기다리는 분들이 있었습니다. 잠깐 기다리니 세명을 호명하고는 면접장소로 들어오라고 하더라구요. 세명이 동시에 면접을 봤는데, 그때가 겨울방학 기간이라 그런지 저랑 같이 면접 봤던 두 친구는 모두 컴퓨터 전공 대학생인듯해 보였습니다. 면접이 시작되고 면접관 두 명(아마 강사인듯 보였습니다.)이 먼저 저말고 나머지 두 친구에게 약간의 전공관련 지식을 물어보셨습니다. “아~ 망했다..떨어지겠구나”라고 마음속으로 생각하고 있었는데 이상하게도 저한테는 전공관련 지식은 전혀 물어보지 않으시더라구요. 자신있게 몇 가지 질문에 대답하고는 면접실에서 나왔습니다. 사실 붙거나 떨어져도 인생에 크게 영향을 주지 않을(거라 생각했었죠^^;;) 면접인데도 불구하고 이상하게 긴장이 됐었고 면접이 끝나니 속이 다 후련해 지더라구요. 그리고 며칠 후 당당히 합격~!&lt;/p&gt;
&lt;p&gt;드디어 안드로이드 전문가 과정을 수강할 수 있게 되었습니다. 뭔가 이룬것 같은 기분이 들었지만, 사실 이제 부터가 진짜 시작인 것이죠. 그러나 아직도 이 과정을 통해서 프로그래머가 되어야겠다는 생각보다는 앱 만드는 방법을 배워서 창업이나 해볼까 하는 생각이 더 컸던 것 같습니다. 이런 제 단순한 생각은 수업을 듣고 앱을 만들어가면서 점점 바뀌게 되는데요. 다음에는 T 아카데미에서 배우고 익히고 앱을 만들었던 과정에 대해서 얘기해 볼까 합니다. 그럼 다음에 뵐게요~&lt;/p&gt;</content:encoded></item><item><title><![CDATA[건축에서 프로그래머로(5) – 학원 VS 독학]]></title><description><![CDATA[…]]></description><link>https://blueshw.github.io/2015/02/10/from-architect-to-progammer-5/</link><guid isPermaLink="false">https://blueshw.github.io/2015/02/10/from-architect-to-progammer-5/</guid><pubDate>Tue, 10 Feb 2015 01:45:34 GMT</pubDate><content:encoded>&lt;p&gt;자바 강의를 등록하고 들어간 첫 수업날, 자바뿐 아니라 그 어떤 프로그램 언어를 다뤄본 경험도 없었기에 강사님의 말씀을 거의 알아들을 수 없었습니다. 보통 첫날에는 우리가 지금 배우는게 어떤것이며 어떻게 사용되는지 따위의 개괄적인 내용을 강의하죠. 그리고는 어떤 언어를 배우든 반드시 처음에 어떤 작은 프로그램을 짜보게 되는데요. 바로 “Hello Wordl!!”를 출력하는 프로그램!!!(또는 Hello Java) 당시에는 아무것도 모르고’뭐가 이렇게 간단한거지? 프로그래밍이란게 별거 없구만!!’이라고 생각했었습니다. 하지만, 하지만 말입니다. ‘Hello World’이후에 강사님을 따라 이것저것 여러가지 프로그램을 한글자 한글자 타이핑 해보고 실행도 해보았습니다. 그런데 가면갈수록 머리속이 흐리멍텅해지더니 급기야 까만건 글자요 들리는건 주문이 되는 경지에 이르렀습니다. 도대체 이건 무슨 의미인거지? 어떤 원리로 실행되는거지? 그나마 그중에 한가지 알 수 있는 게 있었으니,&lt;/p&gt;
&lt;p&gt;XXXX.print(“Hello Java”);&lt;/p&gt;
&lt;p&gt;앞에 X 들은 뭔말인지 전혀 모르겠지만(강사님도 지금은 알 필요는 없다고 했습니다!!), print 라는 문구를 보니 대강 “Hello Java”라는 문구를 츨략하라는 뜻인것   같았습니다.  실행해보니   예상한대로   콘솔(이라 불리는 어떤 영역)에 “Hello Java”가 출력되더라구요. 또다시 자신감 급상승!! ‘프로그래밍 별거 없구나’ 라는 생각이 또다시 스믈스믈 기어나왔지요. 하지만 ‘print’를 제외하고는 다른 문자들은 정말 어느 오지의 외국어 같은 느낌뿐이었습니다. 강사님 왈, 아무것도 모르는 초보에게 처음부터 너무 많은 것을 가르쳐 주면 오히려 헷갈리니 그냥 자신이 불러주는데로 타이핑하는게 낫다는 것이었습니다. 정말인가?? 반신반의했지만, 오랫동안 강의를 해왔으니 나름의 생각이 있을거라 생각했습니다. 지금와서 생각해보면, 아마도 복잡한 문법이나 원리를 설명하기전에 우선 어떤식으로 프로그램이 작동하는지 이해하는게 먼저라고 생각했던것 같습니다. 예를들어 처음부터 ‘이것은 어떤 자료형의 변수고, 이건 클래스 이름이고, 이건 파라미터입니다’ 따위의 말들을 했었다면 단 한마디도 알아들을 수 없었을 것입니다.&lt;/p&gt;
&lt;p&gt;두번째 날, 그리고 세번째 날이 지나면서 자료형, 변수, 배열, 메소드, 클래스 등 을 하나씩 배워갔습니다. 배열과 메소드까지는 어느정도 이해가 가능했지만, 클래스를 처음 접했을 때는 도대체 이게 뭔가 싶었지요. 클래스가 뭐고 변수가 뭔지 알고 있는 지금 그 때의 기분을 정확히 표현할 수는 없지만, 아마 중학교 1 학년이 처음 수동태, 능동태를 배울때의 느낌이랄까? 클래스에 대한 이해가 전무한 상태 이후는 아무 의미 없는 시간들의 연속이었습니다. 말그대로 ‘쇠 귀에 경 읽기’ 였죠. 몸은 학원에 나가고 있었지만, 제가 할수 있는 건 들리는 단어를 그대로 타이핑하는것뿐이었습니다. 그래도 실행은 되니깐 근근히 버틸수 있었던것 같습니다. 당시에 10 대 초등학생 꼬마와 같이 강의를 들었는데,  그 친구보다 내가 못따라간다는 느낌마저 들 정도였으니 좌절의 연속이었죠.&lt;/p&gt;
&lt;p&gt;사실 18 일이라는 짧은 시간(한 달 강의지만 실제 강의 일수는 18 일 입니다) 동안 자바라는 언어 하나를 프로그래밍의 ‘프’자도 모르는 사람들에게 가르치려고 하다보니 이해를 하고 못하고는 중요한 문제가 아니었지요. 강사 입장에서는 커리큘럼에 따라서 반드시 수강생들에게 모든 강의를 해주어야 했습니다. 한달의 강의로 ‘학생들이 자바를 알고 자바 프로그램을 작성할 수 있게 되었다’는 사실은 학원에게는 중요한 관심사가 아니었습니다. 단지 몇명의 학생이 등록했고, 다음 달에는 또 몇명이 등록할지가 주요 관심사였죠. 한명을 유치함에 따라서 학원이 얻는 이익은 결코 작지 않았기 때문이겠죠. 그래도 강사님은 나름대로 열심히 가르쳐 주었습니다. 질문을 하면 최대한 이해가 가능하도록 설명해 주었고, 이해를 할 때까지 몇번이고 반복해서 설명도 해주셨습니다. 그렇지만 시간은 세시간으로 정해져있었고 그 이상을 초과할 수는 없었습니다.&lt;/p&gt;
&lt;p&gt;그렇게 한달이 지나고 수업이 끝났을 무렵, 나는 아무것도 배우지 못했단걸 깨달았습니다. 내가 제대로 이해할 수 있는 거라곤 “Hello Java”와 초반에 배운 자료형이나 연산자 정도밖에 없단걸 알았지요. 처음 자바를 배우기 시작한건 친구와 구상한 사업 아이템으로 안드로이드 앱을 직접 만들어 보겠다는 막연한 생각에서부터였습니다. 처음에는 세네 달 정도 학원에 다니면 충분히 만들수 있을거라 생각했었는데, 딱 한달만에 완전히 잘못생각했었단걸 깨달았습니다. 제가 세운 막연한 계획은 정말 말도 안되는 망상이었단걸 알게된 것이죠.&lt;/p&gt;
&lt;p&gt;두 달만에 결국 학원이 무의미하단걸 깨닫고는 혼자서 공부하기 시작했습니다. 유명하다는 자바강의 서적을 구매해서 보기도 하고, 인터넷 강의도 구해도 보기도 했었습니다. 하지만, 아무 기반지식이 없는 상태에서 혼자서 새로운 개념을 이해하고 받아들인다는게 쉬운 일은 아니더라구요. 그래도 학원에 비해서 나은점은 분명 있었습니다. 학원은 정해진 커리큘럼에 따라서 정해진 시간동안 반드시 진도를 나가야 하기에 수강생들이 이해를 하고 말고의 여부는 중요한게 아니죠. 그렇기 때문에 수업에 따라가지 못하게 되면 그 이후에는 아무 의미없는 시간이 되고 맙니다. 하지만, 혼자서 독학하게 되면 사정이 조금 다르죠. 진도를 나가다가도 이해가지 않는 부분이 있다면, 시간을 두고 여러번 반복해서 학습할 수 있다는 장점이 있습니다. 처음에 이해가 안된다고 하더라도 두번, 세번 계속해서 보다보면 언젠가는 깨닫게 되는 순간이 있는 법이죠. 물론 시간이 많이 걸린다는 단점도 분명 존재합니다.&lt;/p&gt;
&lt;p&gt;그럼 어떤 학습법이 더 좋은걸까요? 만약에 저와 같은 과정을 거쳐가려는 친구가 제게 조언을 구한다면, 어떤 충고를 해줘야 할까요? 지금의 저라면, T 아카데미와 같이 전문 강사의 강의에 하나의 완성된 결과물을 낼 수 있는 강의를 찾아서 수강하라고 권하고 싶네요. 과정이 어렵고 이해가지 않는 부분이 있다 하더라도 완성된 하나의 결과물이 존재한다면, 프로그래밍을 통해서 얻는 기쁨이랄까.. 그런 성취감을 느낄수 있기 때문에 학습을 지속해 나갈수 있다고 생각이 들어요. T 아카데미와 같은 전문가과정을 수강하기 어려워 학원을 다녀야만 하는 경우라면, 한달짜리 단과반보다는 최소 세달 이상 결과물을 만들어낼수 있는 과정을 듣는 것이 좋다고 생각합니다. 그리고 처음부터 독학은 좀 무리라고 생각이 듭니다. 아무런 기본 지식이 없는 상태에서의 독학은 오히려 쉽게 포기하게 되버리므로, 어느정도 기반지식이 쌓은 상태에서 독학을 하는게 좋을것 같아요.&lt;/p&gt;
&lt;p&gt;여기서 T 아카데미가 잠시 언급이 됐는데요. 네 그렇습니다. 다음 이야기의 주제가 바로 T 아카데미입니다. 저의 첫 결과물을 만들게 해준 고마운 학교임과 동시에 프로그래밍에 재미를 붙여준 곳이기도 하지요.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[건축에서 프로그래머로(4) – 학원에 등록하다]]></title><description><![CDATA[IT 관련 학원, 아시는분들은 아시겠지만 무지하게 비쌉니다. 한달 단과반, 하루 3 시간 강의를 수강하면 보통 4…]]></description><link>https://blueshw.github.io/2014/11/02/from-architect-to-progammer-4/</link><guid isPermaLink="false">https://blueshw.github.io/2014/11/02/from-architect-to-progammer-4/</guid><pubDate>Sun, 02 Nov 2014 00:35:25 GMT</pubDate><content:encoded>&lt;p&gt;IT 관련 학원, 아시는분들은 아시겠지만 무지하게 비쌉니다. 한달 단과반, 하루 3 시간 강의를 수강하면 보통 40 만원 정도가 들어요. 영어학원이나 다른 여타 학원들에 비해서도 지나치게 비싼편입니다. 프로그래밍을 가르치는 일에는 전문적인 지식을 필요하기 때문이라고 말할수도 있겠지만, 이 점을 감안하더라도 너무 비싸다는건 부정할 수 없습니다. 그런데 컴퓨터 관련 학원들을 자세히 알아보면 뭔가 이상한점을 발견할 수 있습니다. 어느 학원을 알아보더라도 거의 비슷한 과정을 개설하고 있고, 수강료 마저 비슷한 선에서 형성되어 있습니다. 여기엔 분명히 뭔가 있어보이지요.&lt;/p&gt;
&lt;p&gt;90 년대 말에서 2000 년 초반 벤처 붐이 일어날 당시에 정부에서는 IT 강국으로 도약하기 위해 엄청난 지원금을 쏟아 부었습니다. 이 지원금 중에서 일부는 비전공자를 대상으로하는 학원으로 흘러들어갔지요. 이때 새롭게 발생한 이 수요를 감당하기 위해 컴퓨터 학원들이 많이 생겼겠지요. 그리고 그 결과 초급 개발자(주로 PHP 등의 웹 개발자)가 대량으로 양산되었고 개발자의 몸값도 확 내려갔습니다. 아마도 이때 정부의 지원에 의해 만들어진 학원들이 지금까지 쭉 이어져오고 있는게 아닌가 생각합니다(제가 언급한 위의 내용들은 사실확인을 하지 않은 제 개인적인 추측이니 감안해서 보시면 될것 같네요^^).&lt;/p&gt;
&lt;p&gt;이렇게 비싼 컴퓨터학원에 가보면 여전히 많은 수강생들이 다니고 있는걸 볼 수 있습니다. 이렇게 비싼데도 말이지요. 하지만 대부분의 수강생은 제 돈주고 강의 듣지 않습니다. 다양한 형태로 지원금을 받아서 무료로 강의를 듣거나 일부 금액을 내고 듣기도 합니다. 지원금을 받을 수 있는 형태는 여러가지가 있습니다만, 그 중에서 대표적인 것이 중소기업 재직자 과정, 내일배움카드카드제(계좌제, 이하 계좌제) 등 입니다. 중소기업 재직자 과정의 경우는 처음에 전액을 지불한 다음 규정에 명시된 출석률에 도달하면 전액을 돌려받는 형태입니다. 계좌제(아래에서 자세하게 설명)의 경우에는 20 퍼센트만 지불하고 나머지 80 퍼센트를 지원받는 형태이죠. 예를 들어서 40 만원짜리 단과반 강의를 듣는다면 중소기업 재직자는 100% 환급이 가능하니 무료이고, 계좌제(조금 후에 설명드리겠습니다)를 이용하는 사람은 20%인 8 만원만 지불하고 나머지는 정부지원금으로 지불합니다. 현실이 이렇다보니 실제로 수강료를 모두 지불하고 강의를 듣는 학생은 많지 않습니다. 한달 강의에 40 만원은 쉽게 낼 수 있는 돈이 아니죠. 그런데 강의를 직접 들어보면, 이게 과연 한달 강의의 가치가 될까하는   의문이 듭니다. 아마도 이들 학원들은 정부의 지원금을 이용하여 강의료를 엄청 올린다음 마치 이 비싼 강의를 싸게 들을 수 있는 기회를 준다는 식으로 생색을 내는게 아닌가 생각이 듭니다. 말하자면 돈은 돈대로 정부로부터 받아내고 수강생들에게 생색은 내는대로 낸다는 말입니다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.hrd.go.kr/jsp/HRDP/main/index.jsp&quot; title=&quot;계좌제 홈페이지&quot;&gt;계좌제 홈페이지 들어가기&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;여기서 계좌제를 모르시는 분들은 잠깐 설명드리겠습니다. 계좌제의 공식 명칭은 내일배움카드제입니다. 2010 년에 정식으로 규정이 만들어졌습니다. 2010 년 이전에도 지원 제도가 없진 않았는데, 2010 년에 이름을 바꿔서 규정을 정리한것으로 보입니다. 계좌제는 직업을 가지지 못하거나 실직한 사람들에게 정부에서 내일배움카드(계좌제 카드)를 발급하여 일정금액(200 만원)을 지원해주는 제도입니다. 대학졸업자, 실직자, 구직자 등 현재 직업이 없는 성인은 대부분 이용할 수 있습니다. 위에서도 잠깐 언급했지만, 40 만원짜리 단과반을 수강한다면 20%인 8 만원은 본인 부담으로 결제합니다. 그리고 나머지 32 만원은 정부 지원금 200 만원에서 차감됩니다. 즉, 단과반을 한달 수강하고나면 지원금이 168 만원 남게 된다는 것이죠. 이런 방식으로   남은 금액 한도내에서 어떤 강의든 자신이 원하는 강의를 들을 수 있습니다. 단, 최초에 내일배움카드를 발급받을 때 본인이 취직하려는 직종과 일치하는 강의여야하지요.  강의를 잘 들으면 보너스도 있습니다. 수업에 빠지지 않고 대부분을 출석하면,  교통비랑 식비를 11 만원까지 받을 수 있습니다. 완전 대박이죠!! 여기서 또 한가지 주의하실점은 지원금은 발급일로부터 1 년안에 꼭 사용하셔야 한다는 것입니다. 제가 2011 년에 지원받은 거라 위의 내용이 정확하지 않을 수도 있습니다. 그렇기 때문에 꼭 홈페이지에 들어가셔서 정확한 내용은 확인해보시길 바랍니다.&lt;/p&gt;
&lt;p&gt;여러 학원들에서는 이 계좌제에 맞춰서 안드로이드 전문가 과정, 아이폰 전문가 과정, 오라클 전문가 과정 등의 3~6 개월 과정을 많이 모집하고 있습니다. 이 과정들은 완전 기초(C, JAVA 등의 언어)에서부터 각각의 과정을 소화하기 위해서 필요한 기반지식을 모두 배웁니다. 과정을 모두 이수하고나면 학원에서 우수(?) 중소기업에 취업을 연결시켜주기도 합니다(취업하기 쉬워보입니다만…).&lt;/p&gt;
&lt;p&gt;저는 당시(2011 년)에 프로그램을 처음 배우는 입장이어서 무엇을 먼저 해야할까 고민이었습니다. 공과대학을 졸업했음에도 불구하고 건축공학이라는 이유로 C 언어조차 배우지 않은 상태였기에 무엇부터 어떻게 배워야하는지 전혀 감이 없었고 조언을 구할데도 마땅지 않은 상황이었습니다. 또한 친구와 사업을 계속 추진하고 있는 상태여서 남들처럼 풀타임으로 3~6 개월 과정을 진행하기란 불가능했습니다. 2011 년은 스마트폰이 한창 뜨고 있을 때였죠. 학원에서도 시대의 흐름에 맞춰 안드로이드나 아이폰 과정이 인기가 있었습니다. 아! 이거구나 싶었죠. 하지만 학원에 알아본결과, 모바일 과정은 대부분 3 개월 이상의 풀타임(오전 9 시~오후 6 시)으로 진행하고 있었고, 단과로 개설된 과정은 거의 없었습니다. 단과만 가능했던 저는 이런 풀타임 과정을수강을 할 수 없었습니다. 그래서 학원의 상담사와 상담을 한 끝에, 안드로이드 앱을 개발하는 언어인 자바 단과반을 수강하기로 결정했습니다.(이 때의 선택이 아직도 이어지네요^^)&lt;/p&gt;</content:encoded></item><item><title><![CDATA[건축에서 프로그래머로(3) – 내가 직접 만들어 볼까?]]></title><description><![CDATA[…]]></description><link>https://blueshw.github.io/2014/10/25/from-architect-to-progammer-3/</link><guid isPermaLink="false">https://blueshw.github.io/2014/10/25/from-architect-to-progammer-3/</guid><pubDate>Sat, 25 Oct 2014 12:06:17 GMT</pubDate><content:encoded>&lt;p&gt;한창 사업준비에 몰두하고 있을때였습니다. 기획이 어느정도 진행되었고, 이제는 우리가 생각해왔던 것이 실제로 가능한 것인지, 어느정도의 시간과 노력이 필요한 것인지를 알고 싶었습니다. 전에 언급했던것 처럼 당시에는 절대로 개발자를 구할 수 없는 상태였습니다. 사무실도 구하지 못하고 친구 삼촌네 사무실에 기생하고 있었고, 점심값도 아끼려고 이리저리 돌아다니며 여러 사람들에게 얻어 먹던 상황이었으니까요. 이런 상태에서 개발자를 고용한다는 것은 사치나 다름 없었습니다. 더군다나 기획한 프로젝트가 제대로 될지 안될지도 모르는 상황이었는데 무리를 할 필요는 없었지요. 수 년째 개발일을 하고 있던 친구 지인분이 우리에게 해준 조언 덕택에 우리가 기획한 서비스가 단기간에 고용한 개발자 한두명으로는 어림없다는 것을 알게된 것도 무조건적으로 개발자를 고용해야한다는 생각에서 깨어나게 해주었습니다.&lt;/p&gt;
&lt;p&gt;우리 기획이 잘못된 것인가? 베타버전을 만들어 보기 위해서라도 조금더 간단하고 단순화된 형태로 바꿔야하나? 이런 생각들로 몇날 며칠을 보내고 있었습니다. 당시에 앞으로 사용할 회사이름으로(아직 회사를 설립하지 않았기에 이름만 있음) 티스토리 블로그를 이용하여 만들어 운영중이었습니다. 아시다시피 티스토리는 설치형 블로그의 형태를 띈 가입형 블로그입니다. 즉, 사이트에 종속되어 있어 따로 자신의 웹서버를 구축할 필요가 없고(가입형), 사용자에게 블로그 수정의 자율성이 보장(설치형)됩니다. 대표적인 가입형 블로그에는 네이버나 다음 블로그가 있고, 대표적인 설치형 블로그에는 지금 제가 사용하는 워드프레스가 있습니다. 양쪽 다 워낙 유명해 따로 설명할 필요는 없을 것 같네요.  티스토리가 수정이 된다고는 하지만   워드프레스 만큼이나 방대하고 자유롭게 수정이 가능하지는 않습니다. 티스토리에서만 제공하는 플러그인을 사용해야하고 일부 소스를 수정하는 정도에 불과하지요. 워드프레스를 사용해보신분은 아시겠지만 테마와 플러그인을 사용자가 직접만들고 배포할수 있다보니 어마어마하게 방대한 종류의 테마와 플러그인이 있습니다. 그래서 웬만한 플러그인만 잘 사용하면 코드 한줄 고칠 필요 없이 쉽게 블로그를 꾸밀 수 있지요.&lt;/p&gt;
&lt;p&gt;친구와 저 중에서 그나마 제가 컴퓨터와 친하고 컴퓨터 작업을 좋아했던 터라 회사 블로그의 제작과 운영을 제가 맡게 되었습니다. 처음에는 어떻게 블로그를 만들까 고민하다가 팀블로그로 사용이 가능한 티스토리를 선택하게 되었습니다.네이버 블로그를 사용했더라면 아무런 고민도 없이 네이버에서 제공하는 템플릿으로 뚝딱 만들어버렸겠지만, 가입도 번거럽고(초대 메일을 받아서 가입해야함) 노출도 네이버에 뒤지는 티스토리 블로그를 선택한 것은 오로지 팀블로그 기능 때문이었지요. 사실 친구와 저와 아이디를 공유하면서 하나의 아이디로 글을 써도 무방한 것인데 그때는 그게 뭐가 그리 중요하게 느껴졌는지 꼭 티스토리로 만드러 보고 싶더라구요. 아무튼 티스토리를 선택했으니 어느정도 소스 수정은 필요할 상황이었습니다. 티스토리에서 제공하는 템플릿을 그냥 써도 괜찮지만 무슨 오기에 그래도 우리 색이 담긴 블로그니깐 뭔가 우리가 원하는 모습이 필요하겠다 생각이 들었습니다.&lt;/p&gt;
&lt;p&gt;이 때 저는 HTML 태그 사용도 거의 하지 못하는 바닥 수준이었습니다. 사용해본 태그라고하면 고등학교시절 친구들 사이에서 사용하던 글자에 색 넣기, 글자 움직이기, bold 처리, 이미지 불러오기 정도가 전부였지요. 그래서 학원에 몇달 다니며 HTML 을 익힌 와이프에게 물어가며 블로그에 로고를 입히고 디자인을 변경하는 등 조금씩 우리가 생각하는 모습대로 만들어 갔습니다. 블로그 수정이라고 별게 있겠냐 싶지만, IT 지식이 거의 없는 상태에서 원하는 모습대로 만드는게 생각보다 쉬운일이 아니었습니다. 원하는 모양과 기능을 어떠한 코드(태그)로 만들어야 되는지를 알면 검색이라도 하겠는데 아무것도 모르니 검색 또한 쉽지 않았습니다. 어떤 날은 풀리지 않는 문제로 씨름하다 밤을 새기도 했지요. 몇날 며칠을 별로 수정한 것도 없는데 그렇게 어렵게 또 어설프게 드디어 우리가 앞으로 만들어갈 회사의 블로그를 만들었다는 뿌듯함 때문에 괜시리 기분이 좋아지더라구요. 만드는 과정 자체도 재미있기다고 느끼기도 했습니다. 특히 풀리지 않은 문제를 만났을때 느껴지는 극도의 스트레스도 막상 문제가 해결되었을 때의 희열은 이루 말할 수 없는 정도였습니다.&lt;/p&gt;
&lt;p&gt;블로그를 만들었던 이 경험은 내 안의 뭔가를 바꿔 놓았습니다. IT 분야를 이끌어가는 이 기술인 프로그래밍에 대한 호기심이 발동하기 시작한 것이죠. 그렇다고 당장에 사업을 때려치우고 개발자가 되겠다는 생각은 전혀 없었습니다. 단지 친구와 제가 어렵게 만들어 놓은 기획을 배우고 익히다 보면 나 스스로도 만들 수 있지 않을까, 그런 생각 정도였습니다. 지금 생각해보면 잠깐 프로그래밍을 배운다고해서 뚝딱뚝딱 만들 수 있을만큼 간단한 것도 아니었는데, 당시에는 뭔가 희미한 안개속에서 뭔가 형체가 보이듯이 금방 만들 수 있을것만 같았습니다. 그래서 일단 프로그램을 공부하기 위해서 무엇을 먼저 해야할까 찾아보았습니다. 와이프가 조언하길 아무것도 모르는 상태에서 혼자 공부하려면 더 힘드니 학원에 한번 다녀보면 어떠냐고 그러더라구요.&lt;/p&gt;
&lt;p&gt;그래서 학원으로 달려갔습니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[건축에서 프로그래머로(2) - 사업 한번 해볼까?]]></title><description><![CDATA[박차고 나온 직장, 의미 있는 뭔가를 하고 싶었습니다. 허나 거의…]]></description><link>https://blueshw.github.io/2014/10/15/from-architect-to-progammer-2/</link><guid isPermaLink="false">https://blueshw.github.io/2014/10/15/from-architect-to-progammer-2/</guid><pubDate>Wed, 15 Oct 2014 11:41:25 GMT</pubDate><content:encoded>&lt;p&gt;박차고 나온 직장, 의미 있는 뭔가를 하고 싶었습니다. 허나 거의 7 년간 내게 의미 있었던 것을 단숨에 그만둔다는 것은 쉬운일이 아니었습니다. 때마침 대학때 뜻이 맞던 친구가 저와 비슷한 시기에 비슷한 고민을 하고 있었지요. 그래서 저희는 자연스럽게 앞으로의 일에대해서 많은 고민과 대화를   하게 되었고, 마침내 둘이서 뭔가를 해보자는 결론을 내렸습니다. 즉, 사업한번 해보자는 것이었죠. 우리의 결심은 일사천리로 진행되었습니다. 그리고 저를 회사에 뽑아주셨던 회사 대표님께 뭔가 더 가치있는 일을 하기 위해 회사를 그만둬야겠다고 말씀드렸습니다. 의외로 대표님은 흔쾌히 보내주셨습니다. 같은 동문이라 애착이 있으셨을법도한데 제 결심과 표정을 보고 제 마음을 바꾸지 못할꺼라는 것을 아셨을지도 모르겠습니다.&lt;/p&gt;
&lt;p&gt;막상 회사를 그만두었지만 앞으로 어떻게 해야할지 막막했습니다. 회사를 그만두긴 했지만 그만두기 전에 충분한 준비를 하지 못했었고, 회사를 나와서 준비하면 될거라는 안일한 생각에 빠져있었습니다. 게다가 저는 결혼하지 몇 달 되지도 않은 상황이었습니다. 제 마음대로 회사를 관두기 힘든 상황이었었죠. 하지만, 와이프는 참 고맙게도 저의 뜻을 높게   사주었고   당분간은 힘들겠지만 앞으로는 잘될거라며 굳게 믿어주었습니다. 당시에는 자본금을 마련하기도 힘들어 처음에는 까페를 전전하며 커피 두잔으로 사무실 비용을 대신했었지요. 그렇게 매일같이 마시는 두 잔의 쓰린 커피로는 도저히 안되겠다 싶어서 결국 친구집 빈방에 사무실을 만들었습니다. 처음에는 그럭저럭 쾌적한듯 느껴졌습니다만, 시간이 지날수록 친구의 ‘집’ 이라는 사실이 발목을 잡더군요. 게을러지고 의미없이 보내는 시간들이 많아졌습니다. 그래서 또다시 이사를 감행했습니다. 친구 삼촌이 쓰시는 사무실 한켠에 파티션을 설치하고 책상 두개를 만들어 사무실로 사용했었습니다.&lt;/p&gt;
&lt;p&gt;처음 친구와 저는 먼저 무슨일을 해야할까를 고민하기 시작했습니다. 회사를 관둘때 생각했던 우리에게 가치 있는일, 또한 사회에 긍정적인 영향을 끼칠 수 있는 일이 과연 무엇인지 부터 찾아보았지요. 당시에 ‘사회적 기업’이라는 사회의 이익을 위한 일을 하는 기업이라는 형태가 유행하던 시기였습니다. 기존의 기업들은 이익의 극대화를 위해서 존재한다면, 사회적기업은 소수자들의 자립을 도와준다거나 우리사회나 나아가서는 전 지구적으로 도움이 되는 일을 하자는 취지에 그 존재목적이 있습니다. 저희는 이거다 싶었습니다. 그때부터 사회적 기업 관련 책을 읽거나 세미나, 행사 등을 찾아 다니며 사회적 기업이 무엇인지 공부하기 시작했습니다.&lt;/p&gt;
&lt;p&gt;사회적기업에 대해 알면 알수록 이건 좀 이상하다 싶었습니다. 당시에 우후죽순처럼 나타나던 사회적기업들은 대부분 투자를 받거나 국가에서 지원을 받아서 사업을 해나가던 경우가 많았는데, 국가의 지원같은 경우는 보통 3 년정도의 임금을 지원해주었습니다. 지원 받는 그 3 년간의 기간동안은 그럭저럭 운영을 해가지만 3 년이 지나고 지원금이 사라졌을때, 자생력을 갖추는 사회적기업을 찾아보기가 쉽지 않았습니다. 결론부터 보면 3 년정도 흐른 지금에 와서 보면 그때에 등장했던 수많은 사회적 기업들 중 지금도 존재하는 기업은 많지 않습니다. 저희는 그 때 사회적 기업이라는 것은 한때 유행에 지나지 않을것이고 조금만 있으면 거의 사라질 것이라는 것이라는 생각이 들었습니다. 간단하게 생각만 해보아도 보통의 기업도 돈을 버는 것이 쉬운일이 아닌데 하물며 기반도 부족한 젊은이들이 사회에 공헌하면서 돈도 벌겠다라는 것이 얼마나 어려운 일인지 알 수 있습니다.&lt;/p&gt;
&lt;p&gt;이대로는 무리라고 판단이 되어,  생각을 조금 바꿔보았지요. 우리가 꼭 사회적 기업이라는 틀에 갖힐 필요가 없다. 그저 우리의 생각에 적합하면서 우리가 원하는 개인적 가치, 사회적 가치를 실현할 수 있으면 되는 것이다. 이렇게 말입니다.&lt;/p&gt;
&lt;p&gt;틀에 얽매이는 생각을 조금만 비틀었을 뿐인데 그때부터 여러가지 아이디어가 나오기 시작했습니다. 몇달의 시간이 흘러 아이디어를 추리고 발전시키고 정제하는 과정을 계속해서 반복해갔습니다. 그러던 중   하나의 완성된 아이디어가 나오기 직전, 이제 투자 받을수 있겠구나 생각하던 시점에서 뭔가 잘못됐다는것을 깨달았습니다. 우리가 생각한 아이디어는 IT 를 기반으로 하는 벤처들의 창업과 유사한 형태였습니다. 그런데 친구나 저나 IT 와는 전혀 상관없는 인생을 살아왔기 때문에 당장에 우리가 기획한 것을 베타버전이라도 만들어보려면 개발자가 필요했습니다. 우리는 기획을 하면서 꿈을 꾸고 있었는지 현실적으로 만들어 낼수 있는지에 대한 필터링도 전혀 없었기 때문에 더더욱 개발자의 안목이 필요했었지요. 우연히 친구 아는 분이 개발분야에서 일하고 있어 우리가 기획한 것을 간단하게 보여드렸습니다. 우리가 이 분을 모셔올 수는 없더라도 이렇게 기획한 것이 과연 얼마의 시간동안 얼마의 인력으로 가능할지에 대한 기준이라도 알고 싶었습니다. 대답은 우리의 상상했던 것 이상이었습니다. 1 년 이상의 개발기간에 최소 2~3 억은   필요하다   답해 주셨습니다. 하늘이 무너지는 줄 알았습니다. 아무리 우리가 개발적 지식이 전무하다고 했지만 이정도로 우리의 상상과 현실의 갭이 클줄은 몰랐지요.&lt;/p&gt;
&lt;p&gt;아무런 해결책도 기대도 없던 그 때 거대한 인터넷 기업에서 우리가 생각했던 서비스와 매우 유사한 것을 내놓겠다는 발표를 보게 되었습니다. 기획한 서비스와 완전히 똑같지는 않았지만, 뭔가 잘못됐다는 것을 직감할 수 있었습니다. 혹 우리가 지금까지 꿈을 꾸었던 것이었을까?  불안한 마음도 들었습니다. 예상보다 경제적, 시간적으로 무리라는 조언에 낙담한 상황에서 업친데 덥친격으로 유사 서비스의 발표까지 나오다 보니 이걸 정말 할 수 있을까라는 의구심마저 들기 시작했습니다. 당시에 친구와 저는 서로 말하지는 않았지만 더이상 우리가 하려고 했던 이 사업 놀이(?)는 여기서 끝내야한다는 것을 어렴풋이 느끼고 있었는지도 모릅니다. 결국 누가 먼저랄것도 없이 여기서 그만 두는게 맞는것 같다고 서로 얘기하게 되었지요. 8 개월간 꾸었던 꿈을, 이제는 깨어날 때가 되었던 것입니다. 그리고 이후 우리는 헤어져 또다시 각자 서로 다른 가치를 찾기 위해 각자의 길을 찾아 나서게 되었습니다. 시간이 지난 지금 돌이켜보면, 사실 이 유사한 서비스의 등장이 결정적인 원인이었다 생각하지 않습니다. 그 8 개월 동안 단 한번도 절실하게 원하지 않았기 때문에, 그렇기 때문에 단 한번의 위기로 와르르 쉽게 무너져버린것은 아닐까요?&lt;/p&gt;
&lt;p&gt;좋은 경험이었습니다. 결과는 없었고 과정만 있었지만 많은 고민을 하고 생각을 나누고 아이디어를 쏟아내는 그 과정들은 저에겐 건축과는 또다른 형태의 재산이 될 수 있었습니다. 값진 경험이었습니다. 그리고, 사업은 이렇게 하면 안되는구나(?)라는 것도 알게 되었지요. 특히 IT 벤처를 시작하려면, 확실한 아이디어와 실현할수 있는 기술을 가진 누군가가 꼭 있어야하고 어느정도 현실화가 되기전에는 회사를 그만두지 않는게 좋다는 교훈도 얻게 되었습니다. 이제 저는 또다른 길을 가게 되었습니다. 나이 서른이 다되어서 또다른 일을 결심할 수 있는것이 행복한 것인지 불행한 것인지는 모르겠습니다. 하지만 지금까지의 경험이면 무슨일을 하던지 새롭게 도전할 수 있을것만 같았습니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[건축에서 프로그래머로(1) - 건축에 뜻을 두다]]></title><description><![CDATA[…]]></description><link>https://blueshw.github.io/2014/10/06/from-architect-to-progammer-1/</link><guid isPermaLink="false">https://blueshw.github.io/2014/10/06/from-architect-to-progammer-1/</guid><pubDate>Mon, 06 Oct 2014 12:02:23 GMT</pubDate><content:encoded>&lt;p&gt;어렸을적엔 그림그리는 화가가 되고 싶었습니다. 그림 실력이 그렇게 뛰어나진 않았지만 그림 그리는게 마냥 즐겁고 행복 했었습니다. 누가 시키지 않아도 하루종일 그림 그리는데 몰두하기도 했었지요. 그림뿐만 아니라 만드는데도 흥미가 있었습니다. 약품 박스로 로보트를 만들기도 하고 철사로 이것저것 만들어보기도 했었지요. 하지만, 시간이 지나 중학생이 되고 고등학생이 되면서 예전처럼 그림에 대한 흥미는 사라지고, 대신 여느 아이들처럼 대학을 위한 입시에만 정신이 팔려버리게 되었습니다. 20 살, 드디어 대학생이 되었습니다. 제게 20 살은 해방의 시간이었습니다. 그때는 ‘앞으로 무었을 하겠다’ 보다는 ‘지금은 놀자’ 란 생각으로 머리속이 가득차 있었지요. 매일같이 친구들, 여자친구와 어울리면서 밤이면 밤마다 술자리에 흥청망청 시간을 보냈습니다.&lt;/p&gt;
&lt;p&gt;당시 제가 들어간 대학은 입학해서 2 학년이 되기 전에 과를 선택하는 학부제로 운영되고 있었습니다. 1 학년때는 특정 과가 정해져 있지 않고 교양위주의 수업을 들으면서 자신의 진로를 탐색하는 시간이었지요. 이런 방식이 어떻게 보면 긍정적으로 보일지 모르나 사실은 진로 선택을 1 년 미루는것 밖에 되지 않는다고 생각합니다. 아직 아무것도 정해져 있지 않다는 생각은 자연스럽게 미래의 나를 생각하는것을 미루게 만들었습니다. 어차피 1 년이 지나고 학과를 선택하면 그때부터 시작하면 된다고 그렇게 믿었지요. 그렇게 1 년이 순식간에 지나고 선택의 시간이 다가왔습니다. 20 년을 살면서 자신의 미래를 위해 제대로된 선택을 한것도 그때가 처음이 아닐까 생각이 듭니다. 고등학교를 다닐때까지는 거의 모든것이 정해진대로, 크게 다르지 않은 삶을 살았습니다. 선택을 하더라도 미래에 크게 영향을 주지 않는 선 안에서 이뤄졌습니다. 대학을 선택하는 시간도 있었지만, 학부로 지원을 했기에 당시에도 별다른 고민은 없었지요. 그런데 드디어 내가 미래에 어떤 삶을 살아야 하는지를 결정하는 시간이 다가왔습니다.&lt;/p&gt;
&lt;p&gt;고민이었습니다. 애초에 전자공학과 정도를 염두에 두고 있었습니다. 전자공학은 인기가 있는 학과여서 어느정도의 학점이 필요로 했지만 그정도의 학점은 충분했습니다. 그래서 외부의 조건이나 환경과는 전혀 상관없이 오로지 나 자신만을 위해서 고민을 하기 시작했습니다. 1 년간 별다른 고민없이 지내온 기간이 어쩌면 도움이 됐는지도 모르겠습니다. 문득 어렸을적 시절을 생각해보았습니다. 15 권 가량되는 백과사전의 예술분야와 관련된 13 번째 책, 그 책 속에서 수없이 보아왔던 이미지 하나가 떠올랐습니다. 집을 만드는것! 건축이었습니다.&lt;/p&gt;
&lt;p&gt;뭔가 운명이 찾아온것처럼 건축공학과(당시는 건축학과 건축공학 분리없이 건축공학이었습니다)에 지원했습니다. 2 학년은 1 학년과는 다른 시간이었습니다. 건축이라고는 집짓는것이라는것 외에는 아무것도 모르던 제가 건축이 이런것이구나라는걸 깨달아가는 시간이었습니다. 다양한 분야의 책을 읽고 좋은 친구들을 만나고, 많은 이야기를 나누었습니다. 어설픈 실력에도 밤을 꼬박 새면서 작업한 결과물로 교수님에게 칭찬이라도 한번 받게으면 간밤의 피로는 말끔히 사라지고 더없이 행복했었지요. 하지만 대부분은 깨지고(설계 개념이나 모델 등을 평가 받는 것을 critic 이라고 합니다), 부시고 다시 만드는 일의 반복이었습니다. 이런 반복의 시간동안 나도 세계적인 건축가들과 어깨를 나란히 하고싶다는 생각이 조금씩 자라나고 있었습니다.&lt;/p&gt;
&lt;p&gt;기나긴 방황의 시간을 보내고 드디오 졸업, 취업이 목전에 다가왔습니다. 여기서도 갈등이 찾아왔습니다. 건설회사(이른바 대기업)는 아예 쳐다보지도 않았습니다. 애초에 설계(건축디자인)를 위해 건축을 선택한 것인데 현실적인 조건(연봉, 네임밸류) 때문에 건설회사에 간다는 것은 자존심이 허락치 않았지요. 대신 큰 회사규모의 기업형 설계사무소에 들어갈 것이냐, 아니면 이른바 작가풍의 건축가 밑으로 들어가서 건축에 대해 제대로 배우로 갈것인가를 결정해야 했습니다. 아무래도 기업형 설계사무소에 들어가면 후자에 비해서 연봉은 조금더 높습니다. 하지만 진짜 건축일을하기 보다는 회사가 요구하는 회사가 원하는 일을 해야했지요. 하루종일 PPT 를 만들거나, 말도 안되는 이야기를 갖다 붙이며 ‘이것이 작품입네’하고 과장하고 부풀리는 그런 일들이었지요. 네, 제가 해봐서 아는것입니다. 즉, 제가 선택한 길은 건축가 밑에서 일하며 배우는 것이 아니라 기업형 회사를 선택했다는 말입니다. 이때 후자의 길을 택했다면 아마도 아직 건축계에 발을 붙이고 살았을지도 모를 일입니다.&lt;/p&gt;
&lt;p&gt;회사 초창기에는 외부 공모전에도 여러번 참여 하고 입상하는 등 학생때의 열정을 이어 갔습니다. 하지만, 회사생활은 쉽지 않았고 밤을 새가며 일도 많이했지만 학생때와는 전혀 다르게 얻는것은 별로 없었습니다. 학교다닐때처럼 밤을 새가며 모형을 만들어도, 발표준비에 PPT 를 만들어도 예전의 그것과는 전혀 달랐습니다. 그러다보니 ‘아, 이게 과연 내가 생각했던 건축인가’와 같은 고민들도 자주하게 되었습니다. 이일들은 내가 학생때 배우고 익혔던 이상적이고 훌륭하고 자부심 넘치는 건축이라는 학문이 아니었습니다. 이것은 단지 회사일 그 이상 그 이하도 아니었습니다.&lt;/p&gt;
&lt;p&gt;한편으로는 회사의 이런 모습이 이해가 가기도 했습니다. 건축은 학문이 아니라 경제적인 부분으로 프로젝트가 좌지우지되는 현실적인 ‘사업’이기 때문에 이상적인 모습만을 쫓을 수는 없는 노릇입니다. 하물며 이윤을 추구하는 집단인 회사에서 건축이라는 타이틀을 가지고 있으니 뭔가 멋있고 남들이 이해하지 못하고 비효율적인 프로젝트를 어마어마한 돈으로 실행할수는 없는 노릇입니다. 당연히 누군가의 요구와 누군가의 이해관계에 의해서 그들이 원하는 작업을 빠르고 효율적으로 처리해야하죠. 그래야   회사의 직원 모두가 먹고 살수 있는 것입니다.&lt;/p&gt;
&lt;p&gt;이해가 갔지만, 그래도 저는 싫었습니다. 이런저런 고민들로 점점 지쳐가고 있을 때, 어느 날 같은 회사의 10 년차 선배님이 농담 삼아 제게 이런 말씀을 하셨습니다. “지금의 내 모습이 바로 10 년 후의 니 모습일꺼야” 물론 농담이었지만, 이 말을 듣는 순간 뜨끔할 수 밖에 없었습니다. 10 년이 지나면 30 대 후반의 나이인데, 이런 회사에서 지금과 다를바 없이 일하고 있을 상상을 하니 눈앞이 캄캄하더라구요. 도저히 이건 아니다라는 생각이 들었습니다.&lt;/p&gt;
&lt;p&gt;결국 저는 1 년 5 개월이라는 짧은 기간이 지난 후 과감히 회사를 내팽개치고 나와버렸습니다. 무려 6~7 년간의 열정이 1 년 남짓한 시간만에 연기처럼 사라져버린 것이었습니다. 프로그래머로 살고 3 년째 살고 있는 지금도 가끔 건축에 대한 향수에 젖어듭니다. 특히 당시에 같이 작업하고 고민하던 친구, 선배들이 자기의 길을 변함없이 묵묵히 걸어가고 있는 모습을 보면 더더욱 그리워지곤 합니다. 그래도 돌아갈 수 없습니다. 이는 마치 헤어진 여자친구를 다시 만나는 것처럼 부질없는 일임을 잘 알기 때문입니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[나는 왜 건축을 그만두었는가?]]></title><description><![CDATA[…]]></description><link>https://blueshw.github.io/2014/04/16/why-did-i-quit-a-job-in-architecture/</link><guid isPermaLink="false">https://blueshw.github.io/2014/04/16/why-did-i-quit-a-job-in-architecture/</guid><pubDate>Wed, 16 Apr 2014 18:43:27 GMT</pubDate><content:encoded>&lt;p&gt;나는 왜 건축을 그만두었는가? 지금의 나는 이 질문에 대해 완전하게 답하지 못한채로 있습니다. 지금은 완전히 관심밖의 일처럼 자물쇠 달린 오래된 상자안에 방치해둔채 새로운 것에 대한 생각으로 가득차있지요. 건축 경기가 어려워서라던지, 한국에서 건축가라는 직업에 대한 가치를 매우 낮게 평가한다던가 하는 것은 현실에 대한 핑계에 불가하다 생각합니다. 건축을 그만둔 후 몇년간(지금까지), 누군가 저에게 왜 건축을 그만두고 지금의 길을 걷고 있냐고 물어보면 백이면 백 위와 같이 대답하곤 했습니다. 정말 이런 현실이 문제인걸까요?&lt;/p&gt;
&lt;p&gt;왜 건축을 그만두었는가를 다시 생각해보기 전에, 제가 건축을 공부하면서 느낀 건축이라는 학문에 대해서 잠깐 얘기해보겠습니다. 건축을 이를 때 좋은 말들이 많이 있습니다. ‘건축은 사회를 비추는 거울이다’, ‘건축은 종합예술이다’, ‘건축은 자신의 철학이 필요하다’ 등등 건축에 대한 정의는(주로 건축학과 에 다니는 학생들의 정의) 굉장히 철학적이고 사회적이며 심지어는 예술적이기까지 합니다. 이런 정의를 진리라고 받아들이는 건축과 학생들은(혹은 이런 정의를 증명하기 위해서는) 광범위한 지식의 습득과정이 필요합니다. 단순히 미적감각을 키우거나 그림을 잘그려서는 안되고, 시대의 흐름에 대해 뒤쳐지면 안되며, 사람과 공간에 대한 개념과 이들의 관계를 미적 또는 형태적으로 표현할 수 있어야 합니다. 그리고 그 표현을 위한 철학적 접근도 필요하지요. 굳이 철학이 아니더라도 공간에 스토리텔링이 필요한 경우도 있으며, 시적으로 공간을 접근할 수도 있습니다. 그것도 모자란건지 아니면 새로운 이론을 만들려는 건지는 잘 모르겠지만, 최근 건축계는 모든 학문과 이종교배를 시도하고 끊임없이 새로운 시도로 추구 합니다. 이 모든 것들이 쌓이고 쌓여서 종합적이고 사회적인 철학 예술이 만들어지는 것입니다.&lt;/p&gt;
&lt;p&gt;정말 위에서 말한 건축이 진짜 건축일까요? 저는 고작 1 년 동안만 건축 사무소에서 밤낮없이 일해봤습니다. 그렇기 때문에 섣불리 판단할 수는 없습니다만, 건축의 실체는 의외로 간단할지도 모릅니다. ‘사람들이 원하는 공간을 만든다’ 라고 할수 있을까요? 좀 더 현실적으로 말하자면 ‘건축주가 원하는 공간을 만든다’라고 할 수 있겠습니다. 건축주라는 사람 또는 회사가 원하는 건축물을 만드는 것이 건축이라면 결국 건축주가 누구냐는 것이 가장 중요한 요소가 되겠지요. 아무리 뛰어난 건축가라도 결국은 건축주가 건축의 대부분을 결정하기 때문이지요. 여기서 건축가의 역할이란 단지 건축주가 원하는 건물을 넓고 멋지게(?) 짓는 사람 아닐까요. 물론 건축가 스스로가 건축주의 요구를 받아들이는 수준 안에서 자신의 건축관을 표현할 수는 있습니다. 이런 현실에서 많은 사람들이 원하는 공간을 만드는데는 한계가 있을 수 밖에 없겠습니다. 결국 문제는 돈이 아닐까 생각합니다.&lt;/p&gt;
&lt;p&gt;또 한가지 이유를 들어 볼까요? 건축은 굉장히 보수적입니다. 아직도 르꼬르뷔제의 건축의 5 원칙에서 거의 벗어나지 못했습니다. 이 5 가지 원칙을 벗어난것 처럼 보이는 디지털 아키텍트의 그래픽 작업들은 현실적으로 실현불가능해 보이는 것이 대부분이기 때문에 이 작업들을 건축이라 부르기도 조금 애매합니다. 저는 공간적으로 또는 형태적으로 이 원칙을 벗어나는 것이 미래의 건축이라고 생각하지는 않습니다. 오히려 현재의 상황에서는 오히려 얼마나 지속가능한지(환경을 고려한다던가 건축의 수명이 길다던가) 그리고 얼마나 첨단화되는지가 더 중요해 보입니다. 자원은 한정되어 있고 쓰레기는 넘쳐나기 때문에 이 문제를 조금이나마 덜 야기할 수 있다면 그것은 분명 훌륭한 건축이 될 수 있겠지요. 또 공간의 질을 높이는 것도 공간의 구성이나 동선 등 전통적인 건축 요소뿐 아니라 IT 분야와의 접목이 더욱 중요해질 것입니다. 유비쿼터스라던가, 인터랙티브 공간이라든가, 생활패턴에 의한 공간변화와 같은 반응형 공간이 이러한 예가 되겠습니다. 하지만 건축학과의 교육 커리큘럼을 살펴보면 지금이나 10 년전이나 전혀 달라진 것이 없습니다. 여전히 설계수업, 구조수업, 의장수업, 설비수업, 재료수업 정도로 나뉘어 있습니다. 환경수업이 있긴 하지만 결로나 태양광 같은 자연적인 것에 한정되어 있고 미래의 환경에 대한 고민은 전혀 없습니다. IT 쪽은 더욱 열악하지요. 수업이 전혀 없습니다. 건축과에서 코딩수업을 하라는 말은 아닙니다. 그저 공간의 질을 높이기 위해서 어떤 기술을 접목할 수 있는지에 대한 수업은 필요하겠습니다.&lt;/p&gt;
&lt;p&gt;종합해보면, 돈이 우선일수 밖에 없는 현실, 이론이나 교육과 실제 건축의 괴리, 변화없는 보수적인 학문이라는 이유로 요약될 수 있겠는데요. 이런 이유로 건축을 그만둔게 맞을까요? 여전히 잘 모르겠습니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[글을 써야 한다는 것의 집착]]></title><description><![CDATA[블로그 글도 몇 개 되지 않지만 블로그를 거의 내버려둔 시간이 오래되었습니다. 심지어 티스토리 로그인이…]]></description><link>https://blueshw.github.io/2014/01/03/think-about-my-writing/</link><guid isPermaLink="false">https://blueshw.github.io/2014/01/03/think-about-my-writing/</guid><pubDate>Fri, 03 Jan 2014 05:04:28 GMT</pubDate><content:encoded>&lt;p&gt;블로그 글도 몇 개 되지 않지만 블로그를 거의 내버려둔 시간이 오래되었습니다. 심지어 티스토리 로그인이 3 개월이 넘어서 휴면 계정을 해제 하라고 하더군요. 처음 블로그를 시작할 때는 특정 주제에 대해(주로 환경과 관련된) 어느정도의 길이의 완성된 글을 쓰겠다는 생각이었습니다만, 글을 쓰는게 익숙하지 않은 상태의 사람이 갑자기 완성된 형태의 글을 쓴다는 것은 많은 시간의 할애가 필요한 일이더군요. 자료의 수집에서 시작해서 모은 자료를 정리하고 정리된 자료를 통해서 주제를 선정하고 거기에 내 의견을 더하여 글을 쓰고 두어번 퇴고의 과정을 거치다보면 대충 3~4 시간이 소요 되더군요. 제가 그렇게 부지런한 성격도 아니고 하루에 3~4 시간을 글쓰는데 투자하는 것은 쉽지 않은 일이었습니다. 그러다보니 하루에 하나를 쓰겠다는 의지는 일주일에 세개, 두개가 되고 이런일 저런일이 있다보면 자연스럽게 글을 쓰는것을 멀리하게 되더군요.&lt;/p&gt;
&lt;p&gt;왜 그럴까 생각해보았습니다. 생각하다보니 몇가지 이유가 떠오르더군요.&lt;/p&gt;
&lt;p&gt;1. 너무 전문적인 주제로 글을 쓰려는 생각&lt;/p&gt;
&lt;p&gt;2. 완성된 글을 쓰겠다는 생각&lt;/p&gt;
&lt;p&gt;3. 글을 길게 써야 한다는 것에 대한 집착&lt;/p&gt;
&lt;p&gt;대충 위의 세가지로 요약되는 것 같습니다. 우선 공통적으로 위의 세가지는 모두 블로그의 성격과 목적 때문에 발생한 문제입니다. 기본적으로 블로그는 혼자서 보고 기록하는 매체가 아니라 남들에게 자신의 생각을 보여주기 위한 공간입니다. 이러한 역학관계가 기본전제가 되기 때문에 가벼운 주제로 뒤죽박죽인 글을 쓰는게 쉽지 않은 것이지요.&lt;/p&gt;
&lt;p&gt;첫번 째, 전문적인 주제에 대한 집착의 문제는 결국 위에서 언급한 공통적인 문제와 유사합니다. 내가 평소에 어떤생각을 가지고 있고 어떤 분야에 관심이 있는지를 쓰기보다는 남들이 내가 쓴 글을 보고 어떻게 생각할까가 더 중요했던 것이지요. 나 이런사람이다. 대단하지 않느냐? 이런식으로요. 결과적으로 대단히 관심도 없는 분야에 대해서 공부하고 자료를 수집하고 정리하는 과정이 괜히 글쓰는 시간만 더 길게 만든 것입니다.&lt;/p&gt;
&lt;p&gt;두번 째, 완성된 글을 쓰겠다는 생각입니다. 이유는 다를게 없습니다. 누군가에게 내가 쓴 문장과 문맥, 표현 등을 보여줘야 하기 때문에 최대한 잘 쓰려고 하다보니 여러차례 퇴고과정을 거치게 되고 이 역시 글 쓰는 시간을 늘리는데 한몫하게 되었습니다.&lt;/p&gt;
&lt;p&gt;사실 위의 두 가지 사항은 글을 쓰는 것을 멀리하게 되는 이유이긴 하지만, 어떤 주제를 가지고 완성된 글을 만들어가는 것은 여전히 필요한 부분입니다. 세번째로 언급한 글을 길게 쓰는 것에 대한 집착은 조금은 다시 생각할 필요가 있을 것 같습니다. 글을 쓰는 주제에 따라 길게 쓸 필요가 있기도 하지만 가벼운 주제로 간단하게 글을 쓰고 싶은데 길게 써야한다는 압박감에 억지로 문장을 늘리고 사족을 덧붙이는 경우가 많았던 것 같습니다. 때로는 가볍고 짧막하게 쓰는 글이 읽는 이의 입장에서는 더욱 편하게 느껴질지도 모르지요.&lt;/p&gt;
&lt;p&gt;이제는 좀더 가벼운 주제로 아무렇게나 한번 써볼까 합니다. 그래서 남들에게 보여주기 부끄러워 에버노트에 끄적여 놓았던 몇가지 글들도 블로그로 옮겨놓으려구요. 아무튼 블로그 다시 한번 살려보지요.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[기억(추억)의 형상화]]></title><description><![CDATA[…]]></description><link>https://blueshw.github.io/2012/05/22/shaping-memories/</link><guid isPermaLink="false">https://blueshw.github.io/2012/05/22/shaping-memories/</guid><pubDate>Tue, 22 May 2012 15:36:56 GMT</pubDate><content:encoded>&lt;p&gt;기억은 시간이 지남에 따라서 점차 희미해지거나, 또는 다른 색을 입고는 변색되기 마련입니다. 인간에게 있어 기억이라는 것은 컴퓨터에 저장해 놓은 파일들과는 다른 종류의 것이지요. 대부분의 사람들은 과거의 순간들 혹은 그 때의 생각이나 감정을 어렴풋이 알수는 있지만 정확히 기억해내지 못합니다. 그렇기 때문에찢어질듯이 가슴아픈 이별의 순간도 시간이 지나면 무뎌지기 마련이지요.&lt;/p&gt;
&lt;p&gt;기억 혹은 추억을 형상화 하는 방법에는 크게 두 가지가 있습니다.  사진으로 남기는 방법, 그리고 글로써 남기는 방법입니다(사실 이 두 가지 외에도 여러가지가 있겠지만, 여기에서는 위의 형태로만 나누겠습니다). 두 가지 중 가장 흔히 사용되는 것은 바로 사진을 이용하는 방법입니다. 사진으로 남기는 방법의 가장 큰 장점은 무엇보다 쉽고 빠르게 만들어 낼 수 있다는 점입니다. 이제는 흔하다 못해 누구나 가지고 있는 디지털카메라나 스마트폰만 있으면 언제 어디서나 손쉽게 순간을 사진으로 남길 수 있고, 보고 싶을 때면 언제나 꺼내어 볼 수도 있습니다.&lt;/p&gt;
&lt;p&gt;과거 수십년 전만해도 사진의 속성은 지금과는 조금 달랐습니다. 지금이야 사진을 찍었다가 맘에 들지 않으면 지우면 그만이지만, 과거의 필름 카메라의 경우 사용할 수 있는 필름의 수량이 한정적이기 때문에 사진을 한장 찍는데도 수십번 고민한 끝에 숨을 죽이고 셔터를 눌러야합니다. 그리고 그 결과물은 바로 확인할 수 없고 하루나 이틀은 기다려야 받아볼 수 있지요.&lt;/p&gt;
&lt;p&gt;사실 구체적인 장면을 담고 있는 것이 사진이지만, 사진에 담긴 장면이 너무나 사실적이기 때문에 그 속에 담긴 개개인의 기억은 오히려 추상적입니다. 그 구체적이고 사실적인 과거의 순간을 담는 것이 사진이지만, 그 시점에 가졌던 나의 생각과 감정은 사진 속에 고스란히 담을 수 없기에 사진은 추상적이라 말할 수 있습니다.&lt;/p&gt;
&lt;p&gt;두 번째 방법은 글을 통한 형상화입니다. 구체적인 사실을 담고 있는 추상적인 이미지인 사진과는 달리 글은 구체적인 내용을 통해 추상적인 사실을 상상할 수 있습니다. 사진과 같이정확한 형상을 표현할 수는 없지만 의식의 흐름이라던가, 대상에 대한 느낌 혹은 감정의 변화 등은 오히려 자세히 알 수 있습니다. 그러다 보니 문득 과거에 내가 어떠한 글을 썼는지 궁금해지더군요. 여행을 할 때, 건축 작업을 할 때, 훈련소에 있을 때, 혹은 방치된 블로그에 버려진 글 등 여러가지가 떠올랐습니다. 그 당시에 가졌던 생각과 마음은 어떠했고, 지금과는 어떻게 다른지 알아보고 싶어 졌습니다. 그래서 그 글들 중에서 몇가지는 각색하여 블로그에 기록해 놓으면 좋겠다는 생각을 해보았습니다.&lt;/p&gt;
&lt;p&gt;그래서 우선  5 년 전 한달 동안의 도보여행 중, 끄적였던 것들을 당시의 사진과 함께 블로깅해 볼까 합니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[대화가 필요해(?)]]></title><description><![CDATA[…]]></description><link>https://blueshw.github.io/2012/05/09/need-conversation/</link><guid isPermaLink="false">https://blueshw.github.io/2012/05/09/need-conversation/</guid><pubDate>Wed, 09 May 2012 16:30:34 GMT</pubDate><content:encoded>&lt;p&gt;연인, 친구, 가족을 포함한 모든 관계에서 대화는 갈등을 해소하는 가장 좋은 수단입니다. 여자친구와 싸웠거나, 친구와 다퉜을 때도 감정을 배제하고 차분하게 대화를 해보면 사실 아무것도 아닌 경우가 대부분이지요. 하지만 감정에 휘둘리거나 자존심의 이유로 다툰 상대와 계속해서 대화하기를 꺼려하다가는 두 사람은 다시는 돌이킬 수 없는 관계가 될 수도 있습니다. 그만큼 대화라는 것은 인간사회의 ‘관계’에서 굉장히 중요한 부분입니다.&lt;/p&gt;
&lt;p&gt;일반적으로 우리는, 인간 사이에서 발생하는 대부분의 대화는 말이라는 음성으로 이루어지는 것이라 여깁니다. 하지만 한 연구에 따르면, 실제 인간 사이의 의사소통 과정에서 말 자체가 차지하는 비중은 약 10 퍼센트 정도밖에 안된다고 합니다. 나머지 90 퍼센트는 의사소통 과정 중에서 나타나는 말투, 억양, 행동, 태도, 상황, 몸짓, 눈빛, 뉘앙스 등이 차지하고 있습니다. 이 말은 즉, 같은 말을 해도 내가 어떤 상황에서 어떤 태도로 하느냐에 따라서 받아들이는 사람의 입장에서는 극과 극이 될 수 있다는 것입니다. 대화가 갈등을 해소하는 가장 좋은 수단이 될 수도 있지만, 반대로 관계를 해치는 가장 나쁜 수단이 될 수도 있습니다.&lt;/p&gt;
&lt;p&gt;우리 사회에서 말로 인한 문제는 이미 우리 일상에서 쉽게 찾아볼 수 있습니다. 메신저나 문자메세지가 그렇습니다. 메신저 상의 대화는 글로만 이루어져 있습니다. 컴퓨터나 스마트폰으로 전달하는 이 메세지에는 글자만 있을 뿐 말하는 사람의 감정이나 억양, 행동 등을 제대로 표현되어 있지 않습니다. 그렇다보니 받아들이는 사람의 입장에서는 전달된 메세지만 보기 때문에 전달하는 사람의 의도와 상관없이쉽게 오해를 할 수 있습니다. 아마 남성분들이라면 연인에게 이모티콘 하나 없는 건조한 메세지를 보냈다가 괜한 다툼으로 번졌던 일을 한번쯤 겪어 보셨을 것입니다.&lt;/p&gt;
&lt;p&gt;세상에는 말이 필요 없는 관계도 있습니다. 서로 말이 통하지 않아도 충분히 서로를 아끼고, 사랑할 줄 압니다. 말이 통하지 않는데 어떻게 서로를 이해하고 사랑하냐구요? 위에서 언급했듯 인간이 행하는 의사소통에는 말을 제외한 다른 요소들이 약 90 퍼센트를 차지하고 있기에 10 퍼센트밖에 차지하고 있지 않은 ‘말’이 없다고 해서 서로를 사랑하지 못한다는 것은 말도 안되는 얘기입니다.&lt;/p&gt;
&lt;p&gt;우리 삶은 너무나도 크게 말에 의존하고 있습니다. 스마트폰이 보급되면서 그 의존도는 더 커졌지요. 만나서 얼굴을 마주하고 얘기하는 것 보다 스마트폰의 자판을 누르며 건조한 말(?)을 주고 받는 것이 더 편한 세상입니다. 심지어는 바로 옆자리에 앉은 사람과도 메신저로 말을 주고 받지요. 대화는 말을 주고 받는 단순한 것이 아닙니다. 대화는 상대방을 마주하고 눈과 표정을 보면서 마음을 주고 받는 행위입니다. 상대방이 하는 말이 중요한 것이 아니라 상대가 어떤 마음으로 이 말을 하는가가 더 중요한 것입니다.&lt;/p&gt;
&lt;p&gt;컴퓨터와 스마트폰의 발달이 우리의 삶을 훨씬 편하게 만들어 준 것은 부정할 수 없는 사실입니다. 하지만 가끔은누군가와 키보드나 스마트폰이 아닌 눈으로, 건조한 메세지가 아닌 마음으로 대화를 나누어 보는 것이 어떨까요?&lt;/p&gt;</content:encoded></item><item><title><![CDATA[걸음에 대한 단상]]></title><description><![CDATA[하루에 얼마나 걸으시나요? 2,000 보? 5,000 보? 걸음의 수를 정확히 측정할 수는 없지만 하루에 5,00…]]></description><link>https://blueshw.github.io/2012/04/19/think-about-walking/</link><guid isPermaLink="false">https://blueshw.github.io/2012/04/19/think-about-walking/</guid><pubDate>Thu, 19 Apr 2012 17:45:41 GMT</pubDate><content:encoded>&lt;p&gt;하루에 얼마나 걸으시나요? 2,000 보? 5,000 보? 걸음의 수를 정확히 측정할 수는 없지만 하루에 5,000 보 이상을 걷는 사람은 그렇게 많지 않을 것이라 생각이 듭니다. 아침에는 지하철을 타러 갈때나, 환승할 때나, 지하철에서 내려 회사까지 걸어갈 때 걷고, 저녁에 퇴근할때는 이와는 반대 순서로 걷게 되지요. 조금 나은 사람들은 멀지 않은 거리는 걸어 다니거나, 점심시간에 산책을 하는 정도가 있겠습니다. 하지만 이 정도 걷는다고 하더라도 정작 계산해보면 그 숫자는 결코 많지 않다는 것을 알 수 있습니다.&lt;/p&gt;
&lt;p&gt;한 사람의 평균 보폭을 70cm 정도(참고 자료에 의하면 젊은 여자의 경우 70cm 정도이고 남자는 74cm 정도라고 합니다)라고 가정하고 시간당 4km 를 걷는 사람이 한시간 동안 걷게되면 그 사람의 총 보폭수는 5,714 보 정도가 됩니다. 지하철역까지 5 분, 환승 5 분, 회사까지 10 분 정도로 가정하고 저녁에도 이를 반복하게 되면 보통 하루 40 분 정도를 걷게 되는데, 보폭수로 따져보면 약 3,809 보가 되고 소모칼로리는 대략 150Kcal 가 되겠지요(걷는 사람의 몸무게와 걷는 속도가 변수로 작용하겠지만 대략적으로는 이 정도 수치가 나온다고 간주합니다). 그나마 지하철이나 버스등의 대중교통을 타고 다녀야 이정도의 보폭수와 소모 칼로리가 발생하게 됩니다.&lt;/p&gt;
&lt;p&gt;그렇다면 자동차를 타고 출퇴근하는 사람들의 경우는 어떨까요? 이들이 출퇴근하는 모습을 상상해봅시다. 우선 집을 나서서 집앞에 주차된 자동차까지 걸어갑니다. 자동차 시동을 걸고 회사 지하주차장까지 앉아서 운전합니다. 그리고 주차장에 차를 세워둔 다음 근처에 있는 엘리베이터까지 걸어가겠지요. 그 다음 엘레베이터를 타고 사무실이 있는 층까지 올라와서 자신의 자리까지 걸어서 들어갑니다. 만약 이런 방식의 출퇴근이라면 집에서 나와서 자동차까지, 회사 주차장에 세워둔 자신의 차에서 엘레베이터까지, 엘레베이터에서 회사안 자기 자리까지 걷는 것만이 출근 동안 걷는 걸음 수의 전부일 것입니다. 퇴근시에도 반복한다고 가정하고 그 수에 2 를 곱하면 이 사람이 하루동안 출퇴근을 통해 걷는 총 걸음 수가 나오게 됩니다. 하지만 그 수는 많아도 1,000 보에 미치기 어려울 것입니다.&lt;/p&gt;
&lt;p&gt;위에 보시는 사진은 오래전에 유행하던 만보기입니다. 하루 만보 걸으면 건강해진다는 말로 한때 너도나도 허리춤에 하나씩 가지고 다녔었지요. 그렇다면 하루에 만보를 걸으면 어느 정도의 효과가 있을까요? 위에서 3,809 보를 걸었을때 대략 150Kcal 가 소모된다고 했으므로, 이 수치를 10,000 보로 환산해보면 대략 400Kcal 에 조금 못미치는 칼로리 소모량이 나옵니다. 자전거를 한 시간 타야 300Kcal 정도가 소모되는 것을 감안하면 결코 낮은 수치는 아니지요.&lt;/p&gt;
&lt;p&gt;걷는 것이 런닝이나 다른 운동들보다 상대적으로 칼로리 소모량이 큰 것은 아니지만 걷기 운동에는 여러가지 장점이 있습니다. 바로 아래와 같은 것들이지요.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;심폐기능 상승 및 혈액순환 촉진&lt;/li&gt;
&lt;li&gt;체지방 감소 및 성인병 예방&lt;/li&gt;
&lt;li&gt;골밀도 유지로 인한 골다공증 예방&lt;/li&gt;
&lt;li&gt;스트레스 해소 및 불안감, 우울증 해소&lt;/li&gt;
&lt;li&gt;면역력 증가&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;위와 같은 내용들은 당연하고 익히 알려진 장점들입니다. 하지만 조금만 생각해보면 거의 모든 운동들이 위와 같은 장점들을 가지고 있는 것을 알 수 있습니다. 그렇다면 과연 운동으로서의 걷기가 아닌 걷기 자체만으로의 장점은 어떤 것이 있을까요? 제가 걷는 것을 좋아하고 또 즐겨 하기 때문에 제 경험을 바탕으로 한 장점 몇 가지를 추려보면 다음과 같습니다.&lt;/p&gt;
&lt;h3&gt;사색&lt;/h3&gt;
&lt;p&gt;걷는 것은 곧 생각하는 것과 연결됩니다. 단순히 걷기 때문에 생각되어 지는 것이 아니라 걷기와 생각하는 것 사이에는 좀 더 과학적인 근거가 존재합니다. 사람의 몸은 땅에 발을 내딛을 때마다 발의 신경부터 시작해서 온몸의 근육이 걷는 행위 중에 균형을 잃지 않도록 활동하게 됩니다. 걷는 행위라는 것은 이러한 움직임의 반복이기 때문에 활발하게 활동하는 신경과 세포들이 뇌신경의 활동에도 영향을 미쳐서 사색(생각)으로 이어지는 것입니다.&lt;/p&gt;
&lt;h3&gt;관찰&lt;/h3&gt;
&lt;p&gt;도보 여행을 해본 사람들이라면 다들 알고 있을 거라 생각합니다. 걷는 것은 기차나 자동차를 타고 지나가는 것과 다릅니다. 기차나 자동차를 타고 가면서 보는 창밖의 풍경들에서는 놓쳤던 많은 것들을 걸음을 통해 모두 관찰할 수 있습니다.&lt;/p&gt;
&lt;h3&gt;대화&lt;/h3&gt;
&lt;p&gt;걸음은 자신과의 대화를 가능하게 합니다. 아무도 없고 아무 소리도 나지 않는 조용한 시골길이나 텅빈 도로를 혼자서 걷다보면 자연스럽게 자신이 누구이고 어디로 가야하는지에 대한 깊은 생각에 빠지게 됩니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[사회적 기업의 역할]]></title><description><![CDATA[한국사회에서는 ‘…]]></description><link>https://blueshw.github.io/2011/04/29/role-of-social-venture/</link><guid isPermaLink="false">https://blueshw.github.io/2011/04/29/role-of-social-venture/</guid><pubDate>Fri, 29 Apr 2011 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;한국사회에서는 ‘3 불 타령’이라는 말이 있습니다. 어떤 새로운 일을 하려고 하면 ‘규정에 맞지않다’, ‘선례가 없다’, ‘예산이 없다’ 라는 것입니다.  이와같은 말을 가장 많이 하는 곳이 아마도 공무원들이 일하는 관공서일 것입니다.  실제로 제가 공무원과 그렇게 많은 일을 같이 해보지는 않았지만 그들은 어떤 새로운 일에 대해서 책임지는것을 꺼리는 경향이 있습니다.  무슨 일을 하려고 하면 항상 규정을 따지고 새로운 것에 대한 거부감으로 충만해 있으며 예산은 충분한데 정말 필요한 곳에 쓰려고 하면 예산이 없다고 합니다.&lt;/p&gt;
&lt;p&gt;한국사회에서는 이와관련된 또 하나의 이상한 현상이 있습니다. 그 어느나라보다 공무원이 되고자 하는 청년들이 많아 공무원시험에 합격하기가 하늘의 별따기 만큼이나 어렵습니다. 보통 몇십대일의 경쟁률은 기본인것 같습니다. 그렇다보니 ‘공무원을 준비하는 사람’이라는 실업자들도 많은 상태이지요. 이런 현상이 존재하는 가장 큰 이유는 공무원을 소위말하는 ‘철밥통’이라 부르며 일종의 평생직장이라 생각하기 때문입니다.  공무원 시험에 어렵게 붙었는데 자칫잘못해서 어떤일에 책임을 졌다가 문제가 생기길 바라는 공무원은 없을것입니다. 그래서 공무원들은 자신의 자리에서 어떤 일에대해 책임지기를 꺼려하는 것은 어쩌면 당연한 현상이라 할 수도 있겠네요.&lt;/p&gt;
&lt;p&gt;요즘 한국사회는 때아닌(?) 혁신의 바람이 불고 있습니다. 국가와 공무원집단도 마찬가지지요. 무엇을 위한 ‘혁신’인지는 모르겠지만 자신들에게 문제점이 있는 것을 알고 그것을 고쳐보자는 취지는 나쁘지 않은듯 합니다. 하지만 ‘혁신’을 위한 혁신이 대부분이고 과한 경쟁으로인한 실적위주의 일처리 방식은 과거 공무원이 보여주었던 나태하고 안일한 모습과 다를바 없다는 생각이 들었습니다.&lt;/p&gt;
&lt;p&gt;제가 오늘 말하고자 하는바가 공무원에 대해서가 아닙니다. 하지만 한국의 공무원에 대해서 잠깐 언급한것은 영국의 사회혁신 리포트《올리버는 어떻게 세상을 요리할까?》에 소개된 여러 사례에서 보여주는 관공서의 역할 때문입니다.  현대사회의 문제점을 분석하여 창의적인 해결책을 찾아내는 것이 어찌보면 정부나 관공서의 역할 같아 보입니다. 하지만 실제적으로 이러한 일을 도맡아 하는 곳은 관공서가 아니라 사회단체 및 사회적 기업입니다. 사실 정부는 여러 사회문제에 대해서 분석하여 예산을 편성하는 등의 큰 그림은 그릴수 있을지 몰라도 실제로 사회 깊숙히 들어와 진짜 문제가 무엇이고 무엇을 어떻게 해결해야 하는지 구체적으로 알지는 못합니다. 그리고 현대사회의 문제들은 수없이 많지만 정부가 이 모든 문제들을 단순히 돈으로 해결하기에는 너무나 복잡합니다. 그렇기 때문에 우리사회 곳곳에 사회적 기업이 필요한 것입니다.  어떤 사회문제에 대한 근본적인 해결을 위해서는 정부의 예산이 얼마가 편성되었느냐가 아니라 구체적으로 어떠한 돈을 어디에 얼마만큼 적절히 쓰느냐가 더 중요한 것입니다. 정부가 하지 못하는 일을 사회적 기업이 대신해주는 것이지요. 이것이 사회적 기업이 하는 일이라 할수 있겠습니다.&lt;/p&gt;
&lt;p&gt;저는 사회적 기업에 관심이 많고 사회적 기업에 대해서 공부하고 있습니다. 이 책을 읽은 이유도 이것이지요. 하지만 저는 이 책에서 보여준 대부분의 사회적 기업의 모습은 사회적 기업이라기 보다는 사회단체에 가깝다는 생각을 했습니다. 물론 좋은일을 하자는 취지는 똑같을지 모르겠지만 ‘기업’이라는 것은 확실한 비즈니스 모델이 있어야 한다고 생각합니다. 사회적기업과 사회단체의 가장 큰 차이점이 바로 하는일을 통해 돈을 벌수 있냐 없냐라는 것이지요. 그래서 사회적 기업을 창업 하려고 할때, ‘지원금으로 하지 뭐’식의 사고방식은 반드시 지양해야 합니다. 사회적 기업은 영세한 경우가 대부분이라 지원금이 불가피할 경우도 있지만 회사의 운영이 지원금에 의존되어서는 안됩니다. 예를들어 정권이 바뀌거나 예산편성이 바뀌는 경우처럼 지원금은 언제라도 없어질수 있기 때문입니다. 회사가 지원금에만 의존하고 있었다면 이런경우에는 십중팔구는 망하고 말겠죠.&lt;/p&gt;
&lt;p&gt;또 한가지 말하고 싶은것은 현재 대한민국 정부에서 사회적 기업을 바라보는 시각에 대해서입니다. 우리나라에서 정의하는 사회적기업은 한가지의 관점에 국한되어 있습니다. 바로 ‘고용’입니다. 기업을 만듦에 있어 중요한 것이 이윤추구가 아니라 고용이라는 것이지요. 이윤추구를 위해 고용하는 것이아니라 고용을 위해 이윤을 추구한다는 것이 한국에서 인정하는 사회적기업의 모델입니다. 예를들면 장애인 바리스타를 고용하여 운영하는 까페, 새터민이나 이주여성으로만 구성된 공장을 운영하는 회사 등이 있습니다. 이러한 형태의 기업도 당연히 사회적 기업입니다. 하지만 고용만을 위한 것만이 사회적기업은 아닙니다. 사회적기업이라는 것은 현존하는 사회문제를 기존의 방식과는 다른 창의적인 방법을 통해 고용창출, 빈민구제, 저소득층 지원, 환경문제 해결 등을 실현하는 기업이라 할 수 있습니다. 현재 한국사회에서 가장큰 문제중에 하나가 실업문제임을 감안한다면 고용창출이 사회적 기업을 결정하는 기준이 된것을 이해할수 있지만, 앞으로 한국사회의 다양한 문제들을 효과적으로 해결하기 위해서는 사회적 기업을 결정하는 기준을 확대할 필요가 있습니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[산에게서 배웁니다.]]></title><description><![CDATA[…]]></description><link>https://blueshw.github.io/2011/04/13/learning-from-mountain/</link><guid isPermaLink="false">https://blueshw.github.io/2011/04/13/learning-from-mountain/</guid><pubDate>Wed, 13 Apr 2011 21:58:28 GMT</pubDate><content:encoded>&lt;p&gt;최근 많은 일이 있었습니다. 신변의 변화가 있었고, 그 변화로 인한 심정의 변화가 있었습니다. 그러다보니 자연스럽게 블로그에 거의(?) 무신경해져 버린것 같습니다. 인생의 터닝지점이 되는 순간이라 생각했기 때문에 나름의 휴식도 가질겸, 짧게 여행을 다녀왔습니다. 처음에 계획했던대로 못한것은 아쉽지만 짧은 기간동안 새로운 경험을 통해 생각할 시간을 가질 수 있었던 것은 참으로 다행이었던것 같습니다.&lt;/p&gt;
&lt;p&gt;저는 산을 다녀왔습니다. 처음에는 하루에 한봉우리씩 총 네 곳의 정상에 도전하는 거창하고도 무모한(?) 계획을 세웠습니다. 제가 왜 그랬는지 잘 모르겠습니다만 아마도 산을 너무 우습게 봤던 것 같습니다. 그리고 등산 경험도 전무한 제가 저 스스로를 너무 과대평과 했던것도 있구요. 경기도 양평의 용문산을 시작으로 원주 치악산, 단양 소백산 그리고 마지막으로 지리산 정상에 올라 대피소에서 하룻밤 묵는 것이 저의 계획이었습니다. 등산 고수님들이 이 계획을 보시면 너무 무모하다 생각하실지 아니면 겨우 이정도 가지고 뭘 그리 유난 떠냐고 하실지는 모르겠습니다만 어쨌든 등산 초보인 저에게는 굉장히 무모한 계획이었다라는 느낌을 받았습니다. 그래서 결국에는 용마산과 치악산 비로봉까지만 오르는 것으로 마무리 짓게 되었습니다.&lt;/p&gt;
&lt;p&gt;산에 올라가신분들은 아시겠지만 산은 굉장히 위험합니다. 모든산이 그렇진 않습니다만 제가 올랐던 두 곳은 바위로 이루어진 산이라 보통의 토산보다는 위험했습니다. ‘여기서 미끄러지면 바로 죽을꺼야’라는 생각은 다리를 후들거리게 만들고 머리를 어지럽게하지만, 그만큼 위험이 눈앞에 있기에 더욱 조심하게 됩니다. 이렇게 위험을 감수하며 스릴을 추구하는 것이 바로 등산의 묘미이기도 하지요. 그리고 끝없이 오르기만 하다가 정상에 올랐을때 느껴지는 희열 또한 산을 사랑할수밖에 없게 만드는 이유인것 같습니다.&lt;/p&gt;
&lt;p&gt;산을 오르는 일은 인생과 비슷합니다. 사람들이 정상을 향해 끝없이 오르는것 처럼 인생에서 성공이라는 정상에 오르기 위해서는 끊임없이 노력해야 하고 그 노력의 결실을 맺기 전까지는 오로지 노력하는 일밖에 없습니다. 그리고 어느덧 정상에 오르면 그동안의 노력의 고통은 아무것도 아닌것이 되고 눈앞의 광경에 넋을 놓게 되지요. 정말 꿀맛같은 기분입니다. 마찬가지로 인생에서도 엄청난 노력끝에 얻게되는 성공의 맛은 정상에 올랐을 때의 그 기분과 크게 다르지 않을 것입니다.&lt;/p&gt;
&lt;p&gt;이처럼 정상에 오르는것도 중요하지만 사실 그것이 전부는 아닙니다. 정상에 오른 그 기분이 좋은 것은 사실이나 정상에 오르는 것만이 산을 찾는 이유는 아닐 것입니다. 새벽 일찍부터 오르기 시작하여 정상에 올라 정오가 지나자마자 빠르게 내려오는 사람들이 있는 반면 시간을 두고 천천히 오르면서 산의 기운과 자연의 정취를 즐기려는 사람들도 많이 있습니다. 또한 정상에 오르는 것만이 목적이 아니라 여러 사람들과 함께 오르면서 자연을 즐기며 즐거움을 찾는 사람들도 있지요.&lt;/p&gt;
&lt;p&gt;저 또한 산을 오르는 동안 지금 저의 상황과 산을 오르는 모습을 대비시켜보았습니다. 불안하고 불명확하고 이룬것 없이 혼란스럽고 남들에게 뒤쳐지는 것만 같은 현재의 상황에서 정상만을 바라보며 산을 오르는 모습은 내가 추구하는 가치와는 다른 모습이었습니다. 물론 정상을 오르는 것을 목표로 삼고 산을 찾았지만 정작 산을 오를때에 중요한 것은 경쟁이나 속도가 아니라 스스로의 방향과 페이스를 가지고 천천히 한발한발 올라가는 것이었습니다. ‘왜 내가 남들보다 먼저 정상에 오르지 못한 것일까?’ 혹은 ‘저 앞에 가는 사람보다 내가 먼저 가야지’라는 생각은 자칫 잘못하면 대형사고로 이어질수 있습니다. 모든 사람들은 그들 스스로가 정한 목적과 목표가 있는 것이고 그들 스스로의 페이스가 있는 것이기 때문에 내가 저 사람보다 뒤쳐지는 것은 아무 의미 없는 것입니다. 인생에서도 마찬가지입니다. 내가 친구보다 좀 더 늦게 취직을 했다거나 연봉이 적다거나 하는 것은 지금 순간의 문제일뿐이지 내가 친구보다 뒤쳐지는 것이 아닙니다. 중요한 것은 나의 목표가 무엇이고 내가 지금 가고 있는 길이 나의 목표를 향하고 있느냐는 것이지요.&lt;/p&gt;
&lt;p&gt;얼마전, 기로에 서있던 저는 한가지 길을 선택했습니다. 제가 선택한 그 길이 더 나은 길인지는 두고봐야겠지만 적어도 제가 선택한 길이 제 인생의 목표의 방향으로 향하고 있다고 믿습니다. 그리고 그 길을 걸어가는 그 과정을 제대로 즐겨볼 생각입니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[당신의 젊음은 어디에 있습니까?]]></title><description><![CDATA[일반적으로 20 대에 접어든 사람들을 두고 젊은 사람이라고 말합니다. 그리고 10 대의 청소년들을 두고는 어리다고 말하지요. 30 대가 지난 4…]]></description><link>https://blueshw.github.io/2011/03/12/where-is-the-your-youth/</link><guid isPermaLink="false">https://blueshw.github.io/2011/03/12/where-is-the-your-youth/</guid><pubDate>Sat, 12 Mar 2011 01:16:12 GMT</pubDate><content:encoded>&lt;p&gt;일반적으로 20 대에 접어든 사람들을 두고 젊은 사람이라고 말합니다. 그리고 10 대의 청소년들을 두고는 어리다고 말하지요. 30 대가 지난 40 에 접어들면 혹하지 아니한다는 ‘불혹’에 접어듭니다. 그 이후로는 말할 것도 없이 젊음과는 거리가 멀지요. 10 대 동안 자라 20 대가 되어 완성된 우리의 몸을 두고 바로 젊다고 말합니다. 물론 지금 제가 말하고 있는 ‘젊음’은 신체에 관한 것입니다.&lt;/p&gt;
&lt;p&gt;젊음은 인생에서 꼭 한번씩 찾아옵니다. 그 어떤 사람이라도(희귀한 질병을 가진 사람은 제외하고) 평등하게 딱 시절만 젊음을 누릴 수 있습니다. 누가 돈이 많고 누가 가난하더라도 젊음에 있어서 만큼은 평등하지요. 아무리 많은 돈을 주어도 살 수가 없는 것입니다. 그렇다면 우리는 인생에 딱 한번만 누릴 수 있는 이 젊음의 시기를 과연 어떻게 보내고 있을까요?&lt;/p&gt;
&lt;p&gt;올해 78 을 맞으신 이어령 전 문화부장관의 2010 년작 ‘젊음의 탄생’입니다. 거의 삶의 끝자락에 다가가고 있는 이어령 선생님께서는 어째서 젊음의 ‘탄생’이라는 책을 쓰게 됐을까요? 자신이 살아온 날을 돌아보며 자신이 젊었을 당시의 사고방식과 젊음을 대하는 태도를 지금 막 태어나는 수많은 젊음들을 위해 선배로서 한마디 해주고 싶었겠지요. 혹은 현 시대 대한민국의 젊지않은 젊음들을 바라보며 따끔한 한마디의 충고일지도 모릅니다. 하지만 이 책은 젊은 신체를 가진 젊은 사람들에게 전하는 메세지 이상의 것이 있습니다. 바로 어떤 신체를 가졌느냐가 아니라 어떠한 마음가짐과 정신을 가졌느냐에 따라 젊음이 탄생한다는 것입니다.&lt;/p&gt;
&lt;p&gt;이 시대의 청소년과 청년들은 모두 하나의 목표를 가지고 살아갑니다. 초중고 시절에는 어떤 대학을 갈것인가가 인생 최대의 목표입니다. 하지만 그렇게 힘들게 대학을 들어가도 그들의 앞에는 취업이라는 더 큰 관문이 기다리고 있습니다. 그래서 요즘의 대학생들은 입학과 동시에 학문에 뜻을 두기 보다는 더 나은 곳으로의 취업을 위한 공부를 시작합니다. 어학, 한자, 토론, 공모전, 봉사활동, 어학연수 등 소위 말하는 ‘스펙 쌓기’죠. 학생들은 대학을 다니는 4 년동안 남들보다 얼마나 더 많은 이력을 갖췄느냐에 따라 더 좋은 직장에 들어갈 수 있다고 생각합니다. 실제로도 대부분의 기업체에서는 이러한 스펙으로 인재를 판별하는 경우가 대부분입니다. 이러한 사회구조는 스펙형 인간을 만들고 남들보다 늦거나 스펙이 떨어지는 사람은 더 못난 사람이다라는 의식을 가지게 만듭니다. 젊음의 열정으로 불태워야 할 시기에 취업에 열정을 쏟고 있으니 젊음은 이제 더이상 젊은 사람들의 것이 아닌 것 같습니다.&lt;/p&gt;
&lt;p&gt;이 시대의 젊음이 죽어가고 있습니다. 젊음이 충만해야할 젊은이들은 사회에서 정해준 길만 따라가려고 하고 더이상 스스로의 길에대해 고민하고 방황하지 않습니다. 이런 고민과 방황은 그저 쓸데없는 것이라 여기고 오로지 정해진 한길만을 묵묵히 가는 것이 바른 삶 혹은 젊음의 삶이라 생각합니다. 이어령 선생님은 이 시대의 젊은이들에게 진정한 젊음이 무엇이고 어떻게 태어나는지를 9 가지로 설명합니다. 뜨는 것과 나는 것의 차이, 묻는데 그치지 않고 물음과 동시에 느끼는 것, 진리를 찾아가는 방황과 자신의 길에대한 확고한 믿음, 편협한 시각에서 벗어난 공존의 자세, 어울림과 통합을 통한 창조의 길, 편견과 오만을 버린 유연한 사고, 결핍을 통한 창조, 자신이 하고싶은 일을 즐기는 것, 동양과 서양의 공존, 이 9 가지를 통해서 진정한 젊음의 정신이 태어난다고 말입니다.&lt;/p&gt;
&lt;p&gt;남들이 저만치 가고 있다고 초조해하거나 불안해 하지 마십시요. 당신이 다른 사람보다 늦다고 저 사람을 쫓아가야겠다는 마음도 버리세요. 중요한 것은 당신이 어떤 사람이냐는 것이고 어떤 일을 하고 싶냐는 것입니다. 당신이 정말 하고싶은 일이 있다면 당신이 그것만으로도 세상에서 가장 행복한 사람입니다. 더이상 남들처럼 살려고 하지 말고 자신의 삶을 찾으세요. 찾았다면 바로 실천하세요. 젊음은 신체에서 오는 것이 아니라 바로 자신의 삶에 대한 열정과 행동에서 탄생하는 것임을 잊지마세요.&lt;/p&gt;</content:encoded></item></channel></rss>