<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 2.0.0"/><link rel="alternate" type="application/rss+xml" href="/rss.xml"/><link rel="shortcut icon" href="/icons/icon-48x48.png"/><link rel="manifest" href="/manifest.webmanifest"/><meta name="theme-color" content="#663399"/><title data-react-helmet="true">Functional Programming in Scala week 5 | bono&#x27;s blog</title><meta data-react-helmet="true" name="description" content="5.1 More Functions on Lists 이번 챕터에서는 스칼라 List 의 다른 메서드 들을 알아본다.
xs 는 list 의 object 를 뜻한다. Sublists and element access xs.length xs 의 길이 xs…"/><style id="typography.js">html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress{vertical-align:baseline}[hidden],template{display:none}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{font:100%/1.75 'Merriweather','Georgia',serif;box-sizing:border-box;overflow-y:scroll;}*{box-sizing:inherit;}*:before{box-sizing:inherit;}*:after{box-sizing:inherit;}body{color:hsla(0,0%,0%,0.9);font-family:'Merriweather','Georgia',serif;font-weight:400;word-wrap:break-word;font-kerning:normal;-moz-font-feature-settings:"kern", "liga", "clig", "calt";-ms-font-feature-settings:"kern", "liga", "clig", "calt";-webkit-font-feature-settings:"kern", "liga", "clig", "calt";font-feature-settings:"kern", "liga", "clig", "calt";}img{max-width:100%;margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;}h1{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;color:inherit;font-family:Montserrat,sans-serif;font-weight:900;text-rendering:optimizeLegibility;font-size:2.5rem;line-height:1.1;}h2{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;color:inherit;font-family:'Merriweather','Georgia',serif;font-weight:900;text-rendering:optimizeLegibility;font-size:1.73286rem;line-height:1.1;}h3{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;color:inherit;font-family:'Merriweather','Georgia',serif;font-weight:900;text-rendering:optimizeLegibility;font-size:1.4427rem;line-height:1.1;}h4{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;color:inherit;font-family:'Merriweather','Georgia',serif;font-weight:900;text-rendering:optimizeLegibility;font-size:1rem;line-height:1.1;letter-spacing:0.140625em;text-transform:uppercase;}h5{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;color:inherit;font-family:'Merriweather','Georgia',serif;font-weight:900;text-rendering:optimizeLegibility;font-size:0.83255rem;line-height:1.1;}h6{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;color:inherit;font-family:'Merriweather','Georgia',serif;font-weight:900;text-rendering:optimizeLegibility;font-size:0.75966rem;line-height:1.1;font-style:italic;}hgroup{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;}ul{margin-left:1.75rem;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;list-style-position:outside;list-style-image:none;list-style:disc;}ol{margin-left:1.75rem;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;list-style-position:outside;list-style-image:none;}dl{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;}dd{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;}p{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;}figure{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;}pre{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;font-size:0.85rem;line-height:1.75rem;}table{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;font-size:1rem;line-height:1.75rem;border-collapse:collapse;width:100%;}fieldset{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;}blockquote{margin-left:-1.75rem;margin-right:1.75rem;margin-top:0;padding-bottom:0;padding-left:1.42188rem;padding-right:0;padding-top:0;margin-bottom:1.75rem;font-size:1.20112rem;line-height:1.75rem;color:hsla(0,0%,0%,0.59);font-style:italic;border-left:0.32813rem solid hsla(0,0%,0%,0.9);}form{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;}noscript{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;}iframe{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;}hr{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:calc(1.75rem - 1px);background:hsla(0,0%,0%,0.2);border:none;height:1px;}address{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;}b{font-weight:700;}strong{font-weight:700;}dt{font-weight:700;}th{font-weight:700;}li{margin-bottom:calc(1.75rem / 2);}ol li{padding-left:0;}ul li{padding-left:0;}li > ol{margin-left:1.75rem;margin-bottom:calc(1.75rem / 2);margin-top:calc(1.75rem / 2);}li > ul{margin-left:1.75rem;margin-bottom:calc(1.75rem / 2);margin-top:calc(1.75rem / 2);}blockquote *:last-child{margin-bottom:0;}li *:last-child{margin-bottom:0;}p *:last-child{margin-bottom:0;}li > p{margin-bottom:calc(1.75rem / 2);}code{font-size:0.85rem;line-height:1.75rem;}kbd{font-size:0.85rem;line-height:1.75rem;}samp{font-size:0.85rem;line-height:1.75rem;}abbr{border-bottom:1px dotted hsla(0,0%,0%,0.5);cursor:help;}acronym{border-bottom:1px dotted hsla(0,0%,0%,0.5);cursor:help;}abbr[title]{border-bottom:1px dotted hsla(0,0%,0%,0.5);cursor:help;text-decoration:none;}thead{text-align:left;}td,th{text-align:left;border-bottom:1px solid hsla(0,0%,0%,0.12);font-feature-settings:"tnum";-moz-font-feature-settings:"tnum";-ms-font-feature-settings:"tnum";-webkit-font-feature-settings:"tnum";padding-left:1.16667rem;padding-right:1.16667rem;padding-top:0.875rem;padding-bottom:calc(0.875rem - 1px);}th:first-child,td:first-child{padding-left:0;}th:last-child,td:last-child{padding-right:0;}blockquote > :last-child{margin-bottom:0;}blockquote cite{font-size:1rem;line-height:1.75rem;color:hsla(0,0%,0%,0.9);font-weight:400;}blockquote cite:before{content:"— ";}ul,ol{margin-left:0;}@media only screen and (max-width:480px){ul,ol{margin-left:1.75rem;}blockquote{margin-left:-1.3125rem;margin-right:0;padding-left:0.98438rem;}}h1,h2,h3,h4,h5,h6{margin-top:3.5rem;}a{box-shadow:0 1px 0 0 currentColor;color:#007acc;text-decoration:none;}a:hover,a:active{box-shadow:none;}mark,ins{background:#007acc;color:white;padding:0.10938rem 0.21875rem;text-decoration:none;}a.gatsby-resp-image-link{box-shadow:none;}</style><link as="script" rel="preload" href="/0-8bf3a8bc80e5222607e7.js"/><link as="script" rel="preload" href="/component---src-templates-blog-post-js-fee95fd76061ab2b91a6.js"/><link as="script" rel="preload" href="/app-351efcfeb4f54983a1ef.js"/><link as="script" rel="preload" href="/webpack-runtime-589a7ddf210818ed526a.js"/><link rel="preload" href="/static/d/534/path---2016-07-26-functional-programming-in-scala-week-5-0-da-971-CqU9JkrWMKOcldeqn2M9huK1qE0.json" as="fetch" crossOrigin="use-credentials"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group"><div style="margin-left:auto;margin-right:auto;max-width:42rem;padding:2.625rem 1.3125rem"><h3 style="font-family:Montserrat, sans-serif;margin-top:0;margin-bottom:-1.75rem"><a style="box-shadow:none;text-decoration:none;color:inherit" href="/">Gatsby Starter Blog</a></h3><h1>Functional Programming in Scala week 5</h1><p style="font-size:0.83255rem;line-height:1.75rem;display:block;margin-bottom:1.75rem;margin-top:-1.75rem">July 26, 2016</p><div><h2>5.1 More Functions on Lists</h2>
<p>이번 챕터에서는 스칼라 List 의 다른 메서드 들을 알아본다.
xs 는 list 의 object 를 뜻한다.</p>
<h3>Sublists and element access</h3>
<ul>
<li>xs.length xs 의 길이</li>
<li>xs.last xs 의 마지막 item return, xs 가 비어있으면 exception 발생</li>
<li>xs.init 마지막 item 을 제외한 list reutnr, xs 가 비어있으면 exception 발생</li>
<li>xs take n 처음부터 n 개의 element 의 list 리턴, n 이 xs 의 length 보다 크면 n 개만 리턴</li>
<li>xs drop n n 개를 제외한 나머지 리스트 리턴</li>
<li>xs(n) n 번째 item 리턴</li>
</ul>
<h3>Creating new lists</h3>
<ul>
<li>xs ++ ys 두 list 더하기, :::와 같은 기능을 함</li>
<li>xs.reverse 역순의 리스트 생성</li>
<li>xs updated (n, x) n 번째 item 만 x 로 바뀐 list 생성</li>
</ul>
<h3>Finding elements</h3>
<ul>
<li>xs indexOf x x 와 같은 첫번째 element 의 index 값 리턴, 없으면 -1</li>
<li>xs contains x indexOf x >= 0 과 같음</li>
</ul>
<p>last 가 과연 필요한지 모르겠지만(tail 을 recursive 하게 반복하면 찾을 수 있음), 유용하게 쓰일 수 있다면 last 의 복잡도는 어떻게 될까?</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">def last[T](xs: List[T]): T = xs match {
  case List() =&gt; throw new Error(&quot;last of empty list&quot;)
  case List(x) =&gt; x
  case y :: ys =&gt; lsat(ys)
}</code></pre></div>
<p>위와 같이 list 의 길이와 같으므로, 복잡도는 O(n)이 되겠다.
init 메서드는 어떨까?</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">def init[T](xs: List[T]): List[T] = xs match {
  case List() =&gt; throw new Error(&quot;init of empty list&quot;)
  case List(x) =&gt; List()
  case y :: ys =&gt; y :: init(ys)
}</code></pre></div>
<p>마찬가지로 O(n)
그다음은 concat(Same as :::)</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">def concat[T](xs: List[T], ys: List[T]) = xs match {
  case List() =&gt; ys
  case z :: zs =&gt; z :: concat(zs, ys)
}</code></pre></div>
<p>복잡도는 |xs|, 즉 xs 의 길이가 된다.
다음은 reverse</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">def reverse[T](xs: List[T]): List[T] = xs match {
  case List() =&gt; xs
  case y :: ys =&gt; reverse(ys) ++ List(y)
}</code></pre></div>
<p>reverse(ys) :: y 가 아니라 reverse(ys) ++ List(y)인 이유는 ::의 마지막엔 Nil 이 와야하니깐 y 가 Nil 이 아니기 때문이 아닐까 생각한다.
복잡도는 각 요소마다 concatenating 을 해주고 list 의 length 만큼 reverse 를 해야하므로 O(n2)이 되겠다. reverse 는 다소 실망스러운 성능을 보여주는데, 앞으로 더 개선해보도록 하겠다.</p>
<p>마지막으로 removeAt</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">def removeAt[T](n: Int, xs: List[T]) = (xs take n) ::: (xs drop n+1)</code></pre></div>
<h2>5.2 Paires and Tuples</h2>
<p>앞서 살펴보앗던 insertion sort 보다 더 개선된 merge sort 알고리즘에 대해서 살펴보자. 기본적인 개념은 zero or one element 리스트는 이미 sorted 하다는 것.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">def msort(xs: List[Int]): List[Int] = {
  val n = xs.length/2
  if (n == 0) xs
  else {
    // merge 메서드는 앞으로 더 개선해 나갈 예정임
    def merge(xs: List[Int], ys: List[Int]) =
      xs mathch {
        case Nil =&gt; ys
        case x :: xs1 =&gt;
          ys match {
            case Nil =&gt; xs
            case y :: ys1 =&gt;
              if (x &lt; y) x :: merge(xs1, ys)
              else y :: merge(xs, ys1)
          }
      }

    val (fst, snd) = xs splitAt n
    merge(msort(fst), msort(snd))
  }
}</code></pre></div>
<p>밑에서 나오는 splitAt 함수는 index n 을 기준으로 리스트를 두개로 쪼개서 리턴한다. 여기서 리턴된 val 의 모양을 보자. fst 와 snd 두개의 타입으로 묶여져 있다. 이를 Pair 라고 한다. 예를 들면</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">val pair = (&quot;answer&quot;, 42) &gt; pair: (String, Int) = (answer,42)

val (label, value) = pare &gt; label: String = answer | value : Int = 42</code></pre></div>
<p>위와 같이 타입으로도 쓰일 수 있고, 패턴으로도 사용될 수 있다. 이때 2 개 이상의 요소를 가지면 Tuples 라 한다. Tuples 는 다양하게 사용될 수 있는데, parameterized type 으로 사용될 경우, function applictaion 으로 사용될 경우, constructor 패턴으로 사용될 경우 각각</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">scala.Tuplen[T1, ..., Tn]
scala.Tuplen(e1, ..., en)
scala.Tuplen(p1, ..., pn)</code></pre></div>
<p>과 같이 사용할 수 있다. (여기서 Tuplen 의 n 은 파라미터 개수 ex. Tuple2)
튜플의 각 element 는 _1, _2 와 같이 접근할 수 있다.
이제 merge 메소드를 개선해보자.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">def merge(xs: List[Int], ys: List[Int]): List[Int] = (xs, ys) match {
  case (Nil, ys) =&gt; ys
  case (xs, Nil) =&gt; xs
  case (x :: xs1, y :: ys1) =&gt;
    if (x &lt; y) x :: merge(xs1, ys)
    else y :: merge(xs, ys1)
}</code></pre></div>
<p>훨씬 깔끔해졌다.</p>
<h2>5.3 Implicit Parameters</h2>
<p>이전 장에서 보았던 msort 는 List[Int] 타입으로 지정되어 있는데 parameterize 를 통해서 Int 말고도 다른 타입이 들어올 수 있도록 임의의 타입 T 로 변경해보자</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">object mergesort {
  def msort[T](xs: List[T]): List[T] = {
    val n = xs.length/2
    if (n == 0) xs
    else {
      def merge(xs: List[T], ys: List[T]): List[T] = (xs, ys) match {
        case (Nil, ys) =&gt; ys
        case (xs, Nil) =&gt; xs
        case (x :: xs1, y :: ys1) =&gt;
          if (x &lt; y) x :: merge(xs1, ys)
          else y :: merge(xs, ys1)
      }

      val (fst, snd) = xs splitAt n
      merge(msort(fst), msort(snd))
    }
  }

  val nums = List(2, -4, 5, 7, 1)
  msort(nums)
}</code></pre></div>
<p>x &#x3C; y 부분에서 에러가 발생한다. 왜냐하면 comparison ’&#x3C;‘가 임의의 타입 T 에 정의되어 있지 않기 때문이란다…
그래서 우리는 comparison 함수가 필요하다. 이 때 가장 유연한 방법은 msort 함수에 comparison operation 을 추가적인 파라미터로 붙이는 것이다. 아래처럼</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">def msort[T](xs: List[T])(lt: (T, T) =&gt; Boolean) = {
  ...
  merge(msort(fst)(lt), msort(snd)(lt))
}</code></pre></div>
<p>그래서 원래 mergesort 에 적용하면 다음과 같다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">object mergesort {
  def msort[T](xs: List[T])(lt: (T, T) =&gt; Boolean): List[T] = {
    val n = xs.length/2
    if (n == 0) xs
    else {
      def merge(xs: List[T], ys: List[T]): List[T] = (xs, ys) match {
        case (Nil, ys) =&gt; ys
        case (xs, Nil) =&gt; xs
        case (x :: xs1, y :: ys1) =&gt;
          if (lt(x, y)) x :: merge(xs1, ys)
          else y :: merge(xs, ys1)
      }

      val (fst, snd) = xs splitAt n
      merge(msort(fst)(lt), msort(snd)(lt))
    }
  }

  val nums = List(2, -4, 5, 7, 1)
  msort(nums)((x, y) =&gt; x &lt; y)

  val fruits = List(&quot;apple&quot;, &quot;pineapple&quot;, &quot;banana&quot;, &quot;orange&quot;)
  msort(fruits)((x, y) =&gt; x.compareTo(y) &lt; 0)
}</code></pre></div>
<p>이제 Int 타입 뿐만 아니라 String 과 같은 다른 타입도 정렬이 가능해졌다. 이 때 lt 에 들어오는 함수 파라미터에 타입 붙이는 걸 생략해도 되는데, 컴파일러가 앞에 있는 리스트의 타입을 보고 유추할 수 있기 때문이란다. 즉 파라미터 셋의 마지막에 function value 가 들어오게 되면, 컴파일러가 타입 체크를 미뤄버린다.</p>
<h3>scala.math.Ordering[T]</h3>
<p>사실 ordering 을 위한 스탠다드 라이브러리 클래스가 있다.</p>
<blockquote>
<p>scala.math.Ordering[T]</p>
</blockquote>
<p>그래서 lt 명령어를 parameterizing 하는 대신 Orderging 클래스로 parameterize 할 수 있다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">def msort[T](xs: List[T])(ord: Ordering) =

  def merge(xs: List[T], ys: List[T]) =
    ... if (ord.lt(x, y)) ...

  ... merge(msort(fst)(ord), msort(snd)(ord)) ...</code></pre></div>
<h3>implicit</h3>
<p>대체로 완성된 느낌이 나지만, Ordering 함수가 처음 콜 될때부터 계속 전달되는게 좀 비효율적으로 보인다. 그래서 여기에다가 또하나를 추가해보자.
ord 파라미터에 implicit(절대적인이란 뜻) 키워드를 앞에 붙여보자. 그러면, 함수를 실제로 호출하는 부분에서 실제 파라미터를 넣어줄 필요가 없다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">def msort[T](xs: List[T])(implicit ord: Ordering) =

  def merge(xs: List[T], ys: List[T]) =
    ... if (ord.lt(x, y)) ...

  ... merge(msort(fst), msort(snd)) ...

val nums = List(2, -4, 5, 7, 1)
msort(nums)</code></pre></div>
<p>더 간결해졌다.</p>
<h3>Rules for Implicit Parameters</h3>
<p>타입이 T 인 implicit 파라미터가 있을때, 컴파일러는</p>
<blockquote>
<p>(1) implicit 이 쓰인 파라미터에 (2) T 와 호환되는 타입을 가지고 (3) function call 에서 보이거나 T 와 관련된 companion 오브젝트(클래스와 객체 이름이 같은 오브젝트)에서
single implicit definition 을 찾는다. 즉, Ordering[Int]가 함수 call 의 파라미터로 존재하지 않지만, implicit 으로 처리되어 어딘가에 존재하게 된다.</p>
</blockquote>
<h2>5.4 Higher-Order List Functions</h2>
<p>위에서 보았던 예제들은 종종 비슷한 구조를 보여준다. 요약해보면</p>
<ul>
<li>리스트의 각 element 를 변경하는 것</li>
<li>어떤 조건을 만족하는 모든 element 의 리스트를 구하는 것</li>
<li>연산자를 사용하여 element 들을 결합하는 것</li>
</ul>
<p>함수형 언어는 higer-order functinos 패턴을 이용하는 generic function 을 만들 수 있다.</p>
<p>첫번째 예제는 각 요소를 multiply 하는 것이다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">def scaleList(xs: List[Double], factor: Double): List[Double] = xs match {
  case Nil =&gt; xs
  case y :: ys =&gt; y * factor :: scaleList(ys, factor)
}</code></pre></div>
<h3>Map</h3>
<p>위 예제는 list 의 map 메서드를 이용하여 만들 수 있다.
map 메서드의 구조를 살펴보면 아래와 같다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">abstract class List[T] { ...
  def map[U](f: T =&gt; U): List[U] = this match {
    case Nil =&gt; this
    case x :: xs =&gt; f(x) :: xs.map(f)
  }
}</code></pre></div>
<p>파라미터로 들어온 함수 f 가 각 element 에 적용되어서 새로운 리스트를 만들어 내는 함수가 바로 map 이다. map 메서드를 이용하면 훨씬 간단하게 작성할 수 있다</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">def scaleList(xs: List[Double], factor: Double) =
  xs.map(x =&gt; x * factor)</code></pre></div>
<p>또하나의 예제를 살펴보자</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">def squareList(xs: List[Int]): List[Int] = xs match {
  case Nil =&gt; Nil
  case y :: ys =&gt; y * y :: squareList(ys)
}

def squareList(xs: List[Int]): List[Int] =
  xs map (y =&gt; y * y)</code></pre></div>
<h3>Filtering</h3>
<p>필터링은 어떤 조건에 맞는 element 를 모아 새로운 리스트를 만들어 내는 메서드이다.
0 보다 큰수만 필터링 하는 다음의 함수를 보자</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">def posElems(xs: List[Int]): List[Int] = xs match {
  case Nil =&gt; xs
  case y :: ys =&gt; if (y &gt; 0) y :: posElems(ys) else posElems(ys)
}</code></pre></div>
<p>필터를 이용하면 간단하게 해결할 수 있다. 우선은 filter 메서드가 어떻게 생겼는지부터 살펴보도록 하자.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">abstract class List[T] {
  ...
  def filter(p: T =&gt; Boolean): List[T] = this match {
    case Nil =&gt; this
    case x :: xs =&gt; if (p(x)) x :: xs.filter(p) else xs.filter(p)
  }
}</code></pre></div>
<p>필터는 특정조건함수(p)가 true 이면 :: 연산자를 이용하여 리스트에 붙이고 false 이면 제외하는 방식으로 새로운 리스트를 만들어간다.
그럼 위에서 보았던 posElems 를 filter 를 이용해 재구성해보자</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">def posElems(xs: List[Int]): List[Int] =
  xs filter(x =&gt; x &gt; 0)</code></pre></div>
<p>그외에 유용한 메서드 목록은 아래와 같다.</p>
<ul>
<li>xs filterNot p xs filter (x => !p(x))와 같다.</li>
<li>xs partition p (xs filter p, xs filterNot) 튜플</li>
<li>xs takeWhile p p 를 만족하는 요소들의 가장 긴 리스트</li>
<li>xs dropWhile p p 를 만족하는 요소들의 나머지</li>
<li>xs span p (xs takeWhile p, xs dropWhile p) 튜플</li>
</ul>
<p>예를 들어보자</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">scala&gt; val nums = List(2, -4, 5, 7, 1)
nums: List[Int] = List(2, -4, 5, 7, 1)

scala&gt; nums filter (x =&gt; x &gt; 0)
res0: List[Int] = List(2, 5, 7, 1)

scala&gt; nums filterNot (x =&gt; x &gt; 0)
res1: List[Int] = List(-4)

scala&gt; nums partition (x =&gt; x &gt; 0)
res2: (List[Int], List[Int]) = (List(2, 5, 7, 1),List(-4))

scala&gt; nums takeWhile (x =&gt; x &gt; 0)
res3: List[Int] = List(2)

scala&gt; nums dropWhile (x =&gt; x &gt; 0)
res4: List[Int] = List(-4, 5, 7, 1)

scala&gt; nums span (x =&gt; x &gt; 0)
res5: (List[Int], List[Int]) = (List(2),List(-4, 5, 7, 1))</code></pre></div>
<h2>5.5 Reductino of Lists</h2>
<p>5.4 절에 이어 higr-order Function 패턴을 이용한 List 메서드에 대해서 계속 알아보도록 하자. 5.4 에서 보았던 세가지 패턴 중에 마지막인 element 를 결합하는 방법들에 대한 내용들이 되겠다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">sum(List(x1, ..., xn))      = 0 + x1 + ... + xn
product(List(x1, ..., xn))  = 1 * x1 * ... * xn</code></pre></div>
<h3>ReduceLeft</h3>
<p>각 요소를 더하거나 곱하는 sum 과 product 메서드가 있다. 이를 ReduceLeft 메서드를 이용하여 구현해보도록하자. ReduceLeft 메서드는 아래와 같은 구조를 가진다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">List(x1, ..., xn) reduceLeft op = (...(x1 op x2) op ... ) op xn

// 위의 구조를 이용하면 sum과 product는 아래와 같이 구현가능하다.
def sum(xs: List[Int]) = (0 :: xs) reduceLeft ((x, y) =&gt; x + y) // or (_ + _)
def product(xs: List[Int]) = (1 :: xs) reduceLeft ((x, y) =&gt; x * y) // or (_ * _)</code></pre></div>
<h3>FoldLeft</h3>
<p>foldLeft 함수는 reduceLeft 함수에 비해 좀더 일반적인 형태이다. foldLeft 가 reduceLeft 와 비슷하지만, foldLeft 는 하나의 accumulator(z)를 가진다.
구조는 아래와 같다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">(List(x1, ..., xn) foldLeft z)(op) = (...(z op x1) op ...) op xn</code></pre></div>
<p>foldLeft 로 sum 과 product 를 구현해보자</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">def sum(xs: List[Int]) = (xs foldLeft 0) (_ + _)
def product(xs: List[Int]) = (xs foldLeft 1) (_ * _)</code></pre></div>
<p>foldLeft 와 reduceLeft 는 List class 에서 다음과 같이 구현된다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">abstract class List[T] { ...
  def reduceLeft(op: (T, T) =&gt; T): T = this match {
    case Nil =&gt; throw new Error(&quot;Nil.reduceLeft&quot;)
    case x :: xs =&gt; (xs foldLeft x)(op)
  }
  def foldLeft[U](z: U)(op: (U, T) =&gt; U): U = this match {
    case Nil =&gt; z
    case x :: xs =&gt; (xs foldLeft op(z, x))(op)
  }
}</code></pre></div>
<p>reduceLeft 도 내부적으로는 foldLeft 메서드를 이용한다.
그리고 reduceRight 와 foldRight 도 위의 두 메서드와 비슷한 구조로 동작한다. 대신 좌측이 아닌 우측(뒤)부터 reduce 한다.</p>
<h3>Difference between FoldLeft and FoldRight</h3>
<p>foldLeft 와 foldRight 는 무엇이 다를까? 기본적으로 sum 을 가지고 생각했을때, 왼쪽부터 더하는 것이나 오른쪽부터 더하는 것이나 결과는 동일하다. 하지만 어떤 경우에는 둘 중 하나만 적절할 때도 있다. 아래의 예제를 보자</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">def concat[T](xs: List[T], ys: List[T]): List[T] = (xs foldRight ys) (_ :: _)</code></pre></div>
<p>위의 함수에서 foldRight 를 foldLeft 로 변경하면, 타입에러가 발생한다.
1 :: List(2)는 가능하지만 List(1) :: 2 는 불가능한 연산이기 때문이다.</p>
<h2>5.6 Reasoning About Concat</h2>
<p>이번 챕터에서는 어떤 연산자(or 함수)가 정확히 참임을 증명할 수 있는지에 대해 알아보도록 한다.
일반적으로 natural induction(자연 귀납?)에 의해 증명하는 방법의 예는 다음과 같다.</p>
<ul>
<li>P(n)이 모든 n >= b 에대해서</li>
<li>P(b)가 참이다. (base case)</li>
<li>이때, 모든 n >= b 에 대해서 P(n)이 참이면, P(n + 1)도 참이다.</li>
</ul>
<h3>Referential Transparency (참조 투명성)</h3>
<p>순수한 함수형 프로그램에서는 사이드 이펙트가 없기 때문에, reduction steps 가 어떤 부분에 대해서도 동일하게 적용된다. 이를 Referential Transparency(참조 투명성)이라 한다.</p>
<p>structural induction 은 natural induction 과 비슷하다.
structural induction 은 다음과 같이 동작한다.</p>
<ul>
<li>P(xs)이 모든 리스트 xs 에 대해서</li>
<li>P(Nil)이 hold 된다면</li>
<li>리스트 xs 와 어떤 element x 에 대해서 P(xs)가 hold 되다면, P(x :: xs) 또한 hold 된다.</li>
</ul>
<p>이제 concat 함수를 다시 살펴보자</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">def concat[T](xs: List[T], ys: List[T]) = xs match {
  case List() =&gt; ys
  case x :: xs1 =&gt; x :: concat(xs1, ys)
}</code></pre></div>
<p>그리고 다음의 수식을 structural induction 으로 증명해보자</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">(xs ++ ys) ++ zs = xs ++ (ys ++ zs)
// ++(concat) 연산자의 두가지 정리를 참고한다
// Nil ++ ys = ys
// (x :: xs1) ++ ys = x :: (xs1 ++ ys)</code></pre></div>
<p>우선 xs 에 Nil 이 들어갈 때인 P(Nil)을 살펴보자</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// left
(Nil ++ ys) ++ zs
= ys ++ zs      // by 1st clause of ++

// right
Nil ++ (ys ++ zs)
= ys ++ zs      // by 1st clause of ++</code></pre></div>
<p>다음은 xs 대신에 induction step 인 ‘x :: xs’를 넣어보자</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// left
((x :: xs) ++ ys) + zs
= (x :: (xs ++ ys)) ++ zs      // by 2st clause of ++
= x :: ((xs ++ ys) ++ zs)      // by 2st clause of ++
= x :: (xs ++ (ys ++ zs))    // by induction hypothesis
// right
(x :: xs) ++ (ys ++ zs)
= x :: (xs ++ (ys ++ zs))    // by 2st clause of ++</code></pre></div>
<p>좌변과 우변이 같으므로 함수 P 는 증명됨</p>
<h2>5.7 A Larger Equational Proof on Lists</h2>
<p>좀더 까다로운 function 인 reverse 에 대해서 알아보자
다음의 두가지 amenable 한 사실을 가지고 그 아래의 식을 증명해보자</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">(1) Nil.reverse = Nil               // 1st clause
(2) (x :: xs).reverse = xs.reverse ++ List(x)   // 2nd clause

// 다음을 증명
xs.reverse.reverse = xs</code></pre></div>
<p>base case 는 단순하다</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Nil.reverse.reverse
= Nil.reverse
= Nil</code></pre></div>
<p>이번엔 reduction step 이다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// left
(x :: xs).reverse.reverse
= (xs.reverse ++ List(x)).reverse     // by 2nd clause of reverse

// right
x :: xs
= x :: xs.reverse.reverse       // by induction hypothesis (가설에 의해)</code></pre></div>
<p>두 개를 합쳐보면,</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">(xs.reverse ++ List(x)).reverse = x :: xs.reverse.reverse</code></pre></div>
<p>직접적으로 induction 이 불가하므로, 동일한 연산을 일반화 시켜보자
여기서는 xs.reverse 를 ys 로 치환하도록 하자. 그럼 수식이 아래와 같이 바뀐다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">(ys ++ List(x)).reverse = x :: ys.reverse</code></pre></div>
<p>그럼 이제 두번째 induction 인 ys 를 증명하면 동일함을 입증할 수 있겠다.
우선 base case 부터 살펴보자</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// left
(Nil ++ List(x)).reverse
= List(x).reverse       // by 1st clause of ++
= (x :: Nil).reverse    // by definition of List
= Nil.reverse ++ List(x)
= Nil ++ (x :: Nil)     // by 2nd clause of reverse
= x :: Nil          // by 1st clause of ++
= x :: Nil.reverse      // by 1st clause of reverse</code></pre></div>
<p>결과는 우변의 ys 에 Nil 을 집어넣었을 때와 동일한 결과과 도출되었으므로 base case 를 증명되었다. 이제 reduction step 으로 가보자</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// left
((y :: ys) ++ List(x)).reverse
= (y :: (ys ++ List(x))).reverse    // by 2nd clause of ++
= (ys ++ List(x)).reverse ++ List(y)  // by 2nd clause reverse
= (x :: ys.reverse) ++ List(y)      // by the induction hypothesis
= x :: (ys.reverse ++ List(y))      // by 1st clause of ++
= x :: (y :: ys).reverse        // by 2nd clause of reverse

// right
x :: (y :: ys).reverse</code></pre></div>
<p>좌변과 우변이 동일하므로 증명되었다.</p>
<h3>Exercise</h3>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">(xs ++ ys) map f = (xs map f) ++ (ys map f)

Nil map f = Nil
(x :: xs) map f = f(x) :: (xs map f)</code></pre></div>
<p>base case..</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// left
(Nil ++ ys) map f
= ys map f

// right
(Nil map f) ++ (ys map f)
= Nil ++ (ys map f)
= ys map f</code></pre></div>
<p>reduction step</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// left
((x :: xs) ++ ys) map f
= (x :: (xs ++ ys)) map f
= f(x) :: ((xs ++ ys) map f)
= f(x) :: ((xs map f) ++ (ys map f))

// right
((x :: xs) map f) ++ (ys map f)
= (f(x) :: (xs map f)) ++ (ys map f)
= f(x) :: ((xs map f) ++ (ys map f))</code></pre></div>
<p>base case, reduction step 모두 좌변과 우변이 같으므로 같음이 증명되었다.</p></div><hr style="margin-bottom:1.75rem"/><ul style="display:flex;flex-wrap:wrap;justify-content:space-between;list-style:none;padding:0"><li><a rel="prev" href="/2016/07/26/functional-programming-in-scala-week4/">← <!-- -->Functional Programming in Scala week 4</a></li><li><a rel="next" href="/2016/07/26/functional-programming-in-scala-week6/">Functional Programming in Scala week 6<!-- --> →</a></li></ul></div></div></div><script>
  
  
  if(true) {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  }
  if (typeof ga === "function") {
    ga('create', 'UA-50048807-2', 'auto', {});
      }
      </script><script id="gatsby-script-loader">/*<![CDATA[*/window.page={"componentChunkName":"component---src-templates-blog-post-js","jsonName":"2016-07-26-functional-programming-in-scala-week-5-0da","path":"/2016/07/26/functional-programming-in-scala-week5/"};window.dataPath="534/path---2016-07-26-functional-programming-in-scala-week-5-0-da-971-CqU9JkrWMKOcldeqn2M9huK1qE0";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-351efcfeb4f54983a1ef.js"],"component---node-modules-gatsby-plugin-offline-app-shell-js":["/component---node-modules-gatsby-plugin-offline-app-shell-js-31ee4b698d609e346331.js"],"component---src-templates-blog-post-js":["/component---src-templates-blog-post-js-fee95fd76061ab2b91a6.js"],"component---src-pages-404-js":["/component---src-pages-404-js-bd47a77552aee32af5f8.js"],"component---src-pages-index-js":["/component---src-pages-index-js-7c4638696cb877443516.js"]};/*]]>*/</script><script src="/webpack-runtime-589a7ddf210818ed526a.js" async=""></script><script src="/app-351efcfeb4f54983a1ef.js" async=""></script><script src="/component---src-templates-blog-post-js-fee95fd76061ab2b91a6.js" async=""></script><script src="/0-8bf3a8bc80e5222607e7.js" async=""></script></body></html>